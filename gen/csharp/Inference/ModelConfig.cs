// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: ssn/type/triton/model_config.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Inference {

  /// <summary>Holder for reflection information generated from ssn/type/triton/model_config.proto</summary>
  public static partial class ModelConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for ssn/type/triton/model_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ModelConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJzc24vdHlwZS90cml0b24vbW9kZWxfY29uZmlnLnByb3RvEglpbmZlcmVu",
            "Y2UiwAEKEE1vZGVsUmF0ZUxpbWl0ZXISQgoJcmVzb3VyY2VzGAEgAygLMiQu",
            "aW5mZXJlbmNlLk1vZGVsUmF0ZUxpbWl0ZXIuUmVzb3VyY2VSCXJlc291cmNl",
            "cxIaCghwcmlvcml0eRgCIAEoDVIIcHJpb3JpdHkaTAoIUmVzb3VyY2USEgoE",
            "bmFtZRgBIAEoCVIEbmFtZRIWCgZnbG9iYWwYAiABKAhSBmdsb2JhbBIUCgVj",
            "b3VudBgDIAEoDVIFY291bnQi7QQKEk1vZGVsSW5zdGFuY2VHcm91cBISCgRu",
            "YW1lGAEgASgJUgRuYW1lEjYKBGtpbmQYBCABKA4yIi5pbmZlcmVuY2UuTW9k",
            "ZWxJbnN0YW5jZUdyb3VwLktpbmRSBGtpbmQSFAoFY291bnQYAiABKAVSBWNv",
            "dW50Ej4KDHJhdGVfbGltaXRlchgGIAEoCzIbLmluZmVyZW5jZS5Nb2RlbFJh",
            "dGVMaW1pdGVyUgtyYXRlTGltaXRlchISCgRncHVzGAMgAygFUgRncHVzEloK",
            "EXNlY29uZGFyeV9kZXZpY2VzGAggAygLMi0uaW5mZXJlbmNlLk1vZGVsSW5z",
            "dGFuY2VHcm91cC5TZWNvbmRhcnlEZXZpY2VSEHNlY29uZGFyeURldmljZXMS",
            "GAoHcHJvZmlsZRgFIAMoCVIHcHJvZmlsZRIYCgdwYXNzaXZlGAcgASgIUgdw",
            "YXNzaXZlEh8KC2hvc3RfcG9saWN5GAkgASgJUgpob3N0UG9saWN5GqwBCg9T",
            "ZWNvbmRhcnlEZXZpY2USVQoEa2luZBgBIAEoDjJBLmluZmVyZW5jZS5Nb2Rl",
            "bEluc3RhbmNlR3JvdXAuU2Vjb25kYXJ5RGV2aWNlLlNlY29uZGFyeURldmlj",
            "ZUtpbmRSBGtpbmQSGwoJZGV2aWNlX2lkGAIgASgDUghkZXZpY2VJZCIlChNT",
            "ZWNvbmRhcnlEZXZpY2VLaW5kEg4KCktJTkRfTlZETEEQACJBCgRLaW5kEg0K",
            "CUtJTkRfQVVUTxAAEgwKCEtJTkRfR1BVEAESDAoIS0lORF9DUFUQAhIOCgpL",
            "SU5EX01PREVMEAMiKgoSTW9kZWxUZW5zb3JSZXNoYXBlEhQKBXNoYXBlGAEg",
            "AygDUgVzaGFwZSKEAwoKTW9kZWxJbnB1dBISCgRuYW1lGAEgASgJUgRuYW1l",
            "EjAKCWRhdGFfdHlwZRgCIAEoDjITLmluZmVyZW5jZS5EYXRhVHlwZVIIZGF0",
            "YVR5cGUSNAoGZm9ybWF0GAMgASgOMhwuaW5mZXJlbmNlLk1vZGVsSW5wdXQu",
            "Rm9ybWF0UgZmb3JtYXQSEgoEZGltcxgEIAMoA1IEZGltcxI3CgdyZXNoYXBl",
            "GAUgASgLMh0uaW5mZXJlbmNlLk1vZGVsVGVuc29yUmVzaGFwZVIHcmVzaGFw",
            "ZRImCg9pc19zaGFwZV90ZW5zb3IYBiABKAhSDWlzU2hhcGVUZW5zb3ISLAoS",
            "YWxsb3dfcmFnZ2VkX2JhdGNoGAcgASgIUhBhbGxvd1JhZ2dlZEJhdGNoEhoK",
            "CG9wdGlvbmFsGAggASgIUghvcHRpb25hbCI7CgZGb3JtYXQSDwoLRk9STUFU",
            "X05PTkUQABIPCgtGT1JNQVRfTkhXQxABEg8KC0ZPUk1BVF9OQ0hXEAIi7wEK",
            "C01vZGVsT3V0cHV0EhIKBG5hbWUYASABKAlSBG5hbWUSMAoJZGF0YV90eXBl",
            "GAIgASgOMhMuaW5mZXJlbmNlLkRhdGFUeXBlUghkYXRhVHlwZRISCgRkaW1z",
            "GAMgAygDUgRkaW1zEjcKB3Jlc2hhcGUYBSABKAsyHS5pbmZlcmVuY2UuTW9k",
            "ZWxUZW5zb3JSZXNoYXBlUgdyZXNoYXBlEiUKDmxhYmVsX2ZpbGVuYW1lGAQg",
            "ASgJUg1sYWJlbEZpbGVuYW1lEiYKD2lzX3NoYXBlX3RlbnNvchgGIAEoCFIN",
            "aXNTaGFwZVRlbnNvciKCAwoKQmF0Y2hJbnB1dBIuCgRraW5kGAEgASgOMhou",
            "aW5mZXJlbmNlLkJhdGNoSW5wdXQuS2luZFIEa2luZBIfCgt0YXJnZXRfbmFt",
            "ZRgCIAMoCVIKdGFyZ2V0TmFtZRIwCglkYXRhX3R5cGUYAyABKA4yEy5pbmZl",
            "cmVuY2UuRGF0YVR5cGVSCGRhdGFUeXBlEiEKDHNvdXJjZV9pbnB1dBgEIAMo",
            "CVILc291cmNlSW5wdXQizQEKBEtpbmQSFwoTQkFUQ0hfRUxFTUVOVF9DT1VO",
            "VBAAEiMKH0JBVENIX0FDQ1VNVUxBVEVEX0VMRU1FTlRfQ09VTlQQARItCilC",
            "QVRDSF9BQ0NVTVVMQVRFRF9FTEVNRU5UX0NPVU5UX1dJVEhfWkVSTxACEiQK",
            "IEJBVENIX01BWF9FTEVNRU5UX0NPVU5UX0FTX1NIQVBFEAMSFAoQQkFUQ0hf",
            "SVRFTV9TSEFQRRAEEhwKGEJBVENIX0lURU1fU0hBUEVfRkxBVFRFThAFIq4B",
            "CgtCYXRjaE91dHB1dBIfCgt0YXJnZXRfbmFtZRgBIAMoCVIKdGFyZ2V0TmFt",
            "ZRIvCgRraW5kGAIgASgOMhsuaW5mZXJlbmNlLkJhdGNoT3V0cHV0LktpbmRS",
            "BGtpbmQSIQoMc291cmNlX2lucHV0GAMgAygJUgtzb3VyY2VJbnB1dCIqCgRL",
            "aW5kEiIKHkJBVENIX1NDQVRURVJfV0lUSF9JTlBVVF9TSEFQRRAAIr4CChJN",
            "b2RlbFZlcnNpb25Qb2xpY3kSPgoGbGF0ZXN0GAEgASgLMiQuaW5mZXJlbmNl",
            "Lk1vZGVsVmVyc2lvblBvbGljeS5MYXRlc3RIAFIGbGF0ZXN0EjUKA2FsbBgC",
            "IAEoCzIhLmluZmVyZW5jZS5Nb2RlbFZlcnNpb25Qb2xpY3kuQWxsSABSA2Fs",
            "bBJECghzcGVjaWZpYxgDIAEoCzImLmluZmVyZW5jZS5Nb2RlbFZlcnNpb25Q",
            "b2xpY3kuU3BlY2lmaWNIAFIIc3BlY2lmaWMaKwoGTGF0ZXN0EiEKDG51bV92",
            "ZXJzaW9ucxgBIAEoDVILbnVtVmVyc2lvbnMaBQoDQWxsGiYKCFNwZWNpZmlj",
            "EhoKCHZlcnNpb25zGAEgAygDUgh2ZXJzaW9uc0IPCg1wb2xpY3lfY2hvaWNl",
            "IuYQChdNb2RlbE9wdGltaXphdGlvblBvbGljeRI+CgVncmFwaBgBIAEoCzIo",
            "LmluZmVyZW5jZS5Nb2RlbE9wdGltaXphdGlvblBvbGljeS5HcmFwaFIFZ3Jh",
            "cGgSTAoIcHJpb3JpdHkYAiABKA4yMC5pbmZlcmVuY2UuTW9kZWxPcHRpbWl6",
            "YXRpb25Qb2xpY3kuTW9kZWxQcmlvcml0eVIIcHJpb3JpdHkSOwoEY3VkYRgD",
            "IAEoCzInLmluZmVyZW5jZS5Nb2RlbE9wdGltaXphdGlvblBvbGljeS5DdWRh",
            "UgRjdWRhEm8KFmV4ZWN1dGlvbl9hY2NlbGVyYXRvcnMYBCABKAsyOC5pbmZl",
            "cmVuY2UuTW9kZWxPcHRpbWl6YXRpb25Qb2xpY3kuRXhlY3V0aW9uQWNjZWxl",
            "cmF0b3JzUhVleGVjdXRpb25BY2NlbGVyYXRvcnMSZQoTaW5wdXRfcGlubmVk",
            "X21lbW9yeRgFIAEoCzI1LmluZmVyZW5jZS5Nb2RlbE9wdGltaXphdGlvblBv",
            "bGljeS5QaW5uZWRNZW1vcnlCdWZmZXJSEWlucHV0UGlubmVkTWVtb3J5EmcK",
            "FG91dHB1dF9waW5uZWRfbWVtb3J5GAYgASgLMjUuaW5mZXJlbmNlLk1vZGVs",
            "T3B0aW1pemF0aW9uUG9saWN5LlBpbm5lZE1lbW9yeUJ1ZmZlclISb3V0cHV0",
            "UGlubmVkTWVtb3J5EkMKHmdhdGhlcl9rZXJuZWxfYnVmZmVyX3RocmVzaG9s",
            "ZBgHIAEoDVIbZ2F0aGVyS2VybmVsQnVmZmVyVGhyZXNob2xkEiUKDmVhZ2Vy",
            "X2JhdGNoaW5nGAggASgIUg1lYWdlckJhdGNoaW5nGh0KBUdyYXBoEhQKBWxl",
            "dmVsGAEgASgFUgVsZXZlbBrBBgoEQ3VkYRIWCgZncmFwaHMYASABKAhSBmdy",
            "YXBocxIoChBidXN5X3dhaXRfZXZlbnRzGAIgASgIUg5idXN5V2FpdEV2ZW50",
            "cxJQCgpncmFwaF9zcGVjGAMgAygLMjEuaW5mZXJlbmNlLk1vZGVsT3B0aW1p",
            "emF0aW9uUG9saWN5LkN1ZGEuR3JhcGhTcGVjUglncmFwaFNwZWMSLAoSb3V0",
            "cHV0X2NvcHlfc3RyZWFtGAQgASgIUhBvdXRwdXRDb3B5U3RyZWFtGvYECglH",
            "cmFwaFNwZWMSHQoKYmF0Y2hfc2l6ZRgBIAEoBVIJYmF0Y2hTaXplElIKBWlu",
            "cHV0GAIgAygLMjwuaW5mZXJlbmNlLk1vZGVsT3B0aW1pemF0aW9uUG9saWN5",
            "LkN1ZGEuR3JhcGhTcGVjLklucHV0RW50cnlSBWlucHV0EmgKEWdyYXBoX2xv",
            "d2VyX2JvdW5kGAMgASgLMjwuaW5mZXJlbmNlLk1vZGVsT3B0aW1pemF0aW9u",
            "UG9saWN5LkN1ZGEuR3JhcGhTcGVjLkxvd2VyQm91bmRSD2dyYXBoTG93ZXJC",
            "b3VuZBoZCgVTaGFwZRIQCgNkaW0YASADKANSA2RpbRr9AQoKTG93ZXJCb3Vu",
            "ZBIdCgpiYXRjaF9zaXplGAEgASgFUgliYXRjaFNpemUSXQoFaW5wdXQYAiAD",
            "KAsyRy5pbmZlcmVuY2UuTW9kZWxPcHRpbWl6YXRpb25Qb2xpY3kuQ3VkYS5H",
            "cmFwaFNwZWMuTG93ZXJCb3VuZC5JbnB1dEVudHJ5UgVpbnB1dBpxCgpJbnB1",
            "dEVudHJ5EhAKA2tleRgBIAEoCVIDa2V5Ek0KBXZhbHVlGAIgASgLMjcuaW5m",
            "ZXJlbmNlLk1vZGVsT3B0aW1pemF0aW9uUG9saWN5LkN1ZGEuR3JhcGhTcGVj",
            "LlNoYXBlUgV2YWx1ZToCOAEacQoKSW5wdXRFbnRyeRIQCgNrZXkYASABKAlS",
            "A2tleRJNCgV2YWx1ZRgCIAEoCzI3LmluZmVyZW5jZS5Nb2RlbE9wdGltaXph",
            "dGlvblBvbGljeS5DdWRhLkdyYXBoU3BlYy5TaGFwZVIFdmFsdWU6AjgBGvYD",
            "ChVFeGVjdXRpb25BY2NlbGVyYXRvcnMSgAEKGWdwdV9leGVjdXRpb25fYWNj",
            "ZWxlcmF0b3IYASADKAsyRC5pbmZlcmVuY2UuTW9kZWxPcHRpbWl6YXRpb25Q",
            "b2xpY3kuRXhlY3V0aW9uQWNjZWxlcmF0b3JzLkFjY2VsZXJhdG9yUhdncHVF",
            "eGVjdXRpb25BY2NlbGVyYXRvchKAAQoZY3B1X2V4ZWN1dGlvbl9hY2NlbGVy",
            "YXRvchgCIAMoCzJELmluZmVyZW5jZS5Nb2RlbE9wdGltaXphdGlvblBvbGlj",
            "eS5FeGVjdXRpb25BY2NlbGVyYXRvcnMuQWNjZWxlcmF0b3JSF2NwdUV4ZWN1",
            "dGlvbkFjY2VsZXJhdG9yGtYBCgtBY2NlbGVyYXRvchISCgRuYW1lGAEgASgJ",
            "UgRuYW1lEnQKCnBhcmFtZXRlcnMYAiADKAsyVC5pbmZlcmVuY2UuTW9kZWxP",
            "cHRpbWl6YXRpb25Qb2xpY3kuRXhlY3V0aW9uQWNjZWxlcmF0b3JzLkFjY2Vs",
            "ZXJhdG9yLlBhcmFtZXRlcnNFbnRyeVIKcGFyYW1ldGVycxo9Cg9QYXJhbWV0",
            "ZXJzRW50cnkSEAoDa2V5GAEgASgJUgNrZXkSFAoFdmFsdWUYAiABKAlSBXZh",
            "bHVlOgI4ARosChJQaW5uZWRNZW1vcnlCdWZmZXISFgoGZW5hYmxlGAEgASgI",
            "UgZlbmFibGUiSQoNTW9kZWxQcmlvcml0eRIUChBQUklPUklUWV9ERUZBVUxU",
            "EAASEAoMUFJJT1JJVFlfTUFYEAESEAoMUFJJT1JJVFlfTUlOEAIiqgIKEE1v",
            "ZGVsUXVldWVQb2xpY3kSUAoOdGltZW91dF9hY3Rpb24YASABKA4yKS5pbmZl",
            "cmVuY2UuTW9kZWxRdWV1ZVBvbGljeS5UaW1lb3V0QWN0aW9uUg10aW1lb3V0",
            "QWN0aW9uEkAKHGRlZmF1bHRfdGltZW91dF9taWNyb3NlY29uZHMYAiABKARS",
            "GmRlZmF1bHRUaW1lb3V0TWljcm9zZWNvbmRzEjQKFmFsbG93X3RpbWVvdXRf",
            "b3ZlcnJpZGUYAyABKAhSFGFsbG93VGltZW91dE92ZXJyaWRlEiQKDm1heF9x",
            "dWV1ZV9zaXplGAQgASgNUgxtYXhRdWV1ZVNpemUiJgoNVGltZW91dEFjdGlv",
            "bhIKCgZSRUpFQ1QQABIJCgVERUxBWRABIrcEChRNb2RlbER5bmFtaWNCYXRj",
            "aGluZxIwChRwcmVmZXJyZWRfYmF0Y2hfc2l6ZRgBIAMoBVIScHJlZmVycmVk",
            "QmF0Y2hTaXplEj8KHG1heF9xdWV1ZV9kZWxheV9taWNyb3NlY29uZHMYAiAB",
            "KARSGW1heFF1ZXVlRGVsYXlNaWNyb3NlY29uZHMSKwoRcHJlc2VydmVfb3Jk",
            "ZXJpbmcYAyABKAhSEHByZXNlcnZlT3JkZXJpbmcSJwoPcHJpb3JpdHlfbGV2",
            "ZWxzGAQgASgNUg5wcmlvcml0eUxldmVscxI0ChZkZWZhdWx0X3ByaW9yaXR5",
            "X2xldmVsGAUgASgNUhRkZWZhdWx0UHJpb3JpdHlMZXZlbBJNChRkZWZhdWx0",
            "X3F1ZXVlX3BvbGljeRgGIAEoCzIbLmluZmVyZW5jZS5Nb2RlbFF1ZXVlUG9s",
            "aWN5UhJkZWZhdWx0UXVldWVQb2xpY3kSbAoVcHJpb3JpdHlfcXVldWVfcG9s",
            "aWN5GAcgAygLMjguaW5mZXJlbmNlLk1vZGVsRHluYW1pY0JhdGNoaW5nLlBy",
            "aW9yaXR5UXVldWVQb2xpY3lFbnRyeVITcHJpb3JpdHlRdWV1ZVBvbGljeRpj",
            "ChhQcmlvcml0eVF1ZXVlUG9saWN5RW50cnkSEAoDa2V5GAEgASgNUgNrZXkS",
            "MQoFdmFsdWUYAiABKAsyGy5pbmZlcmVuY2UuTW9kZWxRdWV1ZVBvbGljeVIF",
            "dmFsdWU6AjgBItgMChVNb2RlbFNlcXVlbmNlQmF0Y2hpbmcSSQoGZGlyZWN0",
            "GAMgASgLMi8uaW5mZXJlbmNlLk1vZGVsU2VxdWVuY2VCYXRjaGluZy5TdHJh",
            "dGVneURpcmVjdEgAUgZkaXJlY3QSSQoGb2xkZXN0GAQgASgLMi8uaW5mZXJl",
            "bmNlLk1vZGVsU2VxdWVuY2VCYXRjaGluZy5TdHJhdGVneU9sZGVzdEgAUgZv",
            "bGRlc3QSQwoebWF4X3NlcXVlbmNlX2lkbGVfbWljcm9zZWNvbmRzGAEgASgE",
            "UhttYXhTZXF1ZW5jZUlkbGVNaWNyb3NlY29uZHMSUgoNY29udHJvbF9pbnB1",
            "dBgCIAMoCzItLmluZmVyZW5jZS5Nb2RlbFNlcXVlbmNlQmF0Y2hpbmcuQ29u",
            "dHJvbElucHV0Ugxjb250cm9sSW5wdXQSPAoFc3RhdGUYBSADKAsyJi5pbmZl",
            "cmVuY2UuTW9kZWxTZXF1ZW5jZUJhdGNoaW5nLlN0YXRlUgVzdGF0ZRrvAgoH",
            "Q29udHJvbBJBCgRraW5kGAEgASgOMi0uaW5mZXJlbmNlLk1vZGVsU2VxdWVu",
            "Y2VCYXRjaGluZy5Db250cm9sLktpbmRSBGtpbmQSKAoQaW50MzJfZmFsc2Vf",
            "dHJ1ZRgCIAMoBVIOaW50MzJGYWxzZVRydWUSJgoPZnAzMl9mYWxzZV90cnVl",
            "GAMgAygCUg1mcDMyRmFsc2VUcnVlEiYKD2Jvb2xfZmFsc2VfdHJ1ZRgFIAMo",
            "CFINYm9vbEZhbHNlVHJ1ZRIwCglkYXRhX3R5cGUYBCABKA4yEy5pbmZlcmVu",
            "Y2UuRGF0YVR5cGVSCGRhdGFUeXBlInUKBEtpbmQSGgoWQ09OVFJPTF9TRVFV",
            "RU5DRV9TVEFSVBAAEhoKFkNPTlRST0xfU0VRVUVOQ0VfUkVBRFkQARIYChRD",
            "T05UUk9MX1NFUVVFTkNFX0VORBACEhsKF0NPTlRST0xfU0VRVUVOQ0VfQ09S",
            "UklEEAMaZgoMQ29udHJvbElucHV0EhIKBG5hbWUYASABKAlSBG5hbWUSQgoH",
            "Y29udHJvbBgCIAMoCzIoLmluZmVyZW5jZS5Nb2RlbFNlcXVlbmNlQmF0Y2hp",
            "bmcuQ29udHJvbFIHY29udHJvbBq0AQoMSW5pdGlhbFN0YXRlEjAKCWRhdGFf",
            "dHlwZRgBIAEoDjITLmluZmVyZW5jZS5EYXRhVHlwZVIIZGF0YVR5cGUSEgoE",
            "ZGltcxgCIAMoA1IEZGltcxIdCgl6ZXJvX2RhdGEYAyABKAhIAFIIemVyb0Rh",
            "dGESHQoJZGF0YV9maWxlGAQgASgJSABSCGRhdGFGaWxlEhIKBG5hbWUYBSAB",
            "KAlSBG5hbWVCDAoKc3RhdGVfZGF0YRrhAQoFU3RhdGUSHQoKaW5wdXRfbmFt",
            "ZRgBIAEoCVIJaW5wdXROYW1lEh8KC291dHB1dF9uYW1lGAIgASgJUgpvdXRw",
            "dXROYW1lEjAKCWRhdGFfdHlwZRgDIAEoDjITLmluZmVyZW5jZS5EYXRhVHlw",
            "ZVIIZGF0YVR5cGUSEgoEZGltcxgEIAMoA1IEZGltcxJSCg1pbml0aWFsX3N0",
            "YXRlGAUgAygLMi0uaW5mZXJlbmNlLk1vZGVsU2VxdWVuY2VCYXRjaGluZy5J",
            "bml0aWFsU3RhdGVSDGluaXRpYWxTdGF0ZRqLAQoOU3RyYXRlZ3lEaXJlY3QS",
            "PwocbWF4X3F1ZXVlX2RlbGF5X21pY3Jvc2Vjb25kcxgBIAEoBFIZbWF4UXVl",
            "dWVEZWxheU1pY3Jvc2Vjb25kcxI4ChhtaW5pbXVtX3Nsb3RfdXRpbGl6YXRp",
            "b24YAiABKAJSFm1pbmltdW1TbG90VXRpbGl6YXRpb24auwEKDlN0cmF0ZWd5",
            "T2xkZXN0EjYKF21heF9jYW5kaWRhdGVfc2VxdWVuY2VzGAEgASgFUhVtYXhD",
            "YW5kaWRhdGVTZXF1ZW5jZXMSMAoUcHJlZmVycmVkX2JhdGNoX3NpemUYAiAD",
            "KAVSEnByZWZlcnJlZEJhdGNoU2l6ZRI/ChxtYXhfcXVldWVfZGVsYXlfbWlj",
            "cm9zZWNvbmRzGAMgASgEUhltYXhRdWV1ZURlbGF5TWljcm9zZWNvbmRzQhEK",
            "D3N0cmF0ZWd5X2Nob2ljZSKpAwoPTW9kZWxFbnNlbWJsaW5nEjMKBHN0ZXAY",
            "ASADKAsyHy5pbmZlcmVuY2UuTW9kZWxFbnNlbWJsaW5nLlN0ZXBSBHN0ZXAa",
            "4AIKBFN0ZXASHQoKbW9kZWxfbmFtZRgBIAEoCVIJbW9kZWxOYW1lEiMKDW1v",
            "ZGVsX3ZlcnNpb24YAiABKANSDG1vZGVsVmVyc2lvbhJKCglpbnB1dF9tYXAY",
            "AyADKAsyLS5pbmZlcmVuY2UuTW9kZWxFbnNlbWJsaW5nLlN0ZXAuSW5wdXRN",
            "YXBFbnRyeVIIaW5wdXRNYXASTQoKb3V0cHV0X21hcBgEIAMoCzIuLmluZmVy",
            "ZW5jZS5Nb2RlbEVuc2VtYmxpbmcuU3RlcC5PdXRwdXRNYXBFbnRyeVIJb3V0",
            "cHV0TWFwGjsKDUlucHV0TWFwRW50cnkSEAoDa2V5GAEgASgJUgNrZXkSFAoF",
            "dmFsdWUYAiABKAlSBXZhbHVlOgI4ARo8Cg5PdXRwdXRNYXBFbnRyeRIQCgNr",
            "ZXkYASABKAlSA2tleRIUCgV2YWx1ZRgCIAEoCVIFdmFsdWU6AjgBIjMKDk1v",
            "ZGVsUGFyYW1ldGVyEiEKDHN0cmluZ192YWx1ZRgBIAEoCVILc3RyaW5nVmFs",
            "dWUiugMKC01vZGVsV2FybXVwEhIKBG5hbWUYASABKAlSBG5hbWUSHQoKYmF0",
            "Y2hfc2l6ZRgCIAEoDVIJYmF0Y2hTaXplEjoKBmlucHV0cxgDIAMoCzIiLmlu",
            "ZmVyZW5jZS5Nb2RlbFdhcm11cC5JbnB1dHNFbnRyeVIGaW5wdXRzEhQKBWNv",
            "dW50GAQgASgNUgVjb3VudBrMAQoFSW5wdXQSMAoJZGF0YV90eXBlGAEgASgO",
            "MhMuaW5mZXJlbmNlLkRhdGFUeXBlUghkYXRhVHlwZRISCgRkaW1zGAIgAygD",
            "UgRkaW1zEh0KCXplcm9fZGF0YRgDIAEoCEgAUgh6ZXJvRGF0YRIhCgtyYW5k",
            "b21fZGF0YRgEIAEoCEgAUgpyYW5kb21EYXRhEigKD2lucHV0X2RhdGFfZmls",
            "ZRgFIAEoCUgAUg1pbnB1dERhdGFGaWxlQhEKD2lucHV0X2RhdGFfdHlwZRpX",
            "CgtJbnB1dHNFbnRyeRIQCgNrZXkYASABKAlSA2tleRIyCgV2YWx1ZRgCIAEo",
            "CzIcLmluZmVyZW5jZS5Nb2RlbFdhcm11cC5JbnB1dFIFdmFsdWU6AjgBIkEK",
            "D01vZGVsT3BlcmF0aW9ucxIuChNvcF9saWJyYXJ5X2ZpbGVuYW1lGAEgAygJ",
            "UhFvcExpYnJhcnlGaWxlbmFtZSI2ChZNb2RlbFRyYW5zYWN0aW9uUG9saWN5",
            "EhwKCWRlY291cGxlZBgBIAEoCFIJZGVjb3VwbGVkIowCChVNb2RlbFJlcG9z",
            "aXRvcnlBZ2VudHMSPgoGYWdlbnRzGAEgAygLMiYuaW5mZXJlbmNlLk1vZGVs",
            "UmVwb3NpdG9yeUFnZW50cy5BZ2VudFIGYWdlbnRzGrIBCgVBZ2VudBISCgRu",
            "YW1lGAEgASgJUgRuYW1lElYKCnBhcmFtZXRlcnMYAiADKAsyNi5pbmZlcmVu",
            "Y2UuTW9kZWxSZXBvc2l0b3J5QWdlbnRzLkFnZW50LlBhcmFtZXRlcnNFbnRy",
            "eVIKcGFyYW1ldGVycxo9Cg9QYXJhbWV0ZXJzRW50cnkSEAoDa2V5GAEgASgJ",
            "UgNrZXkSFAoFdmFsdWUYAiABKAlSBXZhbHVlOgI4ASIsChJNb2RlbFJlc3Bv",
            "bnNlQ2FjaGUSFgoGZW5hYmxlGAEgASgIUgZlbmFibGUipA0KC01vZGVsQ29u",
            "ZmlnEhIKBG5hbWUYASABKAlSBG5hbWUSGgoIcGxhdGZvcm0YAiABKAlSCHBs",
            "YXRmb3JtEhgKB2JhY2tlbmQYESABKAlSB2JhY2tlbmQSRAoOdmVyc2lvbl9w",
            "b2xpY3kYAyABKAsyHS5pbmZlcmVuY2UuTW9kZWxWZXJzaW9uUG9saWN5Ug12",
            "ZXJzaW9uUG9saWN5EiQKDm1heF9iYXRjaF9zaXplGAQgASgFUgxtYXhCYXRj",
            "aFNpemUSKwoFaW5wdXQYBSADKAsyFS5pbmZlcmVuY2UuTW9kZWxJbnB1dFIF",
            "aW5wdXQSLgoGb3V0cHV0GAYgAygLMhYuaW5mZXJlbmNlLk1vZGVsT3V0cHV0",
            "UgZvdXRwdXQSNgoLYmF0Y2hfaW5wdXQYFCADKAsyFS5pbmZlcmVuY2UuQmF0",
            "Y2hJbnB1dFIKYmF0Y2hJbnB1dBI5CgxiYXRjaF9vdXRwdXQYFSADKAsyFi5p",
            "bmZlcmVuY2UuQmF0Y2hPdXRwdXRSC2JhdGNoT3V0cHV0EkYKDG9wdGltaXph",
            "dGlvbhgMIAEoCzIiLmluZmVyZW5jZS5Nb2RlbE9wdGltaXphdGlvblBvbGlj",
            "eVIMb3B0aW1pemF0aW9uEkwKEGR5bmFtaWNfYmF0Y2hpbmcYCyABKAsyHy5p",
            "bmZlcmVuY2UuTW9kZWxEeW5hbWljQmF0Y2hpbmdIAFIPZHluYW1pY0JhdGNo",
            "aW5nEk8KEXNlcXVlbmNlX2JhdGNoaW5nGA0gASgLMiAuaW5mZXJlbmNlLk1v",
            "ZGVsU2VxdWVuY2VCYXRjaGluZ0gAUhBzZXF1ZW5jZUJhdGNoaW5nEk0KE2Vu",
            "c2VtYmxlX3NjaGVkdWxpbmcYDyABKAsyGi5pbmZlcmVuY2UuTW9kZWxFbnNl",
            "bWJsaW5nSABSEmVuc2VtYmxlU2NoZWR1bGluZxJECg5pbnN0YW5jZV9ncm91",
            "cBgHIAMoCzIdLmluZmVyZW5jZS5Nb2RlbEluc3RhbmNlR3JvdXBSDWluc3Rh",
            "bmNlR3JvdXASNAoWZGVmYXVsdF9tb2RlbF9maWxlbmFtZRgIIAEoCVIUZGVm",
            "YXVsdE1vZGVsRmlsZW5hbWUSWgoSY2NfbW9kZWxfZmlsZW5hbWVzGAkgAygL",
            "MiwuaW5mZXJlbmNlLk1vZGVsQ29uZmlnLkNjTW9kZWxGaWxlbmFtZXNFbnRy",
            "eVIQY2NNb2RlbEZpbGVuYW1lcxJHCgttZXRyaWNfdGFncxgKIAMoCzImLmlu",
            "ZmVyZW5jZS5Nb2RlbENvbmZpZy5NZXRyaWNUYWdzRW50cnlSCm1ldHJpY1Rh",
            "Z3MSRgoKcGFyYW1ldGVycxgOIAMoCzImLmluZmVyZW5jZS5Nb2RlbENvbmZp",
            "Zy5QYXJhbWV0ZXJzRW50cnlSCnBhcmFtZXRlcnMSOQoMbW9kZWxfd2FybXVw",
            "GBAgAygLMhYuaW5mZXJlbmNlLk1vZGVsV2FybXVwUgttb2RlbFdhcm11cBJF",
            "ChBtb2RlbF9vcGVyYXRpb25zGBIgASgLMhouaW5mZXJlbmNlLk1vZGVsT3Bl",
            "cmF0aW9uc1IPbW9kZWxPcGVyYXRpb25zElsKGG1vZGVsX3RyYW5zYWN0aW9u",
            "X3BvbGljeRgTIAEoCzIhLmluZmVyZW5jZS5Nb2RlbFRyYW5zYWN0aW9uUG9s",
            "aWN5UhZtb2RlbFRyYW5zYWN0aW9uUG9saWN5ElgKF21vZGVsX3JlcG9zaXRv",
            "cnlfYWdlbnRzGBcgASgLMiAuaW5mZXJlbmNlLk1vZGVsUmVwb3NpdG9yeUFn",
            "ZW50c1IVbW9kZWxSZXBvc2l0b3J5QWdlbnRzEkQKDnJlc3BvbnNlX2NhY2hl",
            "GBggASgLMh0uaW5mZXJlbmNlLk1vZGVsUmVzcG9uc2VDYWNoZVINcmVzcG9u",
            "c2VDYWNoZRpDChVDY01vZGVsRmlsZW5hbWVzRW50cnkSEAoDa2V5GAEgASgJ",
            "UgNrZXkSFAoFdmFsdWUYAiABKAlSBXZhbHVlOgI4ARo9Cg9NZXRyaWNUYWdz",
            "RW50cnkSEAoDa2V5GAEgASgJUgNrZXkSFAoFdmFsdWUYAiABKAlSBXZhbHVl",
            "OgI4ARpYCg9QYXJhbWV0ZXJzRW50cnkSEAoDa2V5GAEgASgJUgNrZXkSLwoF",
            "dmFsdWUYAiABKAsyGS5pbmZlcmVuY2UuTW9kZWxQYXJhbWV0ZXJSBXZhbHVl",
            "OgI4AUITChFzY2hlZHVsaW5nX2Nob2ljZSr6AQoIRGF0YVR5cGUSEAoMVFlQ",
            "RV9JTlZBTElEEAASDQoJVFlQRV9CT09MEAESDgoKVFlQRV9VSU5UOBACEg8K",
            "C1RZUEVfVUlOVDE2EAMSDwoLVFlQRV9VSU5UMzIQBBIPCgtUWVBFX1VJTlQ2",
            "NBAFEg0KCVRZUEVfSU5UOBAGEg4KClRZUEVfSU5UMTYQBxIOCgpUWVBFX0lO",
            "VDMyEAgSDgoKVFlQRV9JTlQ2NBAJEg0KCVRZUEVfRlAxNhAKEg0KCVRZUEVf",
            "RlAzMhALEg0KCVRZUEVfRlA2NBAMEg8KC1RZUEVfU1RSSU5HEA0SDQoJVFlQ",
            "RV9CRjE2EA5CTVpLZ2l0aHViLmNvbS9lLWNvbm9taWMvdm1sYXBpcy9nZW4v",
            "Z28vc3NuL3R5cGUvdHJpdG9uLztudmlkaWFfaW5mZXJlbmNlc2VydmVyYgZw",
            "cm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Inference.DataType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelRateLimiter), global::Inference.ModelRateLimiter.Parser, new[]{ "Resources", "Priority" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelRateLimiter.Types.Resource), global::Inference.ModelRateLimiter.Types.Resource.Parser, new[]{ "Name", "Global", "Count" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelInstanceGroup), global::Inference.ModelInstanceGroup.Parser, new[]{ "Name", "Kind", "Count", "RateLimiter", "Gpus", "SecondaryDevices", "Profile", "Passive", "HostPolicy" }, null, new[]{ typeof(global::Inference.ModelInstanceGroup.Types.Kind) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelInstanceGroup.Types.SecondaryDevice), global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Parser, new[]{ "Kind", "DeviceId" }, null, new[]{ typeof(global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind) }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelTensorReshape), global::Inference.ModelTensorReshape.Parser, new[]{ "Shape" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelInput), global::Inference.ModelInput.Parser, new[]{ "Name", "DataType", "Format", "Dims", "Reshape", "IsShapeTensor", "AllowRaggedBatch", "Optional" }, null, new[]{ typeof(global::Inference.ModelInput.Types.Format) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOutput), global::Inference.ModelOutput.Parser, new[]{ "Name", "DataType", "Dims", "Reshape", "LabelFilename", "IsShapeTensor" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.BatchInput), global::Inference.BatchInput.Parser, new[]{ "Kind", "TargetName", "DataType", "SourceInput" }, null, new[]{ typeof(global::Inference.BatchInput.Types.Kind) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.BatchOutput), global::Inference.BatchOutput.Parser, new[]{ "TargetName", "Kind", "SourceInput" }, null, new[]{ typeof(global::Inference.BatchOutput.Types.Kind) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelVersionPolicy), global::Inference.ModelVersionPolicy.Parser, new[]{ "Latest", "All", "Specific" }, new[]{ "PolicyChoice" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelVersionPolicy.Types.Latest), global::Inference.ModelVersionPolicy.Types.Latest.Parser, new[]{ "NumVersions" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelVersionPolicy.Types.All), global::Inference.ModelVersionPolicy.Types.All.Parser, null, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelVersionPolicy.Types.Specific), global::Inference.ModelVersionPolicy.Types.Specific.Parser, new[]{ "Versions" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy), global::Inference.ModelOptimizationPolicy.Parser, new[]{ "Graph", "Priority", "Cuda", "ExecutionAccelerators", "InputPinnedMemory", "OutputPinnedMemory", "GatherKernelBufferThreshold", "EagerBatching" }, null, new[]{ typeof(global::Inference.ModelOptimizationPolicy.Types.ModelPriority) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.Graph), global::Inference.ModelOptimizationPolicy.Types.Graph.Parser, new[]{ "Level" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.Cuda), global::Inference.ModelOptimizationPolicy.Types.Cuda.Parser, new[]{ "Graphs", "BusyWaitEvents", "GraphSpec", "OutputCopyStream" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec), global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Parser, new[]{ "BatchSize", "Input", "GraphLowerBound" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape), global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape.Parser, new[]{ "Dim" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.LowerBound), global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.LowerBound.Parser, new[]{ "BatchSize", "Input" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators), global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Parser, new[]{ "GpuExecutionAccelerator", "CpuExecutionAccelerator" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator), global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator.Parser, new[]{ "Name", "Parameters" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer), global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer.Parser, new[]{ "Enable" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelQueuePolicy), global::Inference.ModelQueuePolicy.Parser, new[]{ "TimeoutAction", "DefaultTimeoutMicroseconds", "AllowTimeoutOverride", "MaxQueueSize" }, null, new[]{ typeof(global::Inference.ModelQueuePolicy.Types.TimeoutAction) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelDynamicBatching), global::Inference.ModelDynamicBatching.Parser, new[]{ "PreferredBatchSize", "MaxQueueDelayMicroseconds", "PreserveOrdering", "PriorityLevels", "DefaultPriorityLevel", "DefaultQueuePolicy", "PriorityQueuePolicy" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelSequenceBatching), global::Inference.ModelSequenceBatching.Parser, new[]{ "Direct", "Oldest", "MaxSequenceIdleMicroseconds", "ControlInput", "State" }, new[]{ "StrategyChoice" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelSequenceBatching.Types.Control), global::Inference.ModelSequenceBatching.Types.Control.Parser, new[]{ "Kind", "Int32FalseTrue", "Fp32FalseTrue", "BoolFalseTrue", "DataType" }, null, new[]{ typeof(global::Inference.ModelSequenceBatching.Types.Control.Types.Kind) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelSequenceBatching.Types.ControlInput), global::Inference.ModelSequenceBatching.Types.ControlInput.Parser, new[]{ "Name", "Control" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelSequenceBatching.Types.InitialState), global::Inference.ModelSequenceBatching.Types.InitialState.Parser, new[]{ "DataType", "Dims", "ZeroData", "DataFile", "Name" }, new[]{ "StateData" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelSequenceBatching.Types.State), global::Inference.ModelSequenceBatching.Types.State.Parser, new[]{ "InputName", "OutputName", "DataType", "Dims", "InitialState" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelSequenceBatching.Types.StrategyDirect), global::Inference.ModelSequenceBatching.Types.StrategyDirect.Parser, new[]{ "MaxQueueDelayMicroseconds", "MinimumSlotUtilization" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelSequenceBatching.Types.StrategyOldest), global::Inference.ModelSequenceBatching.Types.StrategyOldest.Parser, new[]{ "MaxCandidateSequences", "PreferredBatchSize", "MaxQueueDelayMicroseconds" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelEnsembling), global::Inference.ModelEnsembling.Parser, new[]{ "Step" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelEnsembling.Types.Step), global::Inference.ModelEnsembling.Types.Step.Parser, new[]{ "ModelName", "ModelVersion", "InputMap", "OutputMap" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelParameter), global::Inference.ModelParameter.Parser, new[]{ "StringValue" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelWarmup), global::Inference.ModelWarmup.Parser, new[]{ "Name", "BatchSize", "Inputs", "Count" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelWarmup.Types.Input), global::Inference.ModelWarmup.Types.Input.Parser, new[]{ "DataType", "Dims", "ZeroData", "RandomData", "InputDataFile" }, new[]{ "InputDataType" }, null, null, null),
            null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelOperations), global::Inference.ModelOperations.Parser, new[]{ "OpLibraryFilename" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelTransactionPolicy), global::Inference.ModelTransactionPolicy.Parser, new[]{ "Decoupled" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelRepositoryAgents), global::Inference.ModelRepositoryAgents.Parser, new[]{ "Agents" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelRepositoryAgents.Types.Agent), global::Inference.ModelRepositoryAgents.Types.Agent.Parser, new[]{ "Name", "Parameters" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, })}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelResponseCache), global::Inference.ModelResponseCache.Parser, new[]{ "Enable" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Inference.ModelConfig), global::Inference.ModelConfig.Parser, new[]{ "Name", "Platform", "Backend", "VersionPolicy", "MaxBatchSize", "Input", "Output", "BatchInput", "BatchOutput", "Optimization", "DynamicBatching", "SequenceBatching", "EnsembleScheduling", "InstanceGroup", "DefaultModelFilename", "CcModelFilenames", "MetricTags", "Parameters", "ModelWarmup", "ModelOperations", "ModelTransactionPolicy", "ModelRepositoryAgents", "ResponseCache" }, new[]{ "SchedulingChoice" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, null, })
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  ///@@
  ///@@.. cpp:enum:: DataType
  ///@@
  ///@@   Data types supported for input and output tensors.
  ///@@
  /// </summary>
  public enum DataType {
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INVALID = 0
    /// </summary>
    [pbr::OriginalName("TYPE_INVALID")] TypeInvalid = 0,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::BOOL = 1
    /// </summary>
    [pbr::OriginalName("TYPE_BOOL")] TypeBool = 1,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT8 = 2
    /// </summary>
    [pbr::OriginalName("TYPE_UINT8")] TypeUint8 = 2,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT16 = 3
    /// </summary>
    [pbr::OriginalName("TYPE_UINT16")] TypeUint16 = 3,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT32 = 4
    /// </summary>
    [pbr::OriginalName("TYPE_UINT32")] TypeUint32 = 4,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::UINT64 = 5
    /// </summary>
    [pbr::OriginalName("TYPE_UINT64")] TypeUint64 = 5,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT8 = 6
    /// </summary>
    [pbr::OriginalName("TYPE_INT8")] TypeInt8 = 6,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT16 = 7
    /// </summary>
    [pbr::OriginalName("TYPE_INT16")] TypeInt16 = 7,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT32 = 8
    /// </summary>
    [pbr::OriginalName("TYPE_INT32")] TypeInt32 = 8,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::INT64 = 9
    /// </summary>
    [pbr::OriginalName("TYPE_INT64")] TypeInt64 = 9,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::FP16 = 10
    /// </summary>
    [pbr::OriginalName("TYPE_FP16")] TypeFp16 = 10,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::FP32 = 11
    /// </summary>
    [pbr::OriginalName("TYPE_FP32")] TypeFp32 = 11,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::FP64 = 12
    /// </summary>
    [pbr::OriginalName("TYPE_FP64")] TypeFp64 = 12,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::STRING = 13
    /// </summary>
    [pbr::OriginalName("TYPE_STRING")] TypeString = 13,
    /// <summary>
    ///@@  .. cpp:enumerator:: DataType::BF16 = 14
    /// </summary>
    [pbr::OriginalName("TYPE_BF16")] TypeBf16 = 14,
  }

  #endregion

  #region Messages
  /// <summary>
  ///@@
  ///@@  .. cpp:var:: message ModelRateLimiter
  ///@@
  ///@@     The specifications required by the rate limiter to properly
  ///@@     schedule the inference requests across the different models
  ///@@     and their instances.
  ///@@
  /// </summary>
  public sealed partial class ModelRateLimiter : pb::IMessage<ModelRateLimiter>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelRateLimiter> _parser = new pb::MessageParser<ModelRateLimiter>(() => new ModelRateLimiter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelRateLimiter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelRateLimiter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelRateLimiter(ModelRateLimiter other) : this() {
      resources_ = other.resources_.Clone();
      priority_ = other.priority_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelRateLimiter Clone() {
      return new ModelRateLimiter(this);
    }

    /// <summary>Field number for the "resources" field.</summary>
    public const int ResourcesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Inference.ModelRateLimiter.Types.Resource> _repeated_resources_codec
        = pb::FieldCodec.ForMessage(10, global::Inference.ModelRateLimiter.Types.Resource.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelRateLimiter.Types.Resource> resources_ = new pbc::RepeatedField<global::Inference.ModelRateLimiter.Types.Resource>();
    /// <summary>
    ///@@  .. cpp:var:: Resource resources (repeated)
    ///@@
    ///@@     The resources required to execute the request on a model instance.
    ///@@     Resources are just names with a corresponding count. The execution
    ///@@     of the instance will be blocked until the specificied resources are
    ///@@     available. By default an instance uses no rate-limiter resources.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelRateLimiter.Types.Resource> Resources {
      get { return resources_; }
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 2;
    private uint priority_;
    /// <summary>
    ///@@  .. cpp:var:: uint32 priority
    ///@@
    ///@@     The optional weighting value to be used for prioritizing across
    ///@@     instances. An instance with priority 2 will be given 1/2 the
    ///@@     number of scheduling chances as an instance_group with priority
    ///@@     1. The default priority is 1. The priority of value 0 will be
    ///@@     treated as priority 1.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Priority {
      get { return priority_; }
      set {
        priority_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelRateLimiter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelRateLimiter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!resources_.Equals(other.resources_)) return false;
      if (Priority != other.Priority) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= resources_.GetHashCode();
      if (Priority != 0) hash ^= Priority.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      resources_.WriteTo(output, _repeated_resources_codec);
      if (Priority != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Priority);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      resources_.WriteTo(ref output, _repeated_resources_codec);
      if (Priority != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(Priority);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += resources_.CalculateSize(_repeated_resources_codec);
      if (Priority != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Priority);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelRateLimiter other) {
      if (other == null) {
        return;
      }
      resources_.Add(other.resources_);
      if (other.Priority != 0) {
        Priority = other.Priority;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            resources_.AddEntriesFrom(input, _repeated_resources_codec);
            break;
          }
          case 16: {
            Priority = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            resources_.AddEntriesFrom(ref input, _repeated_resources_codec);
            break;
          }
          case 16: {
            Priority = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelRateLimiter message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@  .. cpp:var:: message Resource
      ///@@
      ///@@     The resource property.
      ///@@
      /// </summary>
      public sealed partial class Resource : pb::IMessage<Resource>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Resource> _parser = new pb::MessageParser<Resource>(() => new Resource());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Resource> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelRateLimiter.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Resource() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Resource(Resource other) : this() {
          name_ = other.name_;
          global_ = other.global_;
          count_ = other.count_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Resource Clone() {
          return new Resource(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        ///@@  .. cpp:var:: string name
        ///@@
        ///@@     The name associated with the resource.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "global" field.</summary>
        public const int GlobalFieldNumber = 2;
        private bool global_;
        /// <summary>
        ///@@  .. cpp:var:: bool global
        ///@@
        ///@@     Whether or not the resource is global. If true then the resource
        ///@@     is assumed to be shared among the devices otherwise specified
        ///@@     count of the resource is assumed for each device associated
        ///@@     with the instance.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Global {
          get { return global_; }
          set {
            global_ = value;
          }
        }

        /// <summary>Field number for the "count" field.</summary>
        public const int CountFieldNumber = 3;
        private uint count_;
        /// <summary>
        ///@@  .. cpp:var:: uint32 count
        ///@@
        ///@@     The number of resources required for the execution of the model
        ///@@     instance.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint Count {
          get { return count_; }
          set {
            count_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Resource);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Resource other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (Global != other.Global) return false;
          if (Count != other.Count) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (Global != false) hash ^= Global.GetHashCode();
          if (Count != 0) hash ^= Count.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Global != false) {
            output.WriteRawTag(16);
            output.WriteBool(Global);
          }
          if (Count != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Count);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (Global != false) {
            output.WriteRawTag(16);
            output.WriteBool(Global);
          }
          if (Count != 0) {
            output.WriteRawTag(24);
            output.WriteUInt32(Count);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (Global != false) {
            size += 1 + 1;
          }
          if (Count != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Count);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Resource other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.Global != false) {
            Global = other.Global;
          }
          if (other.Count != 0) {
            Count = other.Count;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                Global = input.ReadBool();
                break;
              }
              case 24: {
                Count = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 16: {
                Global = input.ReadBool();
                break;
              }
              case 24: {
                Count = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelInstanceGroup
  ///@@
  ///@@   A group of one or more instances of a model and resources made
  ///@@   available for those instances.
  ///@@
  /// </summary>
  public sealed partial class ModelInstanceGroup : pb::IMessage<ModelInstanceGroup>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelInstanceGroup> _parser = new pb::MessageParser<ModelInstanceGroup>(() => new ModelInstanceGroup());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelInstanceGroup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelInstanceGroup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelInstanceGroup(ModelInstanceGroup other) : this() {
      name_ = other.name_;
      kind_ = other.kind_;
      count_ = other.count_;
      rateLimiter_ = other.rateLimiter_ != null ? other.rateLimiter_.Clone() : null;
      gpus_ = other.gpus_.Clone();
      secondaryDevices_ = other.secondaryDevices_.Clone();
      profile_ = other.profile_.Clone();
      passive_ = other.passive_;
      hostPolicy_ = other.hostPolicy_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelInstanceGroup Clone() {
      return new ModelInstanceGroup(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     Optional name of this group of instances. If not specified the
    ///@@     name will be formed as &lt;model name>_&lt;group number>. The name of
    ///@@     individual instances will be further formed by a unique instance
    ///@@     number and GPU index:
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 4;
    private global::Inference.ModelInstanceGroup.Types.Kind kind_ = global::Inference.ModelInstanceGroup.Types.Kind.Auto;
    /// <summary>
    ///@@  .. cpp:var:: Kind kind
    ///@@
    ///@@     The kind of this instance group. Default is KIND_AUTO. If
    ///@@     KIND_AUTO or KIND_GPU then both 'count' and 'gpu' are valid and
    ///@@     may be specified. If KIND_CPU or KIND_MODEL only 'count' is valid
    ///@@     and 'gpu' cannot be specified.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelInstanceGroup.Types.Kind Kind {
      get { return kind_; }
      set {
        kind_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 2;
    private int count_;
    /// <summary>
    ///@@  .. cpp:var:: int32 count
    ///@@
    ///@@     For a group assigned to GPU, the number of instances created for
    ///@@     each GPU listed in 'gpus'. For a group assigned to CPU the number
    ///@@     of instances created. Default is 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "rate_limiter" field.</summary>
    public const int RateLimiterFieldNumber = 6;
    private global::Inference.ModelRateLimiter rateLimiter_;
    /// <summary>
    ///@@  .. cpp:var:: ModelRateLimiter rate_limiter
    ///@@
    ///@@     The rate limiter specific settings to be associated with this
    ///@@     instance group. Optional, if not specified no rate limiting
    ///@@     will be applied to this instance group.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelRateLimiter RateLimiter {
      get { return rateLimiter_; }
      set {
        rateLimiter_ = value;
      }
    }

    /// <summary>Field number for the "gpus" field.</summary>
    public const int GpusFieldNumber = 3;
    private static readonly pb::FieldCodec<int> _repeated_gpus_codec
        = pb::FieldCodec.ForInt32(26);
    private readonly pbc::RepeatedField<int> gpus_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///@@  .. cpp:var:: int32 gpus (repeated)
    ///@@
    ///@@     GPU(s) where instances should be available. For each GPU listed,
    ///@@     'count' instances of the model will be available. Setting 'gpus'
    ///@@     to empty (or not specifying at all) is eqivalent to listing all
    ///@@     available GPUs.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> Gpus {
      get { return gpus_; }
    }

    /// <summary>Field number for the "secondary_devices" field.</summary>
    public const int SecondaryDevicesFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Inference.ModelInstanceGroup.Types.SecondaryDevice> _repeated_secondaryDevices_codec
        = pb::FieldCodec.ForMessage(66, global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelInstanceGroup.Types.SecondaryDevice> secondaryDevices_ = new pbc::RepeatedField<global::Inference.ModelInstanceGroup.Types.SecondaryDevice>();
    /// <summary>
    ///@@  .. cpp:var:: SecondaryDevice secondary_devices (repeated)
    ///@@
    ///@@     Secondary devices that are required by instances specified by this
    ///@@     instance group. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelInstanceGroup.Types.SecondaryDevice> SecondaryDevices {
      get { return secondaryDevices_; }
    }

    /// <summary>Field number for the "profile" field.</summary>
    public const int ProfileFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _repeated_profile_codec
        = pb::FieldCodec.ForString(42);
    private readonly pbc::RepeatedField<string> profile_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///@@  .. cpp:var:: string profile (repeated)
    ///@@
    ///@@     For TensorRT models containing multiple optimization profile, this
    ///@@     parameter specifies a set of optimization profiles available to this
    ///@@     instance group. The inference server will choose the optimal profile
    ///@@     based on the shapes of the input tensors. This field should lie
    ///@@     between 0 and &lt;TotalNumberOfOptimizationProfilesInPlanModel> - 1
    ///@@     and be specified only for TensorRT backend, otherwise an error will
    ///@@     be generated. If not specified, the server will select the first
    ///@@     optimization profile by default.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> Profile {
      get { return profile_; }
    }

    /// <summary>Field number for the "passive" field.</summary>
    public const int PassiveFieldNumber = 7;
    private bool passive_;
    /// <summary>
    ///@@  .. cpp:var:: bool passive
    ///@@
    ///@@     Whether the instances within this instance group will be accepting
    ///@@     inference requests from the scheduler. If true, the instances will
    ///@@     not be added to the scheduler. Default value is false.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Passive {
      get { return passive_; }
      set {
        passive_ = value;
      }
    }

    /// <summary>Field number for the "host_policy" field.</summary>
    public const int HostPolicyFieldNumber = 9;
    private string hostPolicy_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string host_policy
    ///@@
    ///@@     The host policy name that the instance to be associated with.
    ///@@     The default value is set to reflect the device kind of the instance,
    ///@@     for instance, KIND_CPU is "cpu", KIND_MODEL is "model" and
    ///@@     KIND_GPU is "gpu_&lt;gpu_id>".
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string HostPolicy {
      get { return hostPolicy_; }
      set {
        hostPolicy_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelInstanceGroup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelInstanceGroup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Kind != other.Kind) return false;
      if (Count != other.Count) return false;
      if (!object.Equals(RateLimiter, other.RateLimiter)) return false;
      if(!gpus_.Equals(other.gpus_)) return false;
      if(!secondaryDevices_.Equals(other.secondaryDevices_)) return false;
      if(!profile_.Equals(other.profile_)) return false;
      if (Passive != other.Passive) return false;
      if (HostPolicy != other.HostPolicy) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Kind != global::Inference.ModelInstanceGroup.Types.Kind.Auto) hash ^= Kind.GetHashCode();
      if (Count != 0) hash ^= Count.GetHashCode();
      if (rateLimiter_ != null) hash ^= RateLimiter.GetHashCode();
      hash ^= gpus_.GetHashCode();
      hash ^= secondaryDevices_.GetHashCode();
      hash ^= profile_.GetHashCode();
      if (Passive != false) hash ^= Passive.GetHashCode();
      if (HostPolicy.Length != 0) hash ^= HostPolicy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Count != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Count);
      }
      gpus_.WriteTo(output, _repeated_gpus_codec);
      if (Kind != global::Inference.ModelInstanceGroup.Types.Kind.Auto) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Kind);
      }
      profile_.WriteTo(output, _repeated_profile_codec);
      if (rateLimiter_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RateLimiter);
      }
      if (Passive != false) {
        output.WriteRawTag(56);
        output.WriteBool(Passive);
      }
      secondaryDevices_.WriteTo(output, _repeated_secondaryDevices_codec);
      if (HostPolicy.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(HostPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Count != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Count);
      }
      gpus_.WriteTo(ref output, _repeated_gpus_codec);
      if (Kind != global::Inference.ModelInstanceGroup.Types.Kind.Auto) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Kind);
      }
      profile_.WriteTo(ref output, _repeated_profile_codec);
      if (rateLimiter_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RateLimiter);
      }
      if (Passive != false) {
        output.WriteRawTag(56);
        output.WriteBool(Passive);
      }
      secondaryDevices_.WriteTo(ref output, _repeated_secondaryDevices_codec);
      if (HostPolicy.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(HostPolicy);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Kind != global::Inference.ModelInstanceGroup.Types.Kind.Auto) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
      }
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      if (rateLimiter_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RateLimiter);
      }
      size += gpus_.CalculateSize(_repeated_gpus_codec);
      size += secondaryDevices_.CalculateSize(_repeated_secondaryDevices_codec);
      size += profile_.CalculateSize(_repeated_profile_codec);
      if (Passive != false) {
        size += 1 + 1;
      }
      if (HostPolicy.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HostPolicy);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelInstanceGroup other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Kind != global::Inference.ModelInstanceGroup.Types.Kind.Auto) {
        Kind = other.Kind;
      }
      if (other.Count != 0) {
        Count = other.Count;
      }
      if (other.rateLimiter_ != null) {
        if (rateLimiter_ == null) {
          RateLimiter = new global::Inference.ModelRateLimiter();
        }
        RateLimiter.MergeFrom(other.RateLimiter);
      }
      gpus_.Add(other.gpus_);
      secondaryDevices_.Add(other.secondaryDevices_);
      profile_.Add(other.profile_);
      if (other.Passive != false) {
        Passive = other.Passive;
      }
      if (other.HostPolicy.Length != 0) {
        HostPolicy = other.HostPolicy;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Count = input.ReadInt32();
            break;
          }
          case 26:
          case 24: {
            gpus_.AddEntriesFrom(input, _repeated_gpus_codec);
            break;
          }
          case 32: {
            Kind = (global::Inference.ModelInstanceGroup.Types.Kind) input.ReadEnum();
            break;
          }
          case 42: {
            profile_.AddEntriesFrom(input, _repeated_profile_codec);
            break;
          }
          case 50: {
            if (rateLimiter_ == null) {
              RateLimiter = new global::Inference.ModelRateLimiter();
            }
            input.ReadMessage(RateLimiter);
            break;
          }
          case 56: {
            Passive = input.ReadBool();
            break;
          }
          case 66: {
            secondaryDevices_.AddEntriesFrom(input, _repeated_secondaryDevices_codec);
            break;
          }
          case 74: {
            HostPolicy = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            Count = input.ReadInt32();
            break;
          }
          case 26:
          case 24: {
            gpus_.AddEntriesFrom(ref input, _repeated_gpus_codec);
            break;
          }
          case 32: {
            Kind = (global::Inference.ModelInstanceGroup.Types.Kind) input.ReadEnum();
            break;
          }
          case 42: {
            profile_.AddEntriesFrom(ref input, _repeated_profile_codec);
            break;
          }
          case 50: {
            if (rateLimiter_ == null) {
              RateLimiter = new global::Inference.ModelRateLimiter();
            }
            input.ReadMessage(RateLimiter);
            break;
          }
          case 56: {
            Passive = input.ReadBool();
            break;
          }
          case 66: {
            secondaryDevices_.AddEntriesFrom(ref input, _repeated_secondaryDevices_codec);
            break;
          }
          case 74: {
            HostPolicy = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelInstanceGroup message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: Kind
      ///@@
      ///@@     Kind of this instance group.
      ///@@
      /// </summary>
      public enum Kind {
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_AUTO = 0
        ///@@
        ///@@       This instance group represents instances that can run on either
        ///@@       CPU or GPU. If all GPUs listed in 'gpus' are available then
        ///@@       instances will be created on GPU(s), otherwise instances will
        ///@@       be created on CPU.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_AUTO")] Auto = 0,
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_GPU = 1
        ///@@
        ///@@       This instance group represents instances that must run on the
        ///@@       GPU.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_GPU")] Gpu = 1,
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_CPU = 2
        ///@@
        ///@@       This instance group represents instances that must run on the
        ///@@       CPU.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_CPU")] Cpu = 2,
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::KIND_MODEL = 3
        ///@@
        ///@@       This instance group represents instances that should run on the
        ///@@       CPU and/or GPU(s) as specified by the model or backend itself.
        ///@@       The inference server will not override the model/backend
        ///@@       settings.
        ///@@
        /// </summary>
        [pbr::OriginalName("KIND_MODEL")] Model = 3,
      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message SecondaryDevice
      ///@@
      ///@@     A secondary device required for a model instance.
      ///@@
      /// </summary>
      public sealed partial class SecondaryDevice : pb::IMessage<SecondaryDevice>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<SecondaryDevice> _parser = new pb::MessageParser<SecondaryDevice>(() => new SecondaryDevice());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<SecondaryDevice> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelInstanceGroup.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SecondaryDevice() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SecondaryDevice(SecondaryDevice other) : this() {
          kind_ = other.kind_;
          deviceId_ = other.deviceId_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public SecondaryDevice Clone() {
          return new SecondaryDevice(this);
        }

        /// <summary>Field number for the "kind" field.</summary>
        public const int KindFieldNumber = 1;
        private global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind kind_ = global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind.KindNvdla;
        /// <summary>
        ///@@  .. cpp:var:: SecondaryDeviceKind kind
        ///@@
        ///@@     The secondary device kind.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind Kind {
          get { return kind_; }
          set {
            kind_ = value;
          }
        }

        /// <summary>Field number for the "device_id" field.</summary>
        public const int DeviceIdFieldNumber = 2;
        private long deviceId_;
        /// <summary>
        ///@@  .. cpp:var:: int64 device_id
        ///@@
        ///@@     Identifier for the secondary device.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long DeviceId {
          get { return deviceId_; }
          set {
            deviceId_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as SecondaryDevice);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(SecondaryDevice other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Kind != other.Kind) return false;
          if (DeviceId != other.DeviceId) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Kind != global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind.KindNvdla) hash ^= Kind.GetHashCode();
          if (DeviceId != 0L) hash ^= DeviceId.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Kind != global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind.KindNvdla) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Kind);
          }
          if (DeviceId != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(DeviceId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Kind != global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind.KindNvdla) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Kind);
          }
          if (DeviceId != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(DeviceId);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Kind != global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind.KindNvdla) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
          }
          if (DeviceId != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(DeviceId);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(SecondaryDevice other) {
          if (other == null) {
            return;
          }
          if (other.Kind != global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind.KindNvdla) {
            Kind = other.Kind;
          }
          if (other.DeviceId != 0L) {
            DeviceId = other.DeviceId;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Kind = (global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind) input.ReadEnum();
                break;
              }
              case 16: {
                DeviceId = input.ReadInt64();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Kind = (global::Inference.ModelInstanceGroup.Types.SecondaryDevice.Types.SecondaryDeviceKind) input.ReadEnum();
                break;
              }
              case 16: {
                DeviceId = input.ReadInt64();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the SecondaryDevice message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///@@
          ///@@  .. cpp:enum:: SecondaryDeviceKind
          ///@@
          ///@@     The kind of the secondary device.
          ///@@
          /// </summary>
          public enum SecondaryDeviceKind {
            /// <summary>
            ///@@    .. cpp:enumerator:: SecondaryDeviceKind::KIND_NVDLA = 0
            ///@@
            ///@@       An NVDLA core. http://nvdla.org
            ///@@       Currently KIND_NVDLA is only supported by the TensorRT backend.
            ///@@
            /// </summary>
            [pbr::OriginalName("KIND_NVDLA")] KindNvdla = 0,
          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelTensorReshape
  ///@@
  ///@@   Reshape specification for input and output tensors.
  ///@@
  /// </summary>
  public sealed partial class ModelTensorReshape : pb::IMessage<ModelTensorReshape>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelTensorReshape> _parser = new pb::MessageParser<ModelTensorReshape>(() => new ModelTensorReshape());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelTensorReshape> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelTensorReshape() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelTensorReshape(ModelTensorReshape other) : this() {
      shape_ = other.shape_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelTensorReshape Clone() {
      return new ModelTensorReshape(this);
    }

    /// <summary>Field number for the "shape" field.</summary>
    public const int ShapeFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_shape_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> shape_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///@@  .. cpp:var:: int64 shape (repeated)
    ///@@
    ///@@     The shape to use for reshaping.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> Shape {
      get { return shape_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelTensorReshape);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelTensorReshape other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!shape_.Equals(other.shape_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= shape_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      shape_.WriteTo(output, _repeated_shape_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      shape_.WriteTo(ref output, _repeated_shape_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += shape_.CalculateSize(_repeated_shape_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelTensorReshape other) {
      if (other == null) {
        return;
      }
      shape_.Add(other.shape_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            shape_.AddEntriesFrom(input, _repeated_shape_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            shape_.AddEntriesFrom(ref input, _repeated_shape_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelInput
  ///@@
  ///@@   An input required by the model.
  ///@@
  /// </summary>
  public sealed partial class ModelInput : pb::IMessage<ModelInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelInput> _parser = new pb::MessageParser<ModelInput>(() => new ModelInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelInput(ModelInput other) : this() {
      name_ = other.name_;
      dataType_ = other.dataType_;
      format_ = other.format_;
      dims_ = other.dims_.Clone();
      reshape_ = other.reshape_ != null ? other.reshape_.Clone() : null;
      isShapeTensor_ = other.isShapeTensor_;
      allowRaggedBatch_ = other.allowRaggedBatch_;
      optional_ = other.optional_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelInput Clone() {
      return new ModelInput(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the input.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "data_type" field.</summary>
    public const int DataTypeFieldNumber = 2;
    private global::Inference.DataType dataType_ = global::Inference.DataType.TypeInvalid;
    /// <summary>
    ///@@  .. cpp:var:: DataType data_type
    ///@@
    ///@@     The data-type of the input.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.DataType DataType {
      get { return dataType_; }
      set {
        dataType_ = value;
      }
    }

    /// <summary>Field number for the "format" field.</summary>
    public const int FormatFieldNumber = 3;
    private global::Inference.ModelInput.Types.Format format_ = global::Inference.ModelInput.Types.Format.None;
    /// <summary>
    ///@@  .. cpp:var:: Format format
    ///@@
    ///@@     The format of the input. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelInput.Types.Format Format {
      get { return format_; }
      set {
        format_ = value;
      }
    }

    /// <summary>Field number for the "dims" field.</summary>
    public const int DimsFieldNumber = 4;
    private static readonly pb::FieldCodec<long> _repeated_dims_codec
        = pb::FieldCodec.ForInt64(34);
    private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///@@  .. cpp:var:: int64 dims (repeated)
    ///@@
    ///@@     The dimensions/shape of the input tensor that must be provided
    ///@@     when invoking the inference API for this model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> Dims {
      get { return dims_; }
    }

    /// <summary>Field number for the "reshape" field.</summary>
    public const int ReshapeFieldNumber = 5;
    private global::Inference.ModelTensorReshape reshape_;
    /// <summary>
    ///@@  .. cpp:var:: ModelTensorReshape reshape
    ///@@
    ///@@     The shape expected for this input by the backend. The input will
    ///@@     be reshaped to this before being presented to the backend. The
    ///@@     reshape must have the same number of elements as the input shape
    ///@@     specified by 'dims'. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelTensorReshape Reshape {
      get { return reshape_; }
      set {
        reshape_ = value;
      }
    }

    /// <summary>Field number for the "is_shape_tensor" field.</summary>
    public const int IsShapeTensorFieldNumber = 6;
    private bool isShapeTensor_;
    /// <summary>
    ///@@  .. cpp:var:: bool is_shape_tensor
    ///@@
    ///@@     Whether or not the input is a shape tensor to the model. This field
    ///@@     is currently supported only for the TensorRT model. An error will be
    ///@@     generated if this specification does not comply with underlying
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsShapeTensor {
      get { return isShapeTensor_; }
      set {
        isShapeTensor_ = value;
      }
    }

    /// <summary>Field number for the "allow_ragged_batch" field.</summary>
    public const int AllowRaggedBatchFieldNumber = 7;
    private bool allowRaggedBatch_;
    /// <summary>
    ///@@  .. cpp:var:: bool allow_ragged_batch
    ///@@
    ///@@     Whether or not the input is allowed to be "ragged" in a dynamically
    ///@@     created batch. Default is false indicating that two requests will
    ///@@     only be batched if this tensor has the same shape in both requests.
    ///@@     True indicates that two requests can be batched even if this tensor
    ///@@     has a different shape in each request.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowRaggedBatch {
      get { return allowRaggedBatch_; }
      set {
        allowRaggedBatch_ = value;
      }
    }

    /// <summary>Field number for the "optional" field.</summary>
    public const int OptionalFieldNumber = 8;
    private bool optional_;
    /// <summary>
    ///@@  .. cpp:var:: bool optional
    ///@@
    ///@@     Whether or not the input is optional for the model execution.
    ///@@     If true, the input is not required in the inference request.
    ///@@     Default value is false.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Optional {
      get { return optional_; }
      set {
        optional_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DataType != other.DataType) return false;
      if (Format != other.Format) return false;
      if(!dims_.Equals(other.dims_)) return false;
      if (!object.Equals(Reshape, other.Reshape)) return false;
      if (IsShapeTensor != other.IsShapeTensor) return false;
      if (AllowRaggedBatch != other.AllowRaggedBatch) return false;
      if (Optional != other.Optional) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DataType != global::Inference.DataType.TypeInvalid) hash ^= DataType.GetHashCode();
      if (Format != global::Inference.ModelInput.Types.Format.None) hash ^= Format.GetHashCode();
      hash ^= dims_.GetHashCode();
      if (reshape_ != null) hash ^= Reshape.GetHashCode();
      if (IsShapeTensor != false) hash ^= IsShapeTensor.GetHashCode();
      if (AllowRaggedBatch != false) hash ^= AllowRaggedBatch.GetHashCode();
      if (Optional != false) hash ^= Optional.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DataType != global::Inference.DataType.TypeInvalid) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      if (Format != global::Inference.ModelInput.Types.Format.None) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Format);
      }
      dims_.WriteTo(output, _repeated_dims_codec);
      if (reshape_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Reshape);
      }
      if (IsShapeTensor != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsShapeTensor);
      }
      if (AllowRaggedBatch != false) {
        output.WriteRawTag(56);
        output.WriteBool(AllowRaggedBatch);
      }
      if (Optional != false) {
        output.WriteRawTag(64);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DataType != global::Inference.DataType.TypeInvalid) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      if (Format != global::Inference.ModelInput.Types.Format.None) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Format);
      }
      dims_.WriteTo(ref output, _repeated_dims_codec);
      if (reshape_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Reshape);
      }
      if (IsShapeTensor != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsShapeTensor);
      }
      if (AllowRaggedBatch != false) {
        output.WriteRawTag(56);
        output.WriteBool(AllowRaggedBatch);
      }
      if (Optional != false) {
        output.WriteRawTag(64);
        output.WriteBool(Optional);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DataType != global::Inference.DataType.TypeInvalid) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
      }
      if (Format != global::Inference.ModelInput.Types.Format.None) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Format);
      }
      size += dims_.CalculateSize(_repeated_dims_codec);
      if (reshape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Reshape);
      }
      if (IsShapeTensor != false) {
        size += 1 + 1;
      }
      if (AllowRaggedBatch != false) {
        size += 1 + 1;
      }
      if (Optional != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelInput other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DataType != global::Inference.DataType.TypeInvalid) {
        DataType = other.DataType;
      }
      if (other.Format != global::Inference.ModelInput.Types.Format.None) {
        Format = other.Format;
      }
      dims_.Add(other.dims_);
      if (other.reshape_ != null) {
        if (reshape_ == null) {
          Reshape = new global::Inference.ModelTensorReshape();
        }
        Reshape.MergeFrom(other.Reshape);
      }
      if (other.IsShapeTensor != false) {
        IsShapeTensor = other.IsShapeTensor;
      }
      if (other.AllowRaggedBatch != false) {
        AllowRaggedBatch = other.AllowRaggedBatch;
      }
      if (other.Optional != false) {
        Optional = other.Optional;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DataType = (global::Inference.DataType) input.ReadEnum();
            break;
          }
          case 24: {
            Format = (global::Inference.ModelInput.Types.Format) input.ReadEnum();
            break;
          }
          case 34:
          case 32: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 42: {
            if (reshape_ == null) {
              Reshape = new global::Inference.ModelTensorReshape();
            }
            input.ReadMessage(Reshape);
            break;
          }
          case 48: {
            IsShapeTensor = input.ReadBool();
            break;
          }
          case 56: {
            AllowRaggedBatch = input.ReadBool();
            break;
          }
          case 64: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DataType = (global::Inference.DataType) input.ReadEnum();
            break;
          }
          case 24: {
            Format = (global::Inference.ModelInput.Types.Format) input.ReadEnum();
            break;
          }
          case 34:
          case 32: {
            dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
            break;
          }
          case 42: {
            if (reshape_ == null) {
              Reshape = new global::Inference.ModelTensorReshape();
            }
            input.ReadMessage(Reshape);
            break;
          }
          case 48: {
            IsShapeTensor = input.ReadBool();
            break;
          }
          case 56: {
            AllowRaggedBatch = input.ReadBool();
            break;
          }
          case 64: {
            Optional = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelInput message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: Format
      ///@@
      ///@@     The format for the input.
      ///@@
      /// </summary>
      public enum Format {
        /// <summary>
        ///@@    .. cpp:enumerator:: Format::FORMAT_NONE = 0
        ///@@
        ///@@       The input has no specific format. This is the default.
        ///@@
        /// </summary>
        [pbr::OriginalName("FORMAT_NONE")] None = 0,
        /// <summary>
        ///@@    .. cpp:enumerator:: Format::FORMAT_NHWC = 1
        ///@@
        ///@@       HWC image format. Tensors with this format require 3 dimensions
        ///@@       if the model does not support batching (max_batch_size = 0) or 4
        ///@@       dimensions if the model does support batching (max_batch_size
        ///@@       >= 1). In either case the 'dims' below should only specify the
        ///@@       3 non-batch dimensions (i.e. HWC or CHW).
        ///@@
        /// </summary>
        [pbr::OriginalName("FORMAT_NHWC")] Nhwc = 1,
        /// <summary>
        ///@@    .. cpp:enumerator:: Format::FORMAT_NCHW = 2
        ///@@
        ///@@       CHW image format. Tensors with this format require 3 dimensions
        ///@@       if the model does not support batching (max_batch_size = 0) or 4
        ///@@       dimensions if the model does support batching (max_batch_size
        ///@@       >= 1). In either case the 'dims' below should only specify the
        ///@@       3 non-batch dimensions (i.e. HWC or CHW).
        ///@@
        /// </summary>
        [pbr::OriginalName("FORMAT_NCHW")] Nchw = 2,
      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelOutput
  ///@@
  ///@@   An output produced by the model.
  ///@@
  /// </summary>
  public sealed partial class ModelOutput : pb::IMessage<ModelOutput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelOutput> _parser = new pb::MessageParser<ModelOutput>(() => new ModelOutput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelOutput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOutput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOutput(ModelOutput other) : this() {
      name_ = other.name_;
      dataType_ = other.dataType_;
      dims_ = other.dims_.Clone();
      reshape_ = other.reshape_ != null ? other.reshape_.Clone() : null;
      labelFilename_ = other.labelFilename_;
      isShapeTensor_ = other.isShapeTensor_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOutput Clone() {
      return new ModelOutput(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the output.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "data_type" field.</summary>
    public const int DataTypeFieldNumber = 2;
    private global::Inference.DataType dataType_ = global::Inference.DataType.TypeInvalid;
    /// <summary>
    ///@@  .. cpp:var:: DataType data_type
    ///@@
    ///@@     The data-type of the output.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.DataType DataType {
      get { return dataType_; }
      set {
        dataType_ = value;
      }
    }

    /// <summary>Field number for the "dims" field.</summary>
    public const int DimsFieldNumber = 3;
    private static readonly pb::FieldCodec<long> _repeated_dims_codec
        = pb::FieldCodec.ForInt64(26);
    private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
    /// <summary>
    ///@@  .. cpp:var:: int64 dims (repeated)
    ///@@
    ///@@     The dimensions/shape of the output tensor.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<long> Dims {
      get { return dims_; }
    }

    /// <summary>Field number for the "reshape" field.</summary>
    public const int ReshapeFieldNumber = 5;
    private global::Inference.ModelTensorReshape reshape_;
    /// <summary>
    ///@@  .. cpp:var:: ModelTensorReshape reshape
    ///@@
    ///@@     The shape produced for this output by the backend. The output will
    ///@@     be reshaped from this to the shape specifed in 'dims' before being
    ///@@     returned in the inference response. The reshape must have the same
    ///@@     number of elements as the output shape specified by 'dims'. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelTensorReshape Reshape {
      get { return reshape_; }
      set {
        reshape_ = value;
      }
    }

    /// <summary>Field number for the "label_filename" field.</summary>
    public const int LabelFilenameFieldNumber = 4;
    private string labelFilename_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string label_filename
    ///@@
    ///@@     The label file associated with this output. Should be specified only
    ///@@     for outputs that represent classifications. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string LabelFilename {
      get { return labelFilename_; }
      set {
        labelFilename_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_shape_tensor" field.</summary>
    public const int IsShapeTensorFieldNumber = 6;
    private bool isShapeTensor_;
    /// <summary>
    ///@@  .. cpp:var:: bool is_shape_tensor
    ///@@
    ///@@     Whether or not the output is a shape tensor to the model. This field
    ///@@     is currently supported only for the TensorRT model. An error will be
    ///@@     generated if this specification does not comply with underlying
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsShapeTensor {
      get { return isShapeTensor_; }
      set {
        isShapeTensor_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelOutput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelOutput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (DataType != other.DataType) return false;
      if(!dims_.Equals(other.dims_)) return false;
      if (!object.Equals(Reshape, other.Reshape)) return false;
      if (LabelFilename != other.LabelFilename) return false;
      if (IsShapeTensor != other.IsShapeTensor) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (DataType != global::Inference.DataType.TypeInvalid) hash ^= DataType.GetHashCode();
      hash ^= dims_.GetHashCode();
      if (reshape_ != null) hash ^= Reshape.GetHashCode();
      if (LabelFilename.Length != 0) hash ^= LabelFilename.GetHashCode();
      if (IsShapeTensor != false) hash ^= IsShapeTensor.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DataType != global::Inference.DataType.TypeInvalid) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      dims_.WriteTo(output, _repeated_dims_codec);
      if (LabelFilename.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(LabelFilename);
      }
      if (reshape_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Reshape);
      }
      if (IsShapeTensor != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsShapeTensor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (DataType != global::Inference.DataType.TypeInvalid) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      dims_.WriteTo(ref output, _repeated_dims_codec);
      if (LabelFilename.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(LabelFilename);
      }
      if (reshape_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Reshape);
      }
      if (IsShapeTensor != false) {
        output.WriteRawTag(48);
        output.WriteBool(IsShapeTensor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (DataType != global::Inference.DataType.TypeInvalid) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
      }
      size += dims_.CalculateSize(_repeated_dims_codec);
      if (reshape_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Reshape);
      }
      if (LabelFilename.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LabelFilename);
      }
      if (IsShapeTensor != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelOutput other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.DataType != global::Inference.DataType.TypeInvalid) {
        DataType = other.DataType;
      }
      dims_.Add(other.dims_);
      if (other.reshape_ != null) {
        if (reshape_ == null) {
          Reshape = new global::Inference.ModelTensorReshape();
        }
        Reshape.MergeFrom(other.Reshape);
      }
      if (other.LabelFilename.Length != 0) {
        LabelFilename = other.LabelFilename;
      }
      if (other.IsShapeTensor != false) {
        IsShapeTensor = other.IsShapeTensor;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DataType = (global::Inference.DataType) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 34: {
            LabelFilename = input.ReadString();
            break;
          }
          case 42: {
            if (reshape_ == null) {
              Reshape = new global::Inference.ModelTensorReshape();
            }
            input.ReadMessage(Reshape);
            break;
          }
          case 48: {
            IsShapeTensor = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            DataType = (global::Inference.DataType) input.ReadEnum();
            break;
          }
          case 26:
          case 24: {
            dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
            break;
          }
          case 34: {
            LabelFilename = input.ReadString();
            break;
          }
          case 42: {
            if (reshape_ == null) {
              Reshape = new global::Inference.ModelTensorReshape();
            }
            input.ReadMessage(Reshape);
            break;
          }
          case 48: {
            IsShapeTensor = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///@@  .. cpp:var:: message BatchInput
  ///@@
  ///@@     A batch input is an additional input that must be added by
  ///@@     the backend based on all the requests in a batch.
  ///@@
  /// </summary>
  public sealed partial class BatchInput : pb::IMessage<BatchInput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BatchInput> _parser = new pb::MessageParser<BatchInput>(() => new BatchInput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BatchInput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchInput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchInput(BatchInput other) : this() {
      kind_ = other.kind_;
      targetName_ = other.targetName_.Clone();
      dataType_ = other.dataType_;
      sourceInput_ = other.sourceInput_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchInput Clone() {
      return new BatchInput(this);
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 1;
    private global::Inference.BatchInput.Types.Kind kind_ = global::Inference.BatchInput.Types.Kind.BatchElementCount;
    /// <summary>
    ///@@    .. cpp:var:: Kind kind
    ///@@
    ///@@       The kind of this batch input.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.BatchInput.Types.Kind Kind {
      get { return kind_; }
      set {
        kind_ = value;
      }
    }

    /// <summary>Field number for the "target_name" field.</summary>
    public const int TargetNameFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_targetName_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> targetName_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///@@    .. cpp:var:: string target_name (repeated)
    ///@@
    ///@@       The name of the model inputs that the backend will create
    ///@@       for this batch input.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> TargetName {
      get { return targetName_; }
    }

    /// <summary>Field number for the "data_type" field.</summary>
    public const int DataTypeFieldNumber = 3;
    private global::Inference.DataType dataType_ = global::Inference.DataType.TypeInvalid;
    /// <summary>
    ///@@    .. cpp:var:: DataType data_type
    ///@@
    ///@@       The input's datatype. The data type can be TYPE_INT32 or
    ///@@       TYPE_FP32.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.DataType DataType {
      get { return dataType_; }
      set {
        dataType_ = value;
      }
    }

    /// <summary>Field number for the "source_input" field.</summary>
    public const int SourceInputFieldNumber = 4;
    private static readonly pb::FieldCodec<string> _repeated_sourceInput_codec
        = pb::FieldCodec.ForString(34);
    private readonly pbc::RepeatedField<string> sourceInput_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///@@    .. cpp:var:: string source_input (repeated)
    ///@@
    ///@@       The backend derives the value for each batch input from one or
    ///@@       more other inputs. 'source_input' gives the names of those
    ///@@       inputs.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> SourceInput {
      get { return sourceInput_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BatchInput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BatchInput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Kind != other.Kind) return false;
      if(!targetName_.Equals(other.targetName_)) return false;
      if (DataType != other.DataType) return false;
      if(!sourceInput_.Equals(other.sourceInput_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Kind != global::Inference.BatchInput.Types.Kind.BatchElementCount) hash ^= Kind.GetHashCode();
      hash ^= targetName_.GetHashCode();
      if (DataType != global::Inference.DataType.TypeInvalid) hash ^= DataType.GetHashCode();
      hash ^= sourceInput_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Kind != global::Inference.BatchInput.Types.Kind.BatchElementCount) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Kind);
      }
      targetName_.WriteTo(output, _repeated_targetName_codec);
      if (DataType != global::Inference.DataType.TypeInvalid) {
        output.WriteRawTag(24);
        output.WriteEnum((int) DataType);
      }
      sourceInput_.WriteTo(output, _repeated_sourceInput_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Kind != global::Inference.BatchInput.Types.Kind.BatchElementCount) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Kind);
      }
      targetName_.WriteTo(ref output, _repeated_targetName_codec);
      if (DataType != global::Inference.DataType.TypeInvalid) {
        output.WriteRawTag(24);
        output.WriteEnum((int) DataType);
      }
      sourceInput_.WriteTo(ref output, _repeated_sourceInput_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Kind != global::Inference.BatchInput.Types.Kind.BatchElementCount) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
      }
      size += targetName_.CalculateSize(_repeated_targetName_codec);
      if (DataType != global::Inference.DataType.TypeInvalid) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
      }
      size += sourceInput_.CalculateSize(_repeated_sourceInput_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BatchInput other) {
      if (other == null) {
        return;
      }
      if (other.Kind != global::Inference.BatchInput.Types.Kind.BatchElementCount) {
        Kind = other.Kind;
      }
      targetName_.Add(other.targetName_);
      if (other.DataType != global::Inference.DataType.TypeInvalid) {
        DataType = other.DataType;
      }
      sourceInput_.Add(other.sourceInput_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Kind = (global::Inference.BatchInput.Types.Kind) input.ReadEnum();
            break;
          }
          case 18: {
            targetName_.AddEntriesFrom(input, _repeated_targetName_codec);
            break;
          }
          case 24: {
            DataType = (global::Inference.DataType) input.ReadEnum();
            break;
          }
          case 34: {
            sourceInput_.AddEntriesFrom(input, _repeated_sourceInput_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Kind = (global::Inference.BatchInput.Types.Kind) input.ReadEnum();
            break;
          }
          case 18: {
            targetName_.AddEntriesFrom(ref input, _repeated_targetName_codec);
            break;
          }
          case 24: {
            DataType = (global::Inference.DataType) input.ReadEnum();
            break;
          }
          case 34: {
            sourceInput_.AddEntriesFrom(ref input, _repeated_sourceInput_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the BatchInput message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@    .. cpp:enum:: Kind
      ///@@
      ///@@       The kind of the batch input.
      ///@@
      /// </summary>
      public enum Kind {
        /// <summary>
        ///@@      .. cpp:enumerator:: Kind::BATCH_ELEMENT_COUNT = 0
        ///@@
        ///@@         The element count of the 'source_input' will be added as
        ///@@         input with shape [1].
        ///@@
        /// </summary>
        [pbr::OriginalName("BATCH_ELEMENT_COUNT")] BatchElementCount = 0,
        /// <summary>
        ///@@      .. cpp:enumerator:: Kind::BATCH_ACCUMULATED_ELEMENT_COUNT = 1
        ///@@
        ///@@         The accumulated element count of the 'source_input' will be
        ///@@         added as input with shape [1]. For example, if there is a
        ///@@         batch of two request, each with 2 elements, an input of value
        ///@@         2 will be added to the first request, and an input of value
        ///@@         4 will be added to the second request.
        ///@@
        /// </summary>
        [pbr::OriginalName("BATCH_ACCUMULATED_ELEMENT_COUNT")] BatchAccumulatedElementCount = 1,
        /// <summary>
        ///@@      .. cpp:enumerator::
        ///@@         Kind::BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO = 2
        ///@@
        ///@@         The accumulated element count of the 'source_input' will be
        ///@@         added as input with shape [1], except for the first request
        ///@@         in the batch. For the first request in the batch, the input
        ///@@         will have shape [2] where the first element is value 0.
        ///@@
        /// </summary>
        [pbr::OriginalName("BATCH_ACCUMULATED_ELEMENT_COUNT_WITH_ZERO")] BatchAccumulatedElementCountWithZero = 2,
        /// <summary>
        ///@@      .. cpp:enumerator:: Kind::BATCH_MAX_ELEMENT_COUNT_AS_SHAPE = 3
        ///@@
        ///@@         Among the requests in the batch, the max element count of the
        ///@@         'source_input' will be added as input with shape
        ///@@         [max_element_count] for the first request in the batch.
        ///@@         For other requests, such input will be with shape [0].
        ///@@         The data of the tensor will be uninitialized.
        ///@@
        /// </summary>
        [pbr::OriginalName("BATCH_MAX_ELEMENT_COUNT_AS_SHAPE")] BatchMaxElementCountAsShape = 3,
        /// <summary>
        ///@@      .. cpp:enumerator:: Kind::BATCH_ITEM_SHAPE = 4
        ///@@
        ///@@         Among the requests in the batch, the shape of the
        ///@@         'source_input' will be added as input with shape
        ///@@         [batch_size, len(input_dim)]. For example, if one
        ///@@         batch-2 input with shape [3, 1] and batch-1 input
        ///@@         with shape [2, 2] are batched, the batch input will
        ///@@         have shape [3, 2] and value [ [3, 1], [3, 1], [2, 2]].
        ///@@
        /// </summary>
        [pbr::OriginalName("BATCH_ITEM_SHAPE")] BatchItemShape = 4,
        /// <summary>
        ///@@      .. cpp:enumerator:: Kind::BATCH_ITEM_SHAPE_FLATTEN = 5
        ///@@
        ///@@         Among the requests in the batch, the shape of the
        ///@@         'source_input' will be added as input with single dimensional
        ///@@         shape [batch_size * len(input_dim)]. For example, if one
        ///@@         batch-2 input with shape [3, 1] and batch-1 input
        ///@@         with shape [2, 2] are batched, the batch input will
        ///@@         have shape [6] and value [3, 1, 3, 1, 2, 2].
        ///@@
        /// </summary>
        [pbr::OriginalName("BATCH_ITEM_SHAPE_FLATTEN")] BatchItemShapeFlatten = 5,
      }

    }
    #endregion

  }

  /// <summary>
  ///@@.. cpp:var:: message BatchOutput
  ///@@
  ///@@   A batch output is an output produced by the model that must be handled
  ///@@   differently by the backend based on all the requests in a batch.
  ///@@
  /// </summary>
  public sealed partial class BatchOutput : pb::IMessage<BatchOutput>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<BatchOutput> _parser = new pb::MessageParser<BatchOutput>(() => new BatchOutput());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<BatchOutput> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOutput() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOutput(BatchOutput other) : this() {
      targetName_ = other.targetName_.Clone();
      kind_ = other.kind_;
      sourceInput_ = other.sourceInput_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public BatchOutput Clone() {
      return new BatchOutput(this);
    }

    /// <summary>Field number for the "target_name" field.</summary>
    public const int TargetNameFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_targetName_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> targetName_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///@@  .. cpp:var:: string target_name (repeated)
    ///@@
    ///@@     The name of the outputs to be produced by this batch output
    ///@@     specification.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> TargetName {
      get { return targetName_; }
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 2;
    private global::Inference.BatchOutput.Types.Kind kind_ = global::Inference.BatchOutput.Types.Kind.BatchScatterWithInputShape;
    /// <summary>
    ///@@  .. cpp:var:: Kind kind
    ///@@
    ///@@     The kind of this batch output.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.BatchOutput.Types.Kind Kind {
      get { return kind_; }
      set {
        kind_ = value;
      }
    }

    /// <summary>Field number for the "source_input" field.</summary>
    public const int SourceInputFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_sourceInput_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> sourceInput_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///@@  .. cpp:var:: string source_input (repeated)
    ///@@
    ///@@     The backend derives each batch output from one or more inputs.
    ///@@     'source_input' gives the names of those inputs.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> SourceInput {
      get { return sourceInput_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as BatchOutput);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(BatchOutput other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!targetName_.Equals(other.targetName_)) return false;
      if (Kind != other.Kind) return false;
      if(!sourceInput_.Equals(other.sourceInput_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= targetName_.GetHashCode();
      if (Kind != global::Inference.BatchOutput.Types.Kind.BatchScatterWithInputShape) hash ^= Kind.GetHashCode();
      hash ^= sourceInput_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      targetName_.WriteTo(output, _repeated_targetName_codec);
      if (Kind != global::Inference.BatchOutput.Types.Kind.BatchScatterWithInputShape) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Kind);
      }
      sourceInput_.WriteTo(output, _repeated_sourceInput_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      targetName_.WriteTo(ref output, _repeated_targetName_codec);
      if (Kind != global::Inference.BatchOutput.Types.Kind.BatchScatterWithInputShape) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Kind);
      }
      sourceInput_.WriteTo(ref output, _repeated_sourceInput_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += targetName_.CalculateSize(_repeated_targetName_codec);
      if (Kind != global::Inference.BatchOutput.Types.Kind.BatchScatterWithInputShape) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
      }
      size += sourceInput_.CalculateSize(_repeated_sourceInput_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(BatchOutput other) {
      if (other == null) {
        return;
      }
      targetName_.Add(other.targetName_);
      if (other.Kind != global::Inference.BatchOutput.Types.Kind.BatchScatterWithInputShape) {
        Kind = other.Kind;
      }
      sourceInput_.Add(other.sourceInput_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            targetName_.AddEntriesFrom(input, _repeated_targetName_codec);
            break;
          }
          case 16: {
            Kind = (global::Inference.BatchOutput.Types.Kind) input.ReadEnum();
            break;
          }
          case 26: {
            sourceInput_.AddEntriesFrom(input, _repeated_sourceInput_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            targetName_.AddEntriesFrom(ref input, _repeated_targetName_codec);
            break;
          }
          case 16: {
            Kind = (global::Inference.BatchOutput.Types.Kind) input.ReadEnum();
            break;
          }
          case 26: {
            sourceInput_.AddEntriesFrom(ref input, _repeated_sourceInput_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the BatchOutput message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: Kind
      ///@@
      ///@@     The kind of the batch output.
      ///@@
      /// </summary>
      public enum Kind {
        /// <summary>
        ///@@    .. cpp:enumerator:: Kind::BATCH_SCATTER_WITH_INPUT_SHAPE = 0
        ///@@
        ///@@       The output should be scattered according to the shape of
        ///@@       'source_input'. The dynamic dimension of the output will
        ///@@       be set to the value of the same dimension in the input.
        ///@@
        /// </summary>
        [pbr::OriginalName("BATCH_SCATTER_WITH_INPUT_SHAPE")] BatchScatterWithInputShape = 0,
      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelVersionPolicy
  ///@@
  ///@@   Policy indicating which versions of a model should be made
  ///@@   available by the inference server.
  ///@@
  /// </summary>
  public sealed partial class ModelVersionPolicy : pb::IMessage<ModelVersionPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelVersionPolicy> _parser = new pb::MessageParser<ModelVersionPolicy>(() => new ModelVersionPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelVersionPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelVersionPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelVersionPolicy(ModelVersionPolicy other) : this() {
      switch (other.PolicyChoiceCase) {
        case PolicyChoiceOneofCase.Latest:
          Latest = other.Latest.Clone();
          break;
        case PolicyChoiceOneofCase.All:
          All = other.All.Clone();
          break;
        case PolicyChoiceOneofCase.Specific:
          Specific = other.Specific.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelVersionPolicy Clone() {
      return new ModelVersionPolicy(this);
    }

    /// <summary>Field number for the "latest" field.</summary>
    public const int LatestFieldNumber = 1;
    /// <summary>
    ///@@    .. cpp:var:: Latest latest
    ///@@
    ///@@       Serve only latest version(s) of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelVersionPolicy.Types.Latest Latest {
      get { return policyChoiceCase_ == PolicyChoiceOneofCase.Latest ? (global::Inference.ModelVersionPolicy.Types.Latest) policyChoice_ : null; }
      set {
        policyChoice_ = value;
        policyChoiceCase_ = value == null ? PolicyChoiceOneofCase.None : PolicyChoiceOneofCase.Latest;
      }
    }

    /// <summary>Field number for the "all" field.</summary>
    public const int AllFieldNumber = 2;
    /// <summary>
    ///@@    .. cpp:var:: All all
    ///@@
    ///@@       Serve all versions of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelVersionPolicy.Types.All All {
      get { return policyChoiceCase_ == PolicyChoiceOneofCase.All ? (global::Inference.ModelVersionPolicy.Types.All) policyChoice_ : null; }
      set {
        policyChoice_ = value;
        policyChoiceCase_ = value == null ? PolicyChoiceOneofCase.None : PolicyChoiceOneofCase.All;
      }
    }

    /// <summary>Field number for the "specific" field.</summary>
    public const int SpecificFieldNumber = 3;
    /// <summary>
    ///@@    .. cpp:var:: Specific specific
    ///@@
    ///@@       Serve only specific version(s) of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelVersionPolicy.Types.Specific Specific {
      get { return policyChoiceCase_ == PolicyChoiceOneofCase.Specific ? (global::Inference.ModelVersionPolicy.Types.Specific) policyChoice_ : null; }
      set {
        policyChoice_ = value;
        policyChoiceCase_ = value == null ? PolicyChoiceOneofCase.None : PolicyChoiceOneofCase.Specific;
      }
    }

    private object policyChoice_;
    /// <summary>Enum of possible cases for the "policy_choice" oneof.</summary>
    public enum PolicyChoiceOneofCase {
      None = 0,
      Latest = 1,
      All = 2,
      Specific = 3,
    }
    private PolicyChoiceOneofCase policyChoiceCase_ = PolicyChoiceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PolicyChoiceOneofCase PolicyChoiceCase {
      get { return policyChoiceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearPolicyChoice() {
      policyChoiceCase_ = PolicyChoiceOneofCase.None;
      policyChoice_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelVersionPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelVersionPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Latest, other.Latest)) return false;
      if (!object.Equals(All, other.All)) return false;
      if (!object.Equals(Specific, other.Specific)) return false;
      if (PolicyChoiceCase != other.PolicyChoiceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) hash ^= Latest.GetHashCode();
      if (policyChoiceCase_ == PolicyChoiceOneofCase.All) hash ^= All.GetHashCode();
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) hash ^= Specific.GetHashCode();
      hash ^= (int) policyChoiceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
        output.WriteRawTag(10);
        output.WriteMessage(Latest);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
        output.WriteRawTag(18);
        output.WriteMessage(All);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
        output.WriteRawTag(26);
        output.WriteMessage(Specific);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
        output.WriteRawTag(10);
        output.WriteMessage(Latest);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
        output.WriteRawTag(18);
        output.WriteMessage(All);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
        output.WriteRawTag(26);
        output.WriteMessage(Specific);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Latest);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(All);
      }
      if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Specific);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelVersionPolicy other) {
      if (other == null) {
        return;
      }
      switch (other.PolicyChoiceCase) {
        case PolicyChoiceOneofCase.Latest:
          if (Latest == null) {
            Latest = new global::Inference.ModelVersionPolicy.Types.Latest();
          }
          Latest.MergeFrom(other.Latest);
          break;
        case PolicyChoiceOneofCase.All:
          if (All == null) {
            All = new global::Inference.ModelVersionPolicy.Types.All();
          }
          All.MergeFrom(other.All);
          break;
        case PolicyChoiceOneofCase.Specific:
          if (Specific == null) {
            Specific = new global::Inference.ModelVersionPolicy.Types.Specific();
          }
          Specific.MergeFrom(other.Specific);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Inference.ModelVersionPolicy.Types.Latest subBuilder = new global::Inference.ModelVersionPolicy.Types.Latest();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
              subBuilder.MergeFrom(Latest);
            }
            input.ReadMessage(subBuilder);
            Latest = subBuilder;
            break;
          }
          case 18: {
            global::Inference.ModelVersionPolicy.Types.All subBuilder = new global::Inference.ModelVersionPolicy.Types.All();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
              subBuilder.MergeFrom(All);
            }
            input.ReadMessage(subBuilder);
            All = subBuilder;
            break;
          }
          case 26: {
            global::Inference.ModelVersionPolicy.Types.Specific subBuilder = new global::Inference.ModelVersionPolicy.Types.Specific();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
              subBuilder.MergeFrom(Specific);
            }
            input.ReadMessage(subBuilder);
            Specific = subBuilder;
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            global::Inference.ModelVersionPolicy.Types.Latest subBuilder = new global::Inference.ModelVersionPolicy.Types.Latest();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.Latest) {
              subBuilder.MergeFrom(Latest);
            }
            input.ReadMessage(subBuilder);
            Latest = subBuilder;
            break;
          }
          case 18: {
            global::Inference.ModelVersionPolicy.Types.All subBuilder = new global::Inference.ModelVersionPolicy.Types.All();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.All) {
              subBuilder.MergeFrom(All);
            }
            input.ReadMessage(subBuilder);
            All = subBuilder;
            break;
          }
          case 26: {
            global::Inference.ModelVersionPolicy.Types.Specific subBuilder = new global::Inference.ModelVersionPolicy.Types.Specific();
            if (policyChoiceCase_ == PolicyChoiceOneofCase.Specific) {
              subBuilder.MergeFrom(Specific);
            }
            input.ReadMessage(subBuilder);
            Specific = subBuilder;
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelVersionPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@  .. cpp:var:: message Latest
      ///@@
      ///@@     Serve only the latest version(s) of a model. This is
      ///@@     the default policy.
      ///@@
      /// </summary>
      public sealed partial class Latest : pb::IMessage<Latest>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Latest> _parser = new pb::MessageParser<Latest>(() => new Latest());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Latest> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelVersionPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Latest() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Latest(Latest other) : this() {
          numVersions_ = other.numVersions_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Latest Clone() {
          return new Latest(this);
        }

        /// <summary>Field number for the "num_versions" field.</summary>
        public const int NumVersionsFieldNumber = 1;
        private uint numVersions_;
        /// <summary>
        ///@@    .. cpp:var:: uint32 num_versions
        ///@@
        ///@@       Serve only the 'num_versions' highest-numbered versions. T
        ///@@       The default value of 'num_versions' is 1, indicating that by
        ///@@       default only the single highest-number version of a
        ///@@       model will be served.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public uint NumVersions {
          get { return numVersions_; }
          set {
            numVersions_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Latest);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Latest other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (NumVersions != other.NumVersions) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (NumVersions != 0) hash ^= NumVersions.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (NumVersions != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(NumVersions);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (NumVersions != 0) {
            output.WriteRawTag(8);
            output.WriteUInt32(NumVersions);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (NumVersions != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumVersions);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Latest other) {
          if (other == null) {
            return;
          }
          if (other.NumVersions != 0) {
            NumVersions = other.NumVersions;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                NumVersions = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                NumVersions = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///@@  .. cpp:var:: message All
      ///@@
      ///@@     Serve all versions of the model.
      ///@@
      /// </summary>
      public sealed partial class All : pb::IMessage<All>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<All> _parser = new pb::MessageParser<All>(() => new All());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<All> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelVersionPolicy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public All() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public All(All other) : this() {
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public All Clone() {
          return new All(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as All);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(All other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(All other) {
          if (other == null) {
            return;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
            }
          }
        }
        #endif

      }

      /// <summary>
      ///@@  .. cpp:var:: message Specific
      ///@@
      ///@@     Serve only specific versions of the model.
      ///@@
      /// </summary>
      public sealed partial class Specific : pb::IMessage<Specific>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Specific> _parser = new pb::MessageParser<Specific>(() => new Specific());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Specific> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelVersionPolicy.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Specific() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Specific(Specific other) : this() {
          versions_ = other.versions_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Specific Clone() {
          return new Specific(this);
        }

        /// <summary>Field number for the "versions" field.</summary>
        public const int VersionsFieldNumber = 1;
        private static readonly pb::FieldCodec<long> _repeated_versions_codec
            = pb::FieldCodec.ForInt64(10);
        private readonly pbc::RepeatedField<long> versions_ = new pbc::RepeatedField<long>();
        /// <summary>
        ///@@    .. cpp:var:: int64 versions (repeated)
        ///@@
        ///@@       The specific versions of the model that will be served.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<long> Versions {
          get { return versions_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Specific);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Specific other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!versions_.Equals(other.versions_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= versions_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          versions_.WriteTo(output, _repeated_versions_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          versions_.WriteTo(ref output, _repeated_versions_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += versions_.CalculateSize(_repeated_versions_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Specific other) {
          if (other == null) {
            return;
          }
          versions_.Add(other.versions_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10:
              case 8: {
                versions_.AddEntriesFrom(input, _repeated_versions_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10:
              case 8: {
                versions_.AddEntriesFrom(ref input, _repeated_versions_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelOptimizationPolicy
  ///@@
  ///@@   Optimization settings for a model. These settings control if/how a
  ///@@   model is optimized and prioritized by the backend framework when
  ///@@   it is loaded.
  ///@@
  /// </summary>
  public sealed partial class ModelOptimizationPolicy : pb::IMessage<ModelOptimizationPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelOptimizationPolicy> _parser = new pb::MessageParser<ModelOptimizationPolicy>(() => new ModelOptimizationPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelOptimizationPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOptimizationPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOptimizationPolicy(ModelOptimizationPolicy other) : this() {
      graph_ = other.graph_ != null ? other.graph_.Clone() : null;
      priority_ = other.priority_;
      cuda_ = other.cuda_ != null ? other.cuda_.Clone() : null;
      executionAccelerators_ = other.executionAccelerators_ != null ? other.executionAccelerators_.Clone() : null;
      inputPinnedMemory_ = other.inputPinnedMemory_ != null ? other.inputPinnedMemory_.Clone() : null;
      outputPinnedMemory_ = other.outputPinnedMemory_ != null ? other.outputPinnedMemory_.Clone() : null;
      gatherKernelBufferThreshold_ = other.gatherKernelBufferThreshold_;
      eagerBatching_ = other.eagerBatching_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOptimizationPolicy Clone() {
      return new ModelOptimizationPolicy(this);
    }

    /// <summary>Field number for the "graph" field.</summary>
    public const int GraphFieldNumber = 1;
    private global::Inference.ModelOptimizationPolicy.Types.Graph graph_;
    /// <summary>
    ///@@  .. cpp:var:: Graph graph
    ///@@
    ///@@     The graph optimization setting for the model. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOptimizationPolicy.Types.Graph Graph {
      get { return graph_; }
      set {
        graph_ = value;
      }
    }

    /// <summary>Field number for the "priority" field.</summary>
    public const int PriorityFieldNumber = 2;
    private global::Inference.ModelOptimizationPolicy.Types.ModelPriority priority_ = global::Inference.ModelOptimizationPolicy.Types.ModelPriority.PriorityDefault;
    /// <summary>
    ///@@  .. cpp:var:: ModelPriority priority
    ///@@
    ///@@     The priority setting for the model. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOptimizationPolicy.Types.ModelPriority Priority {
      get { return priority_; }
      set {
        priority_ = value;
      }
    }

    /// <summary>Field number for the "cuda" field.</summary>
    public const int CudaFieldNumber = 3;
    private global::Inference.ModelOptimizationPolicy.Types.Cuda cuda_;
    /// <summary>
    ///@@  .. cpp:var:: Cuda cuda
    ///@@
    ///@@     CUDA-specific optimization settings. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOptimizationPolicy.Types.Cuda Cuda {
      get { return cuda_; }
      set {
        cuda_ = value;
      }
    }

    /// <summary>Field number for the "execution_accelerators" field.</summary>
    public const int ExecutionAcceleratorsFieldNumber = 4;
    private global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators executionAccelerators_;
    /// <summary>
    ///@@  .. cpp:var:: ExecutionAccelerators execution_accelerators
    ///@@
    ///@@     The accelerators used for the model. Optional.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators ExecutionAccelerators {
      get { return executionAccelerators_; }
      set {
        executionAccelerators_ = value;
      }
    }

    /// <summary>Field number for the "input_pinned_memory" field.</summary>
    public const int InputPinnedMemoryFieldNumber = 5;
    private global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer inputPinnedMemory_;
    /// <summary>
    ///@@  .. cpp:var:: PinnedMemoryBuffer input_pinned_memory
    ///@@
    ///@@     Use pinned memory buffer when the data transfer for inputs
    ///@@     is between GPU memory and non-pinned system memory.
    ///@@     Default is true.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer InputPinnedMemory {
      get { return inputPinnedMemory_; }
      set {
        inputPinnedMemory_ = value;
      }
    }

    /// <summary>Field number for the "output_pinned_memory" field.</summary>
    public const int OutputPinnedMemoryFieldNumber = 6;
    private global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer outputPinnedMemory_;
    /// <summary>
    ///@@  .. cpp:var:: PinnedMemoryBuffer output_pinned_memory
    ///@@
    ///@@     Use pinned memory buffer when the data transfer for outputs
    ///@@     is between GPU memory and non-pinned system memory.
    ///@@     Default is true.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer OutputPinnedMemory {
      get { return outputPinnedMemory_; }
      set {
        outputPinnedMemory_ = value;
      }
    }

    /// <summary>Field number for the "gather_kernel_buffer_threshold" field.</summary>
    public const int GatherKernelBufferThresholdFieldNumber = 7;
    private uint gatherKernelBufferThreshold_;
    /// <summary>
    ///@@  .. cpp:var:: uint32 gather_kernel_buffer_threshold
    ///@@
    ///@@     The backend may use a gather kernel to gather input data if the
    ///@@     device has direct access to the source buffer and the destination
    ///@@     buffer. In such case, the gather kernel will be used only if the
    ///@@     number of buffers to be gathered is greater or equal to
    ///@@     the specifed value. If 0, the gather kernel will be disabled.
    ///@@     Default value is 0.
    ///@@     Currently only recognized by TensorRT backend.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint GatherKernelBufferThreshold {
      get { return gatherKernelBufferThreshold_; }
      set {
        gatherKernelBufferThreshold_ = value;
      }
    }

    /// <summary>Field number for the "eager_batching" field.</summary>
    public const int EagerBatchingFieldNumber = 8;
    private bool eagerBatching_;
    /// <summary>
    ///@@  .. cpp:var:: bool eager_batching
    ///@@
    ///@@     Start preparing the next batch before the model instance is ready
    ///@@     for the next inference. This option can be used to overlap the
    ///@@     batch preparation with model execution, with the trade-off that
    ///@@     the next batch might be smaller than what it could have been.
    ///@@     Default value is false.
    ///@@     Currently only recognized by TensorRT backend.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool EagerBatching {
      get { return eagerBatching_; }
      set {
        eagerBatching_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelOptimizationPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelOptimizationPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Graph, other.Graph)) return false;
      if (Priority != other.Priority) return false;
      if (!object.Equals(Cuda, other.Cuda)) return false;
      if (!object.Equals(ExecutionAccelerators, other.ExecutionAccelerators)) return false;
      if (!object.Equals(InputPinnedMemory, other.InputPinnedMemory)) return false;
      if (!object.Equals(OutputPinnedMemory, other.OutputPinnedMemory)) return false;
      if (GatherKernelBufferThreshold != other.GatherKernelBufferThreshold) return false;
      if (EagerBatching != other.EagerBatching) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (graph_ != null) hash ^= Graph.GetHashCode();
      if (Priority != global::Inference.ModelOptimizationPolicy.Types.ModelPriority.PriorityDefault) hash ^= Priority.GetHashCode();
      if (cuda_ != null) hash ^= Cuda.GetHashCode();
      if (executionAccelerators_ != null) hash ^= ExecutionAccelerators.GetHashCode();
      if (inputPinnedMemory_ != null) hash ^= InputPinnedMemory.GetHashCode();
      if (outputPinnedMemory_ != null) hash ^= OutputPinnedMemory.GetHashCode();
      if (GatherKernelBufferThreshold != 0) hash ^= GatherKernelBufferThreshold.GetHashCode();
      if (EagerBatching != false) hash ^= EagerBatching.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (graph_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Graph);
      }
      if (Priority != global::Inference.ModelOptimizationPolicy.Types.ModelPriority.PriorityDefault) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Priority);
      }
      if (cuda_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Cuda);
      }
      if (executionAccelerators_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ExecutionAccelerators);
      }
      if (inputPinnedMemory_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(InputPinnedMemory);
      }
      if (outputPinnedMemory_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(OutputPinnedMemory);
      }
      if (GatherKernelBufferThreshold != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(GatherKernelBufferThreshold);
      }
      if (EagerBatching != false) {
        output.WriteRawTag(64);
        output.WriteBool(EagerBatching);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (graph_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Graph);
      }
      if (Priority != global::Inference.ModelOptimizationPolicy.Types.ModelPriority.PriorityDefault) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Priority);
      }
      if (cuda_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Cuda);
      }
      if (executionAccelerators_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ExecutionAccelerators);
      }
      if (inputPinnedMemory_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(InputPinnedMemory);
      }
      if (outputPinnedMemory_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(OutputPinnedMemory);
      }
      if (GatherKernelBufferThreshold != 0) {
        output.WriteRawTag(56);
        output.WriteUInt32(GatherKernelBufferThreshold);
      }
      if (EagerBatching != false) {
        output.WriteRawTag(64);
        output.WriteBool(EagerBatching);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (graph_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Graph);
      }
      if (Priority != global::Inference.ModelOptimizationPolicy.Types.ModelPriority.PriorityDefault) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Priority);
      }
      if (cuda_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cuda);
      }
      if (executionAccelerators_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExecutionAccelerators);
      }
      if (inputPinnedMemory_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InputPinnedMemory);
      }
      if (outputPinnedMemory_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(OutputPinnedMemory);
      }
      if (GatherKernelBufferThreshold != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(GatherKernelBufferThreshold);
      }
      if (EagerBatching != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelOptimizationPolicy other) {
      if (other == null) {
        return;
      }
      if (other.graph_ != null) {
        if (graph_ == null) {
          Graph = new global::Inference.ModelOptimizationPolicy.Types.Graph();
        }
        Graph.MergeFrom(other.Graph);
      }
      if (other.Priority != global::Inference.ModelOptimizationPolicy.Types.ModelPriority.PriorityDefault) {
        Priority = other.Priority;
      }
      if (other.cuda_ != null) {
        if (cuda_ == null) {
          Cuda = new global::Inference.ModelOptimizationPolicy.Types.Cuda();
        }
        Cuda.MergeFrom(other.Cuda);
      }
      if (other.executionAccelerators_ != null) {
        if (executionAccelerators_ == null) {
          ExecutionAccelerators = new global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators();
        }
        ExecutionAccelerators.MergeFrom(other.ExecutionAccelerators);
      }
      if (other.inputPinnedMemory_ != null) {
        if (inputPinnedMemory_ == null) {
          InputPinnedMemory = new global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer();
        }
        InputPinnedMemory.MergeFrom(other.InputPinnedMemory);
      }
      if (other.outputPinnedMemory_ != null) {
        if (outputPinnedMemory_ == null) {
          OutputPinnedMemory = new global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer();
        }
        OutputPinnedMemory.MergeFrom(other.OutputPinnedMemory);
      }
      if (other.GatherKernelBufferThreshold != 0) {
        GatherKernelBufferThreshold = other.GatherKernelBufferThreshold;
      }
      if (other.EagerBatching != false) {
        EagerBatching = other.EagerBatching;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (graph_ == null) {
              Graph = new global::Inference.ModelOptimizationPolicy.Types.Graph();
            }
            input.ReadMessage(Graph);
            break;
          }
          case 16: {
            Priority = (global::Inference.ModelOptimizationPolicy.Types.ModelPriority) input.ReadEnum();
            break;
          }
          case 26: {
            if (cuda_ == null) {
              Cuda = new global::Inference.ModelOptimizationPolicy.Types.Cuda();
            }
            input.ReadMessage(Cuda);
            break;
          }
          case 34: {
            if (executionAccelerators_ == null) {
              ExecutionAccelerators = new global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators();
            }
            input.ReadMessage(ExecutionAccelerators);
            break;
          }
          case 42: {
            if (inputPinnedMemory_ == null) {
              InputPinnedMemory = new global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer();
            }
            input.ReadMessage(InputPinnedMemory);
            break;
          }
          case 50: {
            if (outputPinnedMemory_ == null) {
              OutputPinnedMemory = new global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer();
            }
            input.ReadMessage(OutputPinnedMemory);
            break;
          }
          case 56: {
            GatherKernelBufferThreshold = input.ReadUInt32();
            break;
          }
          case 64: {
            EagerBatching = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (graph_ == null) {
              Graph = new global::Inference.ModelOptimizationPolicy.Types.Graph();
            }
            input.ReadMessage(Graph);
            break;
          }
          case 16: {
            Priority = (global::Inference.ModelOptimizationPolicy.Types.ModelPriority) input.ReadEnum();
            break;
          }
          case 26: {
            if (cuda_ == null) {
              Cuda = new global::Inference.ModelOptimizationPolicy.Types.Cuda();
            }
            input.ReadMessage(Cuda);
            break;
          }
          case 34: {
            if (executionAccelerators_ == null) {
              ExecutionAccelerators = new global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators();
            }
            input.ReadMessage(ExecutionAccelerators);
            break;
          }
          case 42: {
            if (inputPinnedMemory_ == null) {
              InputPinnedMemory = new global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer();
            }
            input.ReadMessage(InputPinnedMemory);
            break;
          }
          case 50: {
            if (outputPinnedMemory_ == null) {
              OutputPinnedMemory = new global::Inference.ModelOptimizationPolicy.Types.PinnedMemoryBuffer();
            }
            input.ReadMessage(OutputPinnedMemory);
            break;
          }
          case 56: {
            GatherKernelBufferThreshold = input.ReadUInt32();
            break;
          }
          case 64: {
            EagerBatching = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelOptimizationPolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: ModelPriority
      ///@@
      ///@@     Model priorities. A model will be given scheduling and execution
      ///@@     preference over models at lower priorities. Current model
      ///@@     priorities only work for TensorRT models.
      ///@@
      /// </summary>
      public enum ModelPriority {
        /// <summary>
        ///@@    .. cpp:enumerator:: ModelPriority::PRIORITY_DEFAULT = 0
        ///@@
        ///@@       The default model priority.
        ///@@
        /// </summary>
        [pbr::OriginalName("PRIORITY_DEFAULT")] PriorityDefault = 0,
        /// <summary>
        ///@@    .. cpp:enumerator:: ModelPriority::PRIORITY_MAX = 1
        ///@@
        ///@@       The maximum model priority.
        ///@@
        /// </summary>
        [pbr::OriginalName("PRIORITY_MAX")] PriorityMax = 1,
        /// <summary>
        ///@@    .. cpp:enumerator:: ModelPriority::PRIORITY_MIN = 2
        ///@@
        ///@@       The minimum model priority.
        ///@@
        /// </summary>
        [pbr::OriginalName("PRIORITY_MIN")] PriorityMin = 2,
      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message Graph
      ///@@
      ///@@     Enable generic graph optimization of the model. If not specified
      ///@@     the framework's default level of optimization is used. Supports
      ///@@     TensorFlow graphdef and savedmodel and Onnx models. For TensorFlow
      ///@@     causes XLA to be enabled/disabled for the model. For Onnx defaults
      ///@@     to enabling all optimizations, -1 enables only basic optimizations,
      ///@@     +1 enables only basic and extended optimizations.
      ///@@
      /// </summary>
      public sealed partial class Graph : pb::IMessage<Graph>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Graph> _parser = new pb::MessageParser<Graph>(() => new Graph());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Graph> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelOptimizationPolicy.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Graph() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Graph(Graph other) : this() {
          level_ = other.level_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Graph Clone() {
          return new Graph(this);
        }

        /// <summary>Field number for the "level" field.</summary>
        public const int LevelFieldNumber = 1;
        private int level_;
        /// <summary>
        ///@@    .. cpp:var:: int32 level
        ///@@
        ///@@       The optimization level. Defaults to 0 (zero) if not specified.
        ///@@
        ///@@         - -1: Disabled
        ///@@         -  0: Framework default
        ///@@         -  1+: Enable optimization level (greater values indicate
        ///@@            higher optimization levels)
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Level {
          get { return level_; }
          set {
            level_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Graph);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Graph other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Level != other.Level) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Level != 0) hash ^= Level.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Level != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(Level);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Level != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(Level);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Level != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(Level);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Graph other) {
          if (other == null) {
            return;
          }
          if (other.Level != 0) {
            Level = other.Level;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Level = input.ReadInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Level = input.ReadInt32();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message Cuda
      ///@@
      ///@@     CUDA-specific optimization settings.
      ///@@
      /// </summary>
      public sealed partial class Cuda : pb::IMessage<Cuda>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Cuda> _parser = new pb::MessageParser<Cuda>(() => new Cuda());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Cuda> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelOptimizationPolicy.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Cuda() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Cuda(Cuda other) : this() {
          graphs_ = other.graphs_;
          busyWaitEvents_ = other.busyWaitEvents_;
          graphSpec_ = other.graphSpec_.Clone();
          outputCopyStream_ = other.outputCopyStream_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Cuda Clone() {
          return new Cuda(this);
        }

        /// <summary>Field number for the "graphs" field.</summary>
        public const int GraphsFieldNumber = 1;
        private bool graphs_;
        /// <summary>
        ///@@    .. cpp:var:: bool graphs
        ///@@
        ///@@       Use CUDA graphs API to capture model operations and execute
        ///@@       them more efficiently. Default value is false.
        ///@@       Currently only recognized by TensorRT backend.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Graphs {
          get { return graphs_; }
          set {
            graphs_ = value;
          }
        }

        /// <summary>Field number for the "busy_wait_events" field.</summary>
        public const int BusyWaitEventsFieldNumber = 2;
        private bool busyWaitEvents_;
        /// <summary>
        ///@@    .. cpp:var:: bool busy_wait_events
        ///@@
        ///@@       Use busy-waiting to synchronize CUDA events to achieve minimum
        ///@@       latency from event complete to host thread to be notified, with
        ///@@       the cost of high CPU load. Default value is false.
        ///@@       Currently only recognized by TensorRT backend.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool BusyWaitEvents {
          get { return busyWaitEvents_; }
          set {
            busyWaitEvents_ = value;
          }
        }

        /// <summary>Field number for the "graph_spec" field.</summary>
        public const int GraphSpecFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec> _repeated_graphSpec_codec
            = pb::FieldCodec.ForMessage(26, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Parser);
        private readonly pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec> graphSpec_ = new pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec>();
        /// <summary>
        ///@@    .. cpp:var:: GraphSpec graph_spec (repeated)
        ///@@
        ///@@       Specification of the CUDA graph to be captured. If not specified
        ///@@       and 'graphs' is true, the default CUDA graphs will be captured
        ///@@       based on model settings.
        ///@@       Currently only recognized by TensorRT backend.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec> GraphSpec {
          get { return graphSpec_; }
        }

        /// <summary>Field number for the "output_copy_stream" field.</summary>
        public const int OutputCopyStreamFieldNumber = 4;
        private bool outputCopyStream_;
        /// <summary>
        ///@@    .. cpp:var:: bool output_copy_stream
        ///@@
        ///@@       Uses a CUDA stream separate from the inference stream to copy the
        ///@@       output to host. However, be aware that setting this option to
        ///@@       true will lead to an increase in the memory consumption of the
        ///@@       model as Triton will allocate twice as much GPU memory for its
        ///@@       I/O tensor buffers. Default value is false.
        ///@@       Currently only recognized by TensorRT backend.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool OutputCopyStream {
          get { return outputCopyStream_; }
          set {
            outputCopyStream_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Cuda);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Cuda other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Graphs != other.Graphs) return false;
          if (BusyWaitEvents != other.BusyWaitEvents) return false;
          if(!graphSpec_.Equals(other.graphSpec_)) return false;
          if (OutputCopyStream != other.OutputCopyStream) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Graphs != false) hash ^= Graphs.GetHashCode();
          if (BusyWaitEvents != false) hash ^= BusyWaitEvents.GetHashCode();
          hash ^= graphSpec_.GetHashCode();
          if (OutputCopyStream != false) hash ^= OutputCopyStream.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Graphs != false) {
            output.WriteRawTag(8);
            output.WriteBool(Graphs);
          }
          if (BusyWaitEvents != false) {
            output.WriteRawTag(16);
            output.WriteBool(BusyWaitEvents);
          }
          graphSpec_.WriteTo(output, _repeated_graphSpec_codec);
          if (OutputCopyStream != false) {
            output.WriteRawTag(32);
            output.WriteBool(OutputCopyStream);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Graphs != false) {
            output.WriteRawTag(8);
            output.WriteBool(Graphs);
          }
          if (BusyWaitEvents != false) {
            output.WriteRawTag(16);
            output.WriteBool(BusyWaitEvents);
          }
          graphSpec_.WriteTo(ref output, _repeated_graphSpec_codec);
          if (OutputCopyStream != false) {
            output.WriteRawTag(32);
            output.WriteBool(OutputCopyStream);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Graphs != false) {
            size += 1 + 1;
          }
          if (BusyWaitEvents != false) {
            size += 1 + 1;
          }
          size += graphSpec_.CalculateSize(_repeated_graphSpec_codec);
          if (OutputCopyStream != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Cuda other) {
          if (other == null) {
            return;
          }
          if (other.Graphs != false) {
            Graphs = other.Graphs;
          }
          if (other.BusyWaitEvents != false) {
            BusyWaitEvents = other.BusyWaitEvents;
          }
          graphSpec_.Add(other.graphSpec_);
          if (other.OutputCopyStream != false) {
            OutputCopyStream = other.OutputCopyStream;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Graphs = input.ReadBool();
                break;
              }
              case 16: {
                BusyWaitEvents = input.ReadBool();
                break;
              }
              case 26: {
                graphSpec_.AddEntriesFrom(input, _repeated_graphSpec_codec);
                break;
              }
              case 32: {
                OutputCopyStream = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Graphs = input.ReadBool();
                break;
              }
              case 16: {
                BusyWaitEvents = input.ReadBool();
                break;
              }
              case 26: {
                graphSpec_.AddEntriesFrom(ref input, _repeated_graphSpec_codec);
                break;
              }
              case 32: {
                OutputCopyStream = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Cuda message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///@@    .. cpp:var:: message GraphSpec
          ///@@
          ///@@       Specification of the CUDA graph to be captured.
          ///@@
          /// </summary>
          public sealed partial class GraphSpec : pb::IMessage<GraphSpec>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<GraphSpec> _parser = new pb::MessageParser<GraphSpec>(() => new GraphSpec());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<GraphSpec> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Inference.ModelOptimizationPolicy.Types.Cuda.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public GraphSpec() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public GraphSpec(GraphSpec other) : this() {
              batchSize_ = other.batchSize_;
              input_ = other.input_.Clone();
              graphLowerBound_ = other.graphLowerBound_ != null ? other.graphLowerBound_.Clone() : null;
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public GraphSpec Clone() {
              return new GraphSpec(this);
            }

            /// <summary>Field number for the "batch_size" field.</summary>
            public const int BatchSizeFieldNumber = 1;
            private int batchSize_;
            /// <summary>
            ///@@      .. cpp:var:: int32 batch_size
            ///@@
            ///@@         The batch size of the CUDA graph. If 'max_batch_size' is 0,
            ///@@         'batch_size' must be set to 0. Otherwise, 'batch_size' must
            ///@@         be set to value between 1 and 'max_batch_size'.
            ///@@
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int BatchSize {
              get { return batchSize_; }
              set {
                batchSize_ = value;
              }
            }

            /// <summary>Field number for the "input" field.</summary>
            public const int InputFieldNumber = 2;
            private static readonly pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape>.Codec _map_input_codec
                = new pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape.Parser), 18);
            private readonly pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape> input_ = new pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape>();
            /// <summary>
            ///@@      .. cpp:var:: map&lt;string, Shape> input
            ///@@
            ///@@         The specification of the inputs. 'Shape' is the shape of the
            ///@@         input without batching dimension.
            ///@@
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape> Input {
              get { return input_; }
            }

            /// <summary>Field number for the "graph_lower_bound" field.</summary>
            public const int GraphLowerBoundFieldNumber = 3;
            private global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.LowerBound graphLowerBound_;
            /// <summary>
            ///@@      .. cpp:var:: LowerBound graph_lower_bound
            ///@@
            ///@@         Specify the lower bound of the CUDA graph. Optional.
            ///@@         If specified, the graph can be used for input shapes and
            ///@@         batch sizes that are in closed interval between the lower
            ///@@         bound specification and graph specification. For dynamic
            ///@@         shape model, this allows CUDA graphs to be launched
            ///@@         frequently without capturing all possible shape combinations.
            ///@@         However, using graph for shape combinations different from
            ///@@         the one used for capturing introduces uninitialized data for
            ///@@         execution and it may distort the inference result if
            ///@@         the model is sensitive to uninitialized data.
            ///@@
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.LowerBound GraphLowerBound {
              get { return graphLowerBound_; }
              set {
                graphLowerBound_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as GraphSpec);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(GraphSpec other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (BatchSize != other.BatchSize) return false;
              if (!Input.Equals(other.Input)) return false;
              if (!object.Equals(GraphLowerBound, other.GraphLowerBound)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (BatchSize != 0) hash ^= BatchSize.GetHashCode();
              hash ^= Input.GetHashCode();
              if (graphLowerBound_ != null) hash ^= GraphLowerBound.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (BatchSize != 0) {
                output.WriteRawTag(8);
                output.WriteInt32(BatchSize);
              }
              input_.WriteTo(output, _map_input_codec);
              if (graphLowerBound_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(GraphLowerBound);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (BatchSize != 0) {
                output.WriteRawTag(8);
                output.WriteInt32(BatchSize);
              }
              input_.WriteTo(ref output, _map_input_codec);
              if (graphLowerBound_ != null) {
                output.WriteRawTag(26);
                output.WriteMessage(GraphLowerBound);
              }
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (BatchSize != 0) {
                size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchSize);
              }
              size += input_.CalculateSize(_map_input_codec);
              if (graphLowerBound_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(GraphLowerBound);
              }
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(GraphSpec other) {
              if (other == null) {
                return;
              }
              if (other.BatchSize != 0) {
                BatchSize = other.BatchSize;
              }
              input_.Add(other.input_);
              if (other.graphLowerBound_ != null) {
                if (graphLowerBound_ == null) {
                  GraphLowerBound = new global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.LowerBound();
                }
                GraphLowerBound.MergeFrom(other.GraphLowerBound);
              }
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 8: {
                    BatchSize = input.ReadInt32();
                    break;
                  }
                  case 18: {
                    input_.AddEntriesFrom(input, _map_input_codec);
                    break;
                  }
                  case 26: {
                    if (graphLowerBound_ == null) {
                      GraphLowerBound = new global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.LowerBound();
                    }
                    input.ReadMessage(GraphLowerBound);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 8: {
                    BatchSize = input.ReadInt32();
                    break;
                  }
                  case 18: {
                    input_.AddEntriesFrom(ref input, _map_input_codec);
                    break;
                  }
                  case 26: {
                    if (graphLowerBound_ == null) {
                      GraphLowerBound = new global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.LowerBound();
                    }
                    input.ReadMessage(GraphLowerBound);
                    break;
                  }
                }
              }
            }
            #endif

            #region Nested types
            /// <summary>Container for nested types declared in the GraphSpec message type.</summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static partial class Types {
              /// <summary>
              ///@@      .. cpp:var:: message Dims
              ///@@
              ///@@         Specification of tensor dimension.
              ///@@
              /// </summary>
              public sealed partial class Shape : pb::IMessage<Shape>
              #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  , pb::IBufferMessage
              #endif
              {
                private static readonly pb::MessageParser<Shape> _parser = new pb::MessageParser<Shape>(() => new Shape());
                private pb::UnknownFieldSet _unknownFields;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pb::MessageParser<Shape> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pbr::MessageDescriptor Descriptor {
                  get { return global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Descriptor.NestedTypes[0]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                pbr::MessageDescriptor pb::IMessage.Descriptor {
                  get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public Shape() {
                  OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public Shape(Shape other) : this() {
                  dim_ = other.dim_.Clone();
                  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public Shape Clone() {
                  return new Shape(this);
                }

                /// <summary>Field number for the "dim" field.</summary>
                public const int DimFieldNumber = 1;
                private static readonly pb::FieldCodec<long> _repeated_dim_codec
                    = pb::FieldCodec.ForInt64(10);
                private readonly pbc::RepeatedField<long> dim_ = new pbc::RepeatedField<long>();
                /// <summary>
                ///@@        .. cpp:var:: int64 dim (repeated)
                ///@@
                ///@@           The dimension.
                ///@@
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public pbc::RepeatedField<long> Dim {
                  get { return dim_; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override bool Equals(object other) {
                  return Equals(other as Shape);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool Equals(Shape other) {
                  if (ReferenceEquals(other, null)) {
                    return false;
                  }
                  if (ReferenceEquals(other, this)) {
                    return true;
                  }
                  if(!dim_.Equals(other.dim_)) return false;
                  return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override int GetHashCode() {
                  int hash = 1;
                  hash ^= dim_.GetHashCode();
                  if (_unknownFields != null) {
                    hash ^= _unknownFields.GetHashCode();
                  }
                  return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override string ToString() {
                  return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void WriteTo(pb::CodedOutputStream output) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  output.WriteRawMessage(this);
                #else
                  dim_.WriteTo(output, _repeated_dim_codec);
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(output);
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
                  dim_.WriteTo(ref output, _repeated_dim_codec);
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(ref output);
                  }
                }
                #endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int CalculateSize() {
                  int size = 0;
                  size += dim_.CalculateSize(_repeated_dim_codec);
                  if (_unknownFields != null) {
                    size += _unknownFields.CalculateSize();
                  }
                  return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(Shape other) {
                  if (other == null) {
                    return;
                  }
                  dim_.Add(other.dim_);
                  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(pb::CodedInputStream input) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  input.ReadRawMessage(this);
                #else
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                      case 10:
                      case 8: {
                        dim_.AddEntriesFrom(input, _repeated_dim_codec);
                        break;
                      }
                    }
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                      case 10:
                      case 8: {
                        dim_.AddEntriesFrom(ref input, _repeated_dim_codec);
                        break;
                      }
                    }
                  }
                }
                #endif

              }

              public sealed partial class LowerBound : pb::IMessage<LowerBound>
              #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  , pb::IBufferMessage
              #endif
              {
                private static readonly pb::MessageParser<LowerBound> _parser = new pb::MessageParser<LowerBound>(() => new LowerBound());
                private pb::UnknownFieldSet _unknownFields;
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pb::MessageParser<LowerBound> Parser { get { return _parser; } }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public static pbr::MessageDescriptor Descriptor {
                  get { return global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Descriptor.NestedTypes[1]; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                pbr::MessageDescriptor pb::IMessage.Descriptor {
                  get { return Descriptor; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public LowerBound() {
                  OnConstruction();
                }

                partial void OnConstruction();

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public LowerBound(LowerBound other) : this() {
                  batchSize_ = other.batchSize_;
                  input_ = other.input_.Clone();
                  _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public LowerBound Clone() {
                  return new LowerBound(this);
                }

                /// <summary>Field number for the "batch_size" field.</summary>
                public const int BatchSizeFieldNumber = 1;
                private int batchSize_;
                /// <summary>
                ///@@      .. cpp:var:: int32 batch_size
                ///@@
                ///@@         The batch size of the CUDA graph. If 'max_batch_size' is 0,
                ///@@         'batch_size' must be set to 0. Otherwise, 'batch_size' must
                ///@@         be set to value between 1 and 'max_batch_size'.
                ///@@
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int BatchSize {
                  get { return batchSize_; }
                  set {
                    batchSize_ = value;
                  }
                }

                /// <summary>Field number for the "input" field.</summary>
                public const int InputFieldNumber = 2;
                private static readonly pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape>.Codec _map_input_codec
                    = new pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape.Parser), 18);
                private readonly pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape> input_ = new pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape>();
                /// <summary>
                ///@@      .. cpp:var:: map&lt;string, Shape> input
                ///@@
                ///@@         The specification of the inputs. 'Shape' is the shape of
                ///@@         the input without batching dimension.
                ///@@
                /// </summary>
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public pbc::MapField<string, global::Inference.ModelOptimizationPolicy.Types.Cuda.Types.GraphSpec.Types.Shape> Input {
                  get { return input_; }
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override bool Equals(object other) {
                  return Equals(other as LowerBound);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public bool Equals(LowerBound other) {
                  if (ReferenceEquals(other, null)) {
                    return false;
                  }
                  if (ReferenceEquals(other, this)) {
                    return true;
                  }
                  if (BatchSize != other.BatchSize) return false;
                  if (!Input.Equals(other.Input)) return false;
                  return Equals(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override int GetHashCode() {
                  int hash = 1;
                  if (BatchSize != 0) hash ^= BatchSize.GetHashCode();
                  hash ^= Input.GetHashCode();
                  if (_unknownFields != null) {
                    hash ^= _unknownFields.GetHashCode();
                  }
                  return hash;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public override string ToString() {
                  return pb::JsonFormatter.ToDiagnosticString(this);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void WriteTo(pb::CodedOutputStream output) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  output.WriteRawMessage(this);
                #else
                  if (BatchSize != 0) {
                    output.WriteRawTag(8);
                    output.WriteInt32(BatchSize);
                  }
                  input_.WriteTo(output, _map_input_codec);
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(output);
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
                  if (BatchSize != 0) {
                    output.WriteRawTag(8);
                    output.WriteInt32(BatchSize);
                  }
                  input_.WriteTo(ref output, _map_input_codec);
                  if (_unknownFields != null) {
                    _unknownFields.WriteTo(ref output);
                  }
                }
                #endif

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public int CalculateSize() {
                  int size = 0;
                  if (BatchSize != 0) {
                    size += 1 + pb::CodedOutputStream.ComputeInt32Size(BatchSize);
                  }
                  size += input_.CalculateSize(_map_input_codec);
                  if (_unknownFields != null) {
                    size += _unknownFields.CalculateSize();
                  }
                  return size;
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(LowerBound other) {
                  if (other == null) {
                    return;
                  }
                  if (other.BatchSize != 0) {
                    BatchSize = other.BatchSize;
                  }
                  input_.Add(other.input_);
                  _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                public void MergeFrom(pb::CodedInputStream input) {
                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                  input.ReadRawMessage(this);
                #else
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                        break;
                      case 8: {
                        BatchSize = input.ReadInt32();
                        break;
                      }
                      case 18: {
                        input_.AddEntriesFrom(input, _map_input_codec);
                        break;
                      }
                    }
                  }
                #endif
                }

                #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
                [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
                void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
                  uint tag;
                  while ((tag = input.ReadTag()) != 0) {
                    switch(tag) {
                      default:
                        _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                        break;
                      case 8: {
                        BatchSize = input.ReadInt32();
                        break;
                      }
                      case 18: {
                        input_.AddEntriesFrom(ref input, _map_input_codec);
                        break;
                      }
                    }
                  }
                }
                #endif

              }

            }
            #endregion

          }

        }
        #endregion

      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message ExecutionAccelerators
      ///@@
      ///@@     Specify the preferred execution accelerators to be used to execute
      ///@@     the model. Currently only recognized by ONNX Runtime backend and
      ///@@     TensorFlow backend.
      ///@@
      ///@@     For ONNX Runtime backend, it will deploy the model with the execution
      ///@@     accelerators by priority, the priority is determined based on the
      ///@@     order that they are set, i.e. the provider at the front has highest
      ///@@     priority. Overall, the priority will be in the following order:
      ///@@         &lt;gpu_execution_accelerator> (if instance is on GPU)
      ///@@         CUDA Execution Provider     (if instance is on GPU)
      ///@@         &lt;cpu_execution_accelerator>
      ///@@         Default CPU Execution Provider
      ///@@
      /// </summary>
      public sealed partial class ExecutionAccelerators : pb::IMessage<ExecutionAccelerators>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ExecutionAccelerators> _parser = new pb::MessageParser<ExecutionAccelerators>(() => new ExecutionAccelerators());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ExecutionAccelerators> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelOptimizationPolicy.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ExecutionAccelerators() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ExecutionAccelerators(ExecutionAccelerators other) : this() {
          gpuExecutionAccelerator_ = other.gpuExecutionAccelerator_.Clone();
          cpuExecutionAccelerator_ = other.cpuExecutionAccelerator_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ExecutionAccelerators Clone() {
          return new ExecutionAccelerators(this);
        }

        /// <summary>Field number for the "gpu_execution_accelerator" field.</summary>
        public const int GpuExecutionAcceleratorFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> _repeated_gpuExecutionAccelerator_codec
            = pb::FieldCodec.ForMessage(10, global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator.Parser);
        private readonly pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> gpuExecutionAccelerator_ = new pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator>();
        /// <summary>
        ///@@    .. cpp:var:: Accelerator gpu_execution_accelerator (repeated)
        ///@@
        ///@@       The preferred execution provider to be used if the model instance
        ///@@       is deployed on GPU.
        ///@@
        ///@@       For ONNX Runtime backend, possible value is "tensorrt" as name,
        ///@@       and no parameters are required.
        ///@@
        ///@@       For TensorFlow backend, possible values are "tensorrt",
        ///@@       "auto_mixed_precision", "gpu_io".
        ///@@
        ///@@       For "tensorrt", the following parameters can be specified:
        ///@@         "precision_mode": The precision used for optimization.
        ///@@         Allowed values are "FP32" and "FP16". Default value is "FP32".
        ///@@
        ///@@         "max_cached_engines": The maximum number of cached TensorRT
        ///@@         engines in dynamic TensorRT ops. Default value is 100.
        ///@@
        ///@@         "minimum_segment_size": The smallest model subgraph that will
        ///@@         be considered for optimization by TensorRT. Default value is 3.
        ///@@
        ///@@         "max_workspace_size_bytes": The maximum GPU memory the model
        ///@@         can use temporarily during execution. Default value is 1GB.
        ///@@
        ///@@       For "auto_mixed_precision", no parameters are required. If set,
        ///@@       the model will try to use FP16 for better performance.
        ///@@       This optimization can not be set with "tensorrt".
        ///@@
        ///@@       For "gpu_io", no parameters are required. If set, the model will
        ///@@       be executed using TensorFlow Callable API to set input and output
        ///@@       tensors in GPU memory if possible, which can reduce data transfer
        ///@@       overhead if the model is used in ensemble. However, the Callable
        ///@@       object will be created on model creation and it will request all
        ///@@       outputs for every model execution, which may impact the
        ///@@       performance if a request does not require all outputs. This
        ///@@       optimization will only take affect if the model instance is
        ///@@       created with KIND_GPU.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> GpuExecutionAccelerator {
          get { return gpuExecutionAccelerator_; }
        }

        /// <summary>Field number for the "cpu_execution_accelerator" field.</summary>
        public const int CpuExecutionAcceleratorFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> _repeated_cpuExecutionAccelerator_codec
            = pb::FieldCodec.ForMessage(18, global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator.Parser);
        private readonly pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> cpuExecutionAccelerator_ = new pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator>();
        /// <summary>
        ///@@    .. cpp:var:: Accelerator cpu_execution_accelerator (repeated)
        ///@@
        ///@@       The preferred execution provider to be used if the model instance
        ///@@       is deployed on CPU.
        ///@@
        ///@@       For ONNX Runtime backend, possible value is "openvino" as name,
        ///@@       and no parameters are required.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Types.Accelerator> CpuExecutionAccelerator {
          get { return cpuExecutionAccelerator_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ExecutionAccelerators);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ExecutionAccelerators other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!gpuExecutionAccelerator_.Equals(other.gpuExecutionAccelerator_)) return false;
          if(!cpuExecutionAccelerator_.Equals(other.cpuExecutionAccelerator_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= gpuExecutionAccelerator_.GetHashCode();
          hash ^= cpuExecutionAccelerator_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          gpuExecutionAccelerator_.WriteTo(output, _repeated_gpuExecutionAccelerator_codec);
          cpuExecutionAccelerator_.WriteTo(output, _repeated_cpuExecutionAccelerator_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          gpuExecutionAccelerator_.WriteTo(ref output, _repeated_gpuExecutionAccelerator_codec);
          cpuExecutionAccelerator_.WriteTo(ref output, _repeated_cpuExecutionAccelerator_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          size += gpuExecutionAccelerator_.CalculateSize(_repeated_gpuExecutionAccelerator_codec);
          size += cpuExecutionAccelerator_.CalculateSize(_repeated_cpuExecutionAccelerator_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ExecutionAccelerators other) {
          if (other == null) {
            return;
          }
          gpuExecutionAccelerator_.Add(other.gpuExecutionAccelerator_);
          cpuExecutionAccelerator_.Add(other.cpuExecutionAccelerator_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                gpuExecutionAccelerator_.AddEntriesFrom(input, _repeated_gpuExecutionAccelerator_codec);
                break;
              }
              case 18: {
                cpuExecutionAccelerator_.AddEntriesFrom(input, _repeated_cpuExecutionAccelerator_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                gpuExecutionAccelerator_.AddEntriesFrom(ref input, _repeated_gpuExecutionAccelerator_codec);
                break;
              }
              case 18: {
                cpuExecutionAccelerator_.AddEntriesFrom(ref input, _repeated_cpuExecutionAccelerator_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the ExecutionAccelerators message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///@@
          ///@@  .. cpp:var:: message Accelerator
          ///@@
          ///@@     Specify the accelerator to be used to execute the model.
          ///@@     Accelerator with the same name may accept different parameters
          ///@@     depending on the backends.
          ///@@
          /// </summary>
          public sealed partial class Accelerator : pb::IMessage<Accelerator>
          #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              , pb::IBufferMessage
          #endif
          {
            private static readonly pb::MessageParser<Accelerator> _parser = new pb::MessageParser<Accelerator>(() => new Accelerator());
            private pb::UnknownFieldSet _unknownFields;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pb::MessageParser<Accelerator> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Inference.ModelOptimizationPolicy.Types.ExecutionAccelerators.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Accelerator() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Accelerator(Accelerator other) : this() {
              name_ = other.name_;
              parameters_ = other.parameters_.Clone();
              _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public Accelerator Clone() {
              return new Accelerator(this);
            }

            /// <summary>Field number for the "name" field.</summary>
            public const int NameFieldNumber = 1;
            private string name_ = "";
            /// <summary>
            ///@@    .. cpp:var:: string name
            ///@@
            ///@@       The name of the execution accelerator.
            ///@@
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public string Name {
              get { return name_; }
              set {
                name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
              }
            }

            /// <summary>Field number for the "parameters" field.</summary>
            public const int ParametersFieldNumber = 2;
            private static readonly pbc::MapField<string, string>.Codec _map_parameters_codec
                = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 18);
            private readonly pbc::MapField<string, string> parameters_ = new pbc::MapField<string, string>();
            /// <summary>
            ///@@    .. cpp:var:: map&lt;string, string> parameters
            ///@@
            ///@@       Additional paremeters used to configure the accelerator.
            ///@@
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public pbc::MapField<string, string> Parameters {
              get { return parameters_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override bool Equals(object other) {
              return Equals(other as Accelerator);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public bool Equals(Accelerator other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (Name != other.Name) return false;
              if (!Parameters.Equals(other.Parameters)) return false;
              return Equals(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override int GetHashCode() {
              int hash = 1;
              if (Name.Length != 0) hash ^= Name.GetHashCode();
              hash ^= Parameters.GetHashCode();
              if (_unknownFields != null) {
                hash ^= _unknownFields.GetHashCode();
              }
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void WriteTo(pb::CodedOutputStream output) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              output.WriteRawMessage(this);
            #else
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              parameters_.WriteTo(output, _map_parameters_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(output);
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
              if (Name.Length != 0) {
                output.WriteRawTag(10);
                output.WriteString(Name);
              }
              parameters_.WriteTo(ref output, _map_parameters_codec);
              if (_unknownFields != null) {
                _unknownFields.WriteTo(ref output);
              }
            }
            #endif

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public int CalculateSize() {
              int size = 0;
              if (Name.Length != 0) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
              }
              size += parameters_.CalculateSize(_map_parameters_codec);
              if (_unknownFields != null) {
                size += _unknownFields.CalculateSize();
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(Accelerator other) {
              if (other == null) {
                return;
              }
              if (other.Name.Length != 0) {
                Name = other.Name;
              }
              parameters_.Add(other.parameters_);
              _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            public void MergeFrom(pb::CodedInputStream input) {
            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
              input.ReadRawMessage(this);
            #else
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                  case 18: {
                    parameters_.AddEntriesFrom(input, _map_parameters_codec);
                    break;
                  }
                }
              }
            #endif
            }

            #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
            void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                    break;
                  case 10: {
                    Name = input.ReadString();
                    break;
                  }
                  case 18: {
                    parameters_.AddEntriesFrom(ref input, _map_parameters_codec);
                    break;
                  }
                }
              }
            }
            #endif

          }

        }
        #endregion

      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message PinnedMemoryBuffer
      ///@@
      ///@@     Specify whether to use a pinned memory buffer when transferring data
      ///@@     between non-pinned system memory and GPU memory. Using a pinned
      ///@@     memory buffer for system from/to GPU transfers will typically provide
      ///@@     increased performance. For example, in the common use case where the
      ///@@     request provides inputs and delivers outputs via non-pinned system
      ///@@     memory, if the model instance accepts GPU IOs, the inputs will be
      ///@@     processed by two copies: from non-pinned system memory to pinned
      ///@@     memory, and from pinned memory to GPU memory. Similarly, pinned
      ///@@     memory will be used for delivering the outputs.
      ///@@
      /// </summary>
      public sealed partial class PinnedMemoryBuffer : pb::IMessage<PinnedMemoryBuffer>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<PinnedMemoryBuffer> _parser = new pb::MessageParser<PinnedMemoryBuffer>(() => new PinnedMemoryBuffer());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<PinnedMemoryBuffer> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelOptimizationPolicy.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PinnedMemoryBuffer() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PinnedMemoryBuffer(PinnedMemoryBuffer other) : this() {
          enable_ = other.enable_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public PinnedMemoryBuffer Clone() {
          return new PinnedMemoryBuffer(this);
        }

        /// <summary>Field number for the "enable" field.</summary>
        public const int EnableFieldNumber = 1;
        private bool enable_;
        /// <summary>
        ///@@    .. cpp:var:: bool enable
        ///@@
        ///@@       Use pinned memory buffer. Default is true.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Enable {
          get { return enable_; }
          set {
            enable_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as PinnedMemoryBuffer);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(PinnedMemoryBuffer other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Enable != other.Enable) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Enable != false) hash ^= Enable.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Enable != false) {
            output.WriteRawTag(8);
            output.WriteBool(Enable);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Enable != false) {
            output.WriteRawTag(8);
            output.WriteBool(Enable);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Enable != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(PinnedMemoryBuffer other) {
          if (other == null) {
            return;
          }
          if (other.Enable != false) {
            Enable = other.Enable;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Enable = input.ReadBool();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Enable = input.ReadBool();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelQueuePolicy
  ///@@
  ///@@   Queue policy for inference requests.
  ///@@
  /// </summary>
  public sealed partial class ModelQueuePolicy : pb::IMessage<ModelQueuePolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelQueuePolicy> _parser = new pb::MessageParser<ModelQueuePolicy>(() => new ModelQueuePolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelQueuePolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelQueuePolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelQueuePolicy(ModelQueuePolicy other) : this() {
      timeoutAction_ = other.timeoutAction_;
      defaultTimeoutMicroseconds_ = other.defaultTimeoutMicroseconds_;
      allowTimeoutOverride_ = other.allowTimeoutOverride_;
      maxQueueSize_ = other.maxQueueSize_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelQueuePolicy Clone() {
      return new ModelQueuePolicy(this);
    }

    /// <summary>Field number for the "timeout_action" field.</summary>
    public const int TimeoutActionFieldNumber = 1;
    private global::Inference.ModelQueuePolicy.Types.TimeoutAction timeoutAction_ = global::Inference.ModelQueuePolicy.Types.TimeoutAction.Reject;
    /// <summary>
    ///@@
    ///@@  .. cpp:var:: TimeoutAction timeout_action
    ///@@
    ///@@     The action applied to timed-out request.
    ///@@     The default action is REJECT.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelQueuePolicy.Types.TimeoutAction TimeoutAction {
      get { return timeoutAction_; }
      set {
        timeoutAction_ = value;
      }
    }

    /// <summary>Field number for the "default_timeout_microseconds" field.</summary>
    public const int DefaultTimeoutMicrosecondsFieldNumber = 2;
    private ulong defaultTimeoutMicroseconds_;
    /// <summary>
    ///@@
    ///@@  .. cpp:var:: uint64 default_timeout_microseconds
    ///@@
    ///@@     The default timeout for every request, in microseconds.
    ///@@     The default value is 0 which indicates that no timeout is set.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong DefaultTimeoutMicroseconds {
      get { return defaultTimeoutMicroseconds_; }
      set {
        defaultTimeoutMicroseconds_ = value;
      }
    }

    /// <summary>Field number for the "allow_timeout_override" field.</summary>
    public const int AllowTimeoutOverrideFieldNumber = 3;
    private bool allowTimeoutOverride_;
    /// <summary>
    ///@@
    ///@@  .. cpp:var:: bool allow_timeout_override
    ///@@
    ///@@     Whether individual request can override the default timeout value.
    ///@@     When true, individual requests can set a timeout that is less than
    ///@@     the default timeout value but may not increase the timeout.
    ///@@     The default value is false.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool AllowTimeoutOverride {
      get { return allowTimeoutOverride_; }
      set {
        allowTimeoutOverride_ = value;
      }
    }

    /// <summary>Field number for the "max_queue_size" field.</summary>
    public const int MaxQueueSizeFieldNumber = 4;
    private uint maxQueueSize_;
    /// <summary>
    ///@@
    ///@@  .. cpp:var:: uint32 max_queue_size
    ///@@
    ///@@     The maximum queue size for holding requests. A request will be
    ///@@     rejected immediately if it can't be enqueued because the queue is
    ///@@     full. The default value is 0 which indicates that no maximum
    ///@@     queue size is enforced.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint MaxQueueSize {
      get { return maxQueueSize_; }
      set {
        maxQueueSize_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelQueuePolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelQueuePolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TimeoutAction != other.TimeoutAction) return false;
      if (DefaultTimeoutMicroseconds != other.DefaultTimeoutMicroseconds) return false;
      if (AllowTimeoutOverride != other.AllowTimeoutOverride) return false;
      if (MaxQueueSize != other.MaxQueueSize) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (TimeoutAction != global::Inference.ModelQueuePolicy.Types.TimeoutAction.Reject) hash ^= TimeoutAction.GetHashCode();
      if (DefaultTimeoutMicroseconds != 0UL) hash ^= DefaultTimeoutMicroseconds.GetHashCode();
      if (AllowTimeoutOverride != false) hash ^= AllowTimeoutOverride.GetHashCode();
      if (MaxQueueSize != 0) hash ^= MaxQueueSize.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TimeoutAction != global::Inference.ModelQueuePolicy.Types.TimeoutAction.Reject) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TimeoutAction);
      }
      if (DefaultTimeoutMicroseconds != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(DefaultTimeoutMicroseconds);
      }
      if (AllowTimeoutOverride != false) {
        output.WriteRawTag(24);
        output.WriteBool(AllowTimeoutOverride);
      }
      if (MaxQueueSize != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(MaxQueueSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TimeoutAction != global::Inference.ModelQueuePolicy.Types.TimeoutAction.Reject) {
        output.WriteRawTag(8);
        output.WriteEnum((int) TimeoutAction);
      }
      if (DefaultTimeoutMicroseconds != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(DefaultTimeoutMicroseconds);
      }
      if (AllowTimeoutOverride != false) {
        output.WriteRawTag(24);
        output.WriteBool(AllowTimeoutOverride);
      }
      if (MaxQueueSize != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(MaxQueueSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (TimeoutAction != global::Inference.ModelQueuePolicy.Types.TimeoutAction.Reject) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TimeoutAction);
      }
      if (DefaultTimeoutMicroseconds != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(DefaultTimeoutMicroseconds);
      }
      if (AllowTimeoutOverride != false) {
        size += 1 + 1;
      }
      if (MaxQueueSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxQueueSize);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelQueuePolicy other) {
      if (other == null) {
        return;
      }
      if (other.TimeoutAction != global::Inference.ModelQueuePolicy.Types.TimeoutAction.Reject) {
        TimeoutAction = other.TimeoutAction;
      }
      if (other.DefaultTimeoutMicroseconds != 0UL) {
        DefaultTimeoutMicroseconds = other.DefaultTimeoutMicroseconds;
      }
      if (other.AllowTimeoutOverride != false) {
        AllowTimeoutOverride = other.AllowTimeoutOverride;
      }
      if (other.MaxQueueSize != 0) {
        MaxQueueSize = other.MaxQueueSize;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TimeoutAction = (global::Inference.ModelQueuePolicy.Types.TimeoutAction) input.ReadEnum();
            break;
          }
          case 16: {
            DefaultTimeoutMicroseconds = input.ReadUInt64();
            break;
          }
          case 24: {
            AllowTimeoutOverride = input.ReadBool();
            break;
          }
          case 32: {
            MaxQueueSize = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            TimeoutAction = (global::Inference.ModelQueuePolicy.Types.TimeoutAction) input.ReadEnum();
            break;
          }
          case 16: {
            DefaultTimeoutMicroseconds = input.ReadUInt64();
            break;
          }
          case 24: {
            AllowTimeoutOverride = input.ReadBool();
            break;
          }
          case 32: {
            MaxQueueSize = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelQueuePolicy message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:enum:: TimeoutAction
      ///@@
      ///@@     The action applied to timed-out requests.
      ///@@
      /// </summary>
      public enum TimeoutAction {
        /// <summary>
        ///@@    .. cpp:enumerator:: Action::REJECT = 0
        ///@@
        ///@@       Reject the request and return error message accordingly.
        ///@@
        /// </summary>
        [pbr::OriginalName("REJECT")] Reject = 0,
        /// <summary>
        ///@@    .. cpp:enumerator:: Action::DELAY = 1
        ///@@
        ///@@       Delay the request until all other requests at the same
        ///@@       (or higher) priority levels that have not reached their timeouts
        ///@@       are processed. A delayed request will eventually be processed,
        ///@@       but may be delayed indefinitely due to newly arriving requests.
        ///@@
        /// </summary>
        [pbr::OriginalName("DELAY")] Delay = 1,
      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelDynamicBatching
  ///@@
  ///@@   Dynamic batching configuration. These settings control how dynamic
  ///@@   batching operates for the model.
  ///@@
  /// </summary>
  public sealed partial class ModelDynamicBatching : pb::IMessage<ModelDynamicBatching>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelDynamicBatching> _parser = new pb::MessageParser<ModelDynamicBatching>(() => new ModelDynamicBatching());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelDynamicBatching> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelDynamicBatching() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelDynamicBatching(ModelDynamicBatching other) : this() {
      preferredBatchSize_ = other.preferredBatchSize_.Clone();
      maxQueueDelayMicroseconds_ = other.maxQueueDelayMicroseconds_;
      preserveOrdering_ = other.preserveOrdering_;
      priorityLevels_ = other.priorityLevels_;
      defaultPriorityLevel_ = other.defaultPriorityLevel_;
      defaultQueuePolicy_ = other.defaultQueuePolicy_ != null ? other.defaultQueuePolicy_.Clone() : null;
      priorityQueuePolicy_ = other.priorityQueuePolicy_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelDynamicBatching Clone() {
      return new ModelDynamicBatching(this);
    }

    /// <summary>Field number for the "preferred_batch_size" field.</summary>
    public const int PreferredBatchSizeFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_preferredBatchSize_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> preferredBatchSize_ = new pbc::RepeatedField<int>();
    /// <summary>
    ///@@  .. cpp:var:: int32 preferred_batch_size (repeated)
    ///@@
    ///@@     Preferred batch sizes for dynamic batching. If a batch of one of
    ///@@     these sizes can be formed it will be executed immediately.  If
    ///@@     not specified a preferred batch size will be chosen automatically
    ///@@     based on model and GPU characteristics.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<int> PreferredBatchSize {
      get { return preferredBatchSize_; }
    }

    /// <summary>Field number for the "max_queue_delay_microseconds" field.</summary>
    public const int MaxQueueDelayMicrosecondsFieldNumber = 2;
    private ulong maxQueueDelayMicroseconds_;
    /// <summary>
    ///@@  .. cpp:var:: uint64 max_queue_delay_microseconds
    ///@@
    ///@@     The maximum time, in microseconds, a request will be delayed in
    ///@@     the scheduling queue to wait for additional requests for
    ///@@     batching. Default is 0.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MaxQueueDelayMicroseconds {
      get { return maxQueueDelayMicroseconds_; }
      set {
        maxQueueDelayMicroseconds_ = value;
      }
    }

    /// <summary>Field number for the "preserve_ordering" field.</summary>
    public const int PreserveOrderingFieldNumber = 3;
    private bool preserveOrdering_;
    /// <summary>
    ///@@  .. cpp:var:: bool preserve_ordering
    ///@@
    ///@@     Should the dynamic batcher preserve the ordering of responses to
    ///@@     match the order of requests received by the scheduler. Default is
    ///@@     false. If true, the responses will be returned in the same order as
    ///@@     the order of requests sent to the scheduler. If false, the responses
    ///@@     may be returned in arbitrary order. This option is specifically
    ///@@     needed when a sequence of related inference requests (i.e. inference
    ///@@     requests with the same correlation ID) are sent to the dynamic
    ///@@     batcher to ensure that the sequence responses are in the correct
    ///@@     order.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool PreserveOrdering {
      get { return preserveOrdering_; }
      set {
        preserveOrdering_ = value;
      }
    }

    /// <summary>Field number for the "priority_levels" field.</summary>
    public const int PriorityLevelsFieldNumber = 4;
    private uint priorityLevels_;
    /// <summary>
    ///@@  .. cpp:var:: uint32 priority_levels
    ///@@
    ///@@     The number of priority levels to be enabled for the model,
    ///@@     the priority level starts from 1 and 1 is the highest priority.
    ///@@     Requests are handled in priority order with all priority 1 requests
    ///@@     processed before priority 2, all priority 2 requests processed before
    ///@@     priority 3, etc. Requests with the same priority level will be
    ///@@     handled in the order that they are received.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint PriorityLevels {
      get { return priorityLevels_; }
      set {
        priorityLevels_ = value;
      }
    }

    /// <summary>Field number for the "default_priority_level" field.</summary>
    public const int DefaultPriorityLevelFieldNumber = 5;
    private uint defaultPriorityLevel_;
    /// <summary>
    ///@@  .. cpp:var:: uint32 default_priority_level
    ///@@
    ///@@     The priority level used for requests that don't specify their
    ///@@     priority. The value must be in the range [ 1, 'priority_levels' ].
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint DefaultPriorityLevel {
      get { return defaultPriorityLevel_; }
      set {
        defaultPriorityLevel_ = value;
      }
    }

    /// <summary>Field number for the "default_queue_policy" field.</summary>
    public const int DefaultQueuePolicyFieldNumber = 6;
    private global::Inference.ModelQueuePolicy defaultQueuePolicy_;
    /// <summary>
    ///@@  .. cpp:var:: ModelQueuePolicy default_queue_policy
    ///@@
    ///@@     The default queue policy used for requests that don't require
    ///@@     priority handling and requests that specify priority levels where
    ///@@     there is no specific policy given. If not specified, a policy with
    ///@@     default field values will be used.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelQueuePolicy DefaultQueuePolicy {
      get { return defaultQueuePolicy_; }
      set {
        defaultQueuePolicy_ = value;
      }
    }

    /// <summary>Field number for the "priority_queue_policy" field.</summary>
    public const int PriorityQueuePolicyFieldNumber = 7;
    private static readonly pbc::MapField<uint, global::Inference.ModelQueuePolicy>.Codec _map_priorityQueuePolicy_codec
        = new pbc::MapField<uint, global::Inference.ModelQueuePolicy>.Codec(pb::FieldCodec.ForUInt32(8, 0), pb::FieldCodec.ForMessage(18, global::Inference.ModelQueuePolicy.Parser), 58);
    private readonly pbc::MapField<uint, global::Inference.ModelQueuePolicy> priorityQueuePolicy_ = new pbc::MapField<uint, global::Inference.ModelQueuePolicy>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;uint32, ModelQueuePolicy> priority_queue_policy
    ///@@
    ///@@     Specify the queue policy for the priority level. The default queue
    ///@@     policy will be used if a priority level doesn't specify a queue
    ///@@     policy.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<uint, global::Inference.ModelQueuePolicy> PriorityQueuePolicy {
      get { return priorityQueuePolicy_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelDynamicBatching);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelDynamicBatching other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!preferredBatchSize_.Equals(other.preferredBatchSize_)) return false;
      if (MaxQueueDelayMicroseconds != other.MaxQueueDelayMicroseconds) return false;
      if (PreserveOrdering != other.PreserveOrdering) return false;
      if (PriorityLevels != other.PriorityLevels) return false;
      if (DefaultPriorityLevel != other.DefaultPriorityLevel) return false;
      if (!object.Equals(DefaultQueuePolicy, other.DefaultQueuePolicy)) return false;
      if (!PriorityQueuePolicy.Equals(other.PriorityQueuePolicy)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= preferredBatchSize_.GetHashCode();
      if (MaxQueueDelayMicroseconds != 0UL) hash ^= MaxQueueDelayMicroseconds.GetHashCode();
      if (PreserveOrdering != false) hash ^= PreserveOrdering.GetHashCode();
      if (PriorityLevels != 0) hash ^= PriorityLevels.GetHashCode();
      if (DefaultPriorityLevel != 0) hash ^= DefaultPriorityLevel.GetHashCode();
      if (defaultQueuePolicy_ != null) hash ^= DefaultQueuePolicy.GetHashCode();
      hash ^= PriorityQueuePolicy.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      preferredBatchSize_.WriteTo(output, _repeated_preferredBatchSize_codec);
      if (MaxQueueDelayMicroseconds != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(MaxQueueDelayMicroseconds);
      }
      if (PreserveOrdering != false) {
        output.WriteRawTag(24);
        output.WriteBool(PreserveOrdering);
      }
      if (PriorityLevels != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(PriorityLevels);
      }
      if (DefaultPriorityLevel != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(DefaultPriorityLevel);
      }
      if (defaultQueuePolicy_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DefaultQueuePolicy);
      }
      priorityQueuePolicy_.WriteTo(output, _map_priorityQueuePolicy_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      preferredBatchSize_.WriteTo(ref output, _repeated_preferredBatchSize_codec);
      if (MaxQueueDelayMicroseconds != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(MaxQueueDelayMicroseconds);
      }
      if (PreserveOrdering != false) {
        output.WriteRawTag(24);
        output.WriteBool(PreserveOrdering);
      }
      if (PriorityLevels != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(PriorityLevels);
      }
      if (DefaultPriorityLevel != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(DefaultPriorityLevel);
      }
      if (defaultQueuePolicy_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(DefaultQueuePolicy);
      }
      priorityQueuePolicy_.WriteTo(ref output, _map_priorityQueuePolicy_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += preferredBatchSize_.CalculateSize(_repeated_preferredBatchSize_codec);
      if (MaxQueueDelayMicroseconds != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxQueueDelayMicroseconds);
      }
      if (PreserveOrdering != false) {
        size += 1 + 1;
      }
      if (PriorityLevels != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PriorityLevels);
      }
      if (DefaultPriorityLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DefaultPriorityLevel);
      }
      if (defaultQueuePolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultQueuePolicy);
      }
      size += priorityQueuePolicy_.CalculateSize(_map_priorityQueuePolicy_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelDynamicBatching other) {
      if (other == null) {
        return;
      }
      preferredBatchSize_.Add(other.preferredBatchSize_);
      if (other.MaxQueueDelayMicroseconds != 0UL) {
        MaxQueueDelayMicroseconds = other.MaxQueueDelayMicroseconds;
      }
      if (other.PreserveOrdering != false) {
        PreserveOrdering = other.PreserveOrdering;
      }
      if (other.PriorityLevels != 0) {
        PriorityLevels = other.PriorityLevels;
      }
      if (other.DefaultPriorityLevel != 0) {
        DefaultPriorityLevel = other.DefaultPriorityLevel;
      }
      if (other.defaultQueuePolicy_ != null) {
        if (defaultQueuePolicy_ == null) {
          DefaultQueuePolicy = new global::Inference.ModelQueuePolicy();
        }
        DefaultQueuePolicy.MergeFrom(other.DefaultQueuePolicy);
      }
      priorityQueuePolicy_.Add(other.priorityQueuePolicy_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            preferredBatchSize_.AddEntriesFrom(input, _repeated_preferredBatchSize_codec);
            break;
          }
          case 16: {
            MaxQueueDelayMicroseconds = input.ReadUInt64();
            break;
          }
          case 24: {
            PreserveOrdering = input.ReadBool();
            break;
          }
          case 32: {
            PriorityLevels = input.ReadUInt32();
            break;
          }
          case 40: {
            DefaultPriorityLevel = input.ReadUInt32();
            break;
          }
          case 50: {
            if (defaultQueuePolicy_ == null) {
              DefaultQueuePolicy = new global::Inference.ModelQueuePolicy();
            }
            input.ReadMessage(DefaultQueuePolicy);
            break;
          }
          case 58: {
            priorityQueuePolicy_.AddEntriesFrom(input, _map_priorityQueuePolicy_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10:
          case 8: {
            preferredBatchSize_.AddEntriesFrom(ref input, _repeated_preferredBatchSize_codec);
            break;
          }
          case 16: {
            MaxQueueDelayMicroseconds = input.ReadUInt64();
            break;
          }
          case 24: {
            PreserveOrdering = input.ReadBool();
            break;
          }
          case 32: {
            PriorityLevels = input.ReadUInt32();
            break;
          }
          case 40: {
            DefaultPriorityLevel = input.ReadUInt32();
            break;
          }
          case 50: {
            if (defaultQueuePolicy_ == null) {
              DefaultQueuePolicy = new global::Inference.ModelQueuePolicy();
            }
            input.ReadMessage(DefaultQueuePolicy);
            break;
          }
          case 58: {
            priorityQueuePolicy_.AddEntriesFrom(ref input, _map_priorityQueuePolicy_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelSequenceBatching
  ///@@
  ///@@   Sequence batching configuration. These settings control how sequence
  ///@@   batching operates for the model.
  ///@@
  /// </summary>
  public sealed partial class ModelSequenceBatching : pb::IMessage<ModelSequenceBatching>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelSequenceBatching> _parser = new pb::MessageParser<ModelSequenceBatching>(() => new ModelSequenceBatching());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelSequenceBatching> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelSequenceBatching() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelSequenceBatching(ModelSequenceBatching other) : this() {
      maxSequenceIdleMicroseconds_ = other.maxSequenceIdleMicroseconds_;
      controlInput_ = other.controlInput_.Clone();
      state_ = other.state_.Clone();
      switch (other.StrategyChoiceCase) {
        case StrategyChoiceOneofCase.Direct:
          Direct = other.Direct.Clone();
          break;
        case StrategyChoiceOneofCase.Oldest:
          Oldest = other.Oldest.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelSequenceBatching Clone() {
      return new ModelSequenceBatching(this);
    }

    /// <summary>Field number for the "direct" field.</summary>
    public const int DirectFieldNumber = 3;
    /// <summary>
    ///@@    .. cpp:var:: StrategyDirect direct
    ///@@
    ///@@       StrategyDirect scheduling strategy.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelSequenceBatching.Types.StrategyDirect Direct {
      get { return strategyChoiceCase_ == StrategyChoiceOneofCase.Direct ? (global::Inference.ModelSequenceBatching.Types.StrategyDirect) strategyChoice_ : null; }
      set {
        strategyChoice_ = value;
        strategyChoiceCase_ = value == null ? StrategyChoiceOneofCase.None : StrategyChoiceOneofCase.Direct;
      }
    }

    /// <summary>Field number for the "oldest" field.</summary>
    public const int OldestFieldNumber = 4;
    /// <summary>
    ///@@    .. cpp:var:: StrategyOldest oldest
    ///@@
    ///@@       StrategyOldest scheduling strategy.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelSequenceBatching.Types.StrategyOldest Oldest {
      get { return strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest ? (global::Inference.ModelSequenceBatching.Types.StrategyOldest) strategyChoice_ : null; }
      set {
        strategyChoice_ = value;
        strategyChoiceCase_ = value == null ? StrategyChoiceOneofCase.None : StrategyChoiceOneofCase.Oldest;
      }
    }

    /// <summary>Field number for the "max_sequence_idle_microseconds" field.</summary>
    public const int MaxSequenceIdleMicrosecondsFieldNumber = 1;
    private ulong maxSequenceIdleMicroseconds_;
    /// <summary>
    ///@@  .. cpp:var:: uint64 max_sequence_idle_microseconds
    ///@@
    ///@@     The maximum time, in microseconds, that a sequence is allowed to
    ///@@     be idle before it is aborted. The inference server considers a
    ///@@     sequence idle when it does not have any inference request queued
    ///@@     for the sequence. If this limit is exceeded, the inference server
    ///@@     will free the sequence slot allocated by the sequence and make it
    ///@@     available for another sequence. If not specified (or specified as
    ///@@     zero) a default value of 1000000 (1 second) is used.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong MaxSequenceIdleMicroseconds {
      get { return maxSequenceIdleMicroseconds_; }
      set {
        maxSequenceIdleMicroseconds_ = value;
      }
    }

    /// <summary>Field number for the "control_input" field.</summary>
    public const int ControlInputFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Inference.ModelSequenceBatching.Types.ControlInput> _repeated_controlInput_codec
        = pb::FieldCodec.ForMessage(18, global::Inference.ModelSequenceBatching.Types.ControlInput.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.ControlInput> controlInput_ = new pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.ControlInput>();
    /// <summary>
    ///@@  .. cpp:var:: ControlInput control_input (repeated)
    ///@@
    ///@@     The model input(s) that the server should use to communicate
    ///@@     sequence start, stop, ready and similar control values to the
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.ControlInput> ControlInput {
      get { return controlInput_; }
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Inference.ModelSequenceBatching.Types.State> _repeated_state_codec
        = pb::FieldCodec.ForMessage(42, global::Inference.ModelSequenceBatching.Types.State.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.State> state_ = new pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.State>();
    /// <summary>
    ///@@  .. cpp:var:: State state (repeated)
    ///@@
    ///@@     The optional state that can be stored in Triton for performing
    ///@@     inference requests on a sequence. Each sequence holds an implicit
    ///@@     state local to itself. The output state tensor provided by the
    ///@@     model in 'output_name' field of the current inference request will
    ///@@     be transferred as an input tensor named 'input_name' in the next
    ///@@     request of the same sequence. The input state of the first request
    ///@@     in the sequence contains garbage data.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.State> State {
      get { return state_; }
    }

    private object strategyChoice_;
    /// <summary>Enum of possible cases for the "strategy_choice" oneof.</summary>
    public enum StrategyChoiceOneofCase {
      None = 0,
      Direct = 3,
      Oldest = 4,
    }
    private StrategyChoiceOneofCase strategyChoiceCase_ = StrategyChoiceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public StrategyChoiceOneofCase StrategyChoiceCase {
      get { return strategyChoiceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearStrategyChoice() {
      strategyChoiceCase_ = StrategyChoiceOneofCase.None;
      strategyChoice_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelSequenceBatching);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelSequenceBatching other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Direct, other.Direct)) return false;
      if (!object.Equals(Oldest, other.Oldest)) return false;
      if (MaxSequenceIdleMicroseconds != other.MaxSequenceIdleMicroseconds) return false;
      if(!controlInput_.Equals(other.controlInput_)) return false;
      if(!state_.Equals(other.state_)) return false;
      if (StrategyChoiceCase != other.StrategyChoiceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) hash ^= Direct.GetHashCode();
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) hash ^= Oldest.GetHashCode();
      if (MaxSequenceIdleMicroseconds != 0UL) hash ^= MaxSequenceIdleMicroseconds.GetHashCode();
      hash ^= controlInput_.GetHashCode();
      hash ^= state_.GetHashCode();
      hash ^= (int) strategyChoiceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (MaxSequenceIdleMicroseconds != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(MaxSequenceIdleMicroseconds);
      }
      controlInput_.WriteTo(output, _repeated_controlInput_codec);
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
        output.WriteRawTag(26);
        output.WriteMessage(Direct);
      }
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
        output.WriteRawTag(34);
        output.WriteMessage(Oldest);
      }
      state_.WriteTo(output, _repeated_state_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (MaxSequenceIdleMicroseconds != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(MaxSequenceIdleMicroseconds);
      }
      controlInput_.WriteTo(ref output, _repeated_controlInput_codec);
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
        output.WriteRawTag(26);
        output.WriteMessage(Direct);
      }
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
        output.WriteRawTag(34);
        output.WriteMessage(Oldest);
      }
      state_.WriteTo(ref output, _repeated_state_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Direct);
      }
      if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Oldest);
      }
      if (MaxSequenceIdleMicroseconds != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxSequenceIdleMicroseconds);
      }
      size += controlInput_.CalculateSize(_repeated_controlInput_codec);
      size += state_.CalculateSize(_repeated_state_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelSequenceBatching other) {
      if (other == null) {
        return;
      }
      if (other.MaxSequenceIdleMicroseconds != 0UL) {
        MaxSequenceIdleMicroseconds = other.MaxSequenceIdleMicroseconds;
      }
      controlInput_.Add(other.controlInput_);
      state_.Add(other.state_);
      switch (other.StrategyChoiceCase) {
        case StrategyChoiceOneofCase.Direct:
          if (Direct == null) {
            Direct = new global::Inference.ModelSequenceBatching.Types.StrategyDirect();
          }
          Direct.MergeFrom(other.Direct);
          break;
        case StrategyChoiceOneofCase.Oldest:
          if (Oldest == null) {
            Oldest = new global::Inference.ModelSequenceBatching.Types.StrategyOldest();
          }
          Oldest.MergeFrom(other.Oldest);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxSequenceIdleMicroseconds = input.ReadUInt64();
            break;
          }
          case 18: {
            controlInput_.AddEntriesFrom(input, _repeated_controlInput_codec);
            break;
          }
          case 26: {
            global::Inference.ModelSequenceBatching.Types.StrategyDirect subBuilder = new global::Inference.ModelSequenceBatching.Types.StrategyDirect();
            if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
              subBuilder.MergeFrom(Direct);
            }
            input.ReadMessage(subBuilder);
            Direct = subBuilder;
            break;
          }
          case 34: {
            global::Inference.ModelSequenceBatching.Types.StrategyOldest subBuilder = new global::Inference.ModelSequenceBatching.Types.StrategyOldest();
            if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
              subBuilder.MergeFrom(Oldest);
            }
            input.ReadMessage(subBuilder);
            Oldest = subBuilder;
            break;
          }
          case 42: {
            state_.AddEntriesFrom(input, _repeated_state_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            MaxSequenceIdleMicroseconds = input.ReadUInt64();
            break;
          }
          case 18: {
            controlInput_.AddEntriesFrom(ref input, _repeated_controlInput_codec);
            break;
          }
          case 26: {
            global::Inference.ModelSequenceBatching.Types.StrategyDirect subBuilder = new global::Inference.ModelSequenceBatching.Types.StrategyDirect();
            if (strategyChoiceCase_ == StrategyChoiceOneofCase.Direct) {
              subBuilder.MergeFrom(Direct);
            }
            input.ReadMessage(subBuilder);
            Direct = subBuilder;
            break;
          }
          case 34: {
            global::Inference.ModelSequenceBatching.Types.StrategyOldest subBuilder = new global::Inference.ModelSequenceBatching.Types.StrategyOldest();
            if (strategyChoiceCase_ == StrategyChoiceOneofCase.Oldest) {
              subBuilder.MergeFrom(Oldest);
            }
            input.ReadMessage(subBuilder);
            Oldest = subBuilder;
            break;
          }
          case 42: {
            state_.AddEntriesFrom(ref input, _repeated_state_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelSequenceBatching message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@  .. cpp:var:: message Control
      ///@@
      ///@@     A control is a signal that the sequence batcher uses to
      ///@@     communicate with a backend.
      ///@@
      /// </summary>
      public sealed partial class Control : pb::IMessage<Control>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Control> _parser = new pb::MessageParser<Control>(() => new Control());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Control> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelSequenceBatching.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Control() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Control(Control other) : this() {
          kind_ = other.kind_;
          int32FalseTrue_ = other.int32FalseTrue_.Clone();
          fp32FalseTrue_ = other.fp32FalseTrue_.Clone();
          boolFalseTrue_ = other.boolFalseTrue_.Clone();
          dataType_ = other.dataType_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Control Clone() {
          return new Control(this);
        }

        /// <summary>Field number for the "kind" field.</summary>
        public const int KindFieldNumber = 1;
        private global::Inference.ModelSequenceBatching.Types.Control.Types.Kind kind_ = global::Inference.ModelSequenceBatching.Types.Control.Types.Kind.ControlSequenceStart;
        /// <summary>
        ///@@    .. cpp:var:: Kind kind
        ///@@
        ///@@       The kind of this control.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Inference.ModelSequenceBatching.Types.Control.Types.Kind Kind {
          get { return kind_; }
          set {
            kind_ = value;
          }
        }

        /// <summary>Field number for the "int32_false_true" field.</summary>
        public const int Int32FalseTrueFieldNumber = 2;
        private static readonly pb::FieldCodec<int> _repeated_int32FalseTrue_codec
            = pb::FieldCodec.ForInt32(18);
        private readonly pbc::RepeatedField<int> int32FalseTrue_ = new pbc::RepeatedField<int>();
        /// <summary>
        ///@@    .. cpp:var:: int32 int32_false_true (repeated)
        ///@@
        ///@@       The control's true and false setting is indicated by setting
        ///@@       a value in an int32 tensor. The tensor must be a
        ///@@       1-dimensional tensor with size equal to the batch size of
        ///@@       the request. 'int32_false_true' must have two entries: the
        ///@@       first the false value and the second the true value.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<int> Int32FalseTrue {
          get { return int32FalseTrue_; }
        }

        /// <summary>Field number for the "fp32_false_true" field.</summary>
        public const int Fp32FalseTrueFieldNumber = 3;
        private static readonly pb::FieldCodec<float> _repeated_fp32FalseTrue_codec
            = pb::FieldCodec.ForFloat(26);
        private readonly pbc::RepeatedField<float> fp32FalseTrue_ = new pbc::RepeatedField<float>();
        /// <summary>
        ///@@    .. cpp:var:: float fp32_false_true (repeated)
        ///@@
        ///@@       The control's true and false setting is indicated by setting
        ///@@       a value in a fp32 tensor. The tensor must be a
        ///@@       1-dimensional tensor with size equal to the batch size of
        ///@@       the request. 'fp32_false_true' must have two entries: the
        ///@@       first the false value and the second the true value.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<float> Fp32FalseTrue {
          get { return fp32FalseTrue_; }
        }

        /// <summary>Field number for the "bool_false_true" field.</summary>
        public const int BoolFalseTrueFieldNumber = 5;
        private static readonly pb::FieldCodec<bool> _repeated_boolFalseTrue_codec
            = pb::FieldCodec.ForBool(42);
        private readonly pbc::RepeatedField<bool> boolFalseTrue_ = new pbc::RepeatedField<bool>();
        /// <summary>
        ///@@    .. cpp:var:: bool bool_false_true (repeated)
        ///@@
        ///@@       The control's true and false setting is indicated by setting
        ///@@       a value in a bool tensor. The tensor must be a
        ///@@       1-dimensional tensor with size equal to the batch size of
        ///@@       the request. 'bool_false_true' must have two entries: the
        ///@@       first the false value and the second the true value.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<bool> BoolFalseTrue {
          get { return boolFalseTrue_; }
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 4;
        private global::Inference.DataType dataType_ = global::Inference.DataType.TypeInvalid;
        /// <summary>
        ///@@    .. cpp:var:: DataType data_type
        ///@@
        ///@@       The control's datatype.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Inference.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Control);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Control other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Kind != other.Kind) return false;
          if(!int32FalseTrue_.Equals(other.int32FalseTrue_)) return false;
          if(!fp32FalseTrue_.Equals(other.fp32FalseTrue_)) return false;
          if(!boolFalseTrue_.Equals(other.boolFalseTrue_)) return false;
          if (DataType != other.DataType) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Kind != global::Inference.ModelSequenceBatching.Types.Control.Types.Kind.ControlSequenceStart) hash ^= Kind.GetHashCode();
          hash ^= int32FalseTrue_.GetHashCode();
          hash ^= fp32FalseTrue_.GetHashCode();
          hash ^= boolFalseTrue_.GetHashCode();
          if (DataType != global::Inference.DataType.TypeInvalid) hash ^= DataType.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Kind != global::Inference.ModelSequenceBatching.Types.Control.Types.Kind.ControlSequenceStart) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Kind);
          }
          int32FalseTrue_.WriteTo(output, _repeated_int32FalseTrue_codec);
          fp32FalseTrue_.WriteTo(output, _repeated_fp32FalseTrue_codec);
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(32);
            output.WriteEnum((int) DataType);
          }
          boolFalseTrue_.WriteTo(output, _repeated_boolFalseTrue_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Kind != global::Inference.ModelSequenceBatching.Types.Control.Types.Kind.ControlSequenceStart) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Kind);
          }
          int32FalseTrue_.WriteTo(ref output, _repeated_int32FalseTrue_codec);
          fp32FalseTrue_.WriteTo(ref output, _repeated_fp32FalseTrue_codec);
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(32);
            output.WriteEnum((int) DataType);
          }
          boolFalseTrue_.WriteTo(ref output, _repeated_boolFalseTrue_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Kind != global::Inference.ModelSequenceBatching.Types.Control.Types.Kind.ControlSequenceStart) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
          }
          size += int32FalseTrue_.CalculateSize(_repeated_int32FalseTrue_codec);
          size += fp32FalseTrue_.CalculateSize(_repeated_fp32FalseTrue_codec);
          size += boolFalseTrue_.CalculateSize(_repeated_boolFalseTrue_codec);
          if (DataType != global::Inference.DataType.TypeInvalid) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Control other) {
          if (other == null) {
            return;
          }
          if (other.Kind != global::Inference.ModelSequenceBatching.Types.Control.Types.Kind.ControlSequenceStart) {
            Kind = other.Kind;
          }
          int32FalseTrue_.Add(other.int32FalseTrue_);
          fp32FalseTrue_.Add(other.fp32FalseTrue_);
          boolFalseTrue_.Add(other.boolFalseTrue_);
          if (other.DataType != global::Inference.DataType.TypeInvalid) {
            DataType = other.DataType;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Kind = (global::Inference.ModelSequenceBatching.Types.Control.Types.Kind) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                int32FalseTrue_.AddEntriesFrom(input, _repeated_int32FalseTrue_codec);
                break;
              }
              case 26:
              case 29: {
                fp32FalseTrue_.AddEntriesFrom(input, _repeated_fp32FalseTrue_codec);
                break;
              }
              case 32: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 42:
              case 40: {
                boolFalseTrue_.AddEntriesFrom(input, _repeated_boolFalseTrue_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Kind = (global::Inference.ModelSequenceBatching.Types.Control.Types.Kind) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                int32FalseTrue_.AddEntriesFrom(ref input, _repeated_int32FalseTrue_codec);
                break;
              }
              case 26:
              case 29: {
                fp32FalseTrue_.AddEntriesFrom(ref input, _repeated_fp32FalseTrue_codec);
                break;
              }
              case 32: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 42:
              case 40: {
                boolFalseTrue_.AddEntriesFrom(ref input, _repeated_boolFalseTrue_codec);
                break;
              }
            }
          }
        }
        #endif

        #region Nested types
        /// <summary>Container for nested types declared in the Control message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static partial class Types {
          /// <summary>
          ///@@
          ///@@    .. cpp:enum:: Kind
          ///@@
          ///@@       The kind of the control.
          ///@@
          /// </summary>
          public enum Kind {
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_START = 0
            ///@@
            ///@@         A new sequence is/is-not starting. If true a sequence is
            ///@@         starting, if false a sequence is continuing. Must
            ///@@         specify either int32_false_true, fp32_false_true or
            ///@@         bool_false_true for this control. This control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_START")] ControlSequenceStart = 0,
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_READY = 1
            ///@@
            ///@@         A sequence is/is-not ready for inference. If true the
            ///@@         input tensor data is valid and should be used. If false
            ///@@         the input tensor data is invalid and inferencing should
            ///@@         be "skipped". Must specify either int32_false_true,
            ///@@         fp32_false_true or bool_false_true for this control. This
            ///@@         control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_READY")] ControlSequenceReady = 1,
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_END = 2
            ///@@
            ///@@         A sequence is/is-not ending. If true a sequence is
            ///@@         ending, if false a sequence is continuing. Must specify
            ///@@         either int32_false_true, fp32_false_true or bool_false_true
            ///@@         for this control. This control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_END")] ControlSequenceEnd = 2,
            /// <summary>
            ///@@      .. cpp:enumerator:: Kind::CONTROL_SEQUENCE_CORRID = 3
            ///@@
            ///@@         The correlation ID of the sequence. The correlation ID
            ///@@         is an uint64_t value that is communicated in whole or
            ///@@         in part by the tensor. The tensor's datatype must be
            ///@@         specified by data_type and must be TYPE_UINT64, TYPE_INT64,
            ///@@         TYPE_UINT32 or TYPE_INT32. If a 32-bit datatype is specified
            ///@@         the correlation ID will be truncated to the low-order 32
            ///@@         bits. This control is optional.
            ///@@
            /// </summary>
            [pbr::OriginalName("CONTROL_SEQUENCE_CORRID")] ControlSequenceCorrid = 3,
          }

        }
        #endregion

      }

      /// <summary>
      ///@@  .. cpp:var:: message ControlInput
      ///@@
      ///@@     The sequence control values to communicate by a model input.
      ///@@
      /// </summary>
      public sealed partial class ControlInput : pb::IMessage<ControlInput>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ControlInput> _parser = new pb::MessageParser<ControlInput>(() => new ControlInput());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ControlInput> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelSequenceBatching.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ControlInput() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ControlInput(ControlInput other) : this() {
          name_ = other.name_;
          control_ = other.control_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ControlInput Clone() {
          return new ControlInput(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        ///@@    .. cpp:var:: string name
        ///@@
        ///@@       The name of the model input.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "control" field.</summary>
        public const int ControlFieldNumber = 2;
        private static readonly pb::FieldCodec<global::Inference.ModelSequenceBatching.Types.Control> _repeated_control_codec
            = pb::FieldCodec.ForMessage(18, global::Inference.ModelSequenceBatching.Types.Control.Parser);
        private readonly pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.Control> control_ = new pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.Control>();
        /// <summary>
        ///@@    .. cpp:var:: Control control (repeated)
        ///@@
        ///@@       The control value(s) that should be communicated to the
        ///@@       model using this model input.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.Control> Control {
          get { return control_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ControlInput);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ControlInput other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if(!control_.Equals(other.control_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= control_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          control_.WriteTo(output, _repeated_control_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          control_.WriteTo(ref output, _repeated_control_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += control_.CalculateSize(_repeated_control_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ControlInput other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          control_.Add(other.control_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                control_.AddEntriesFrom(input, _repeated_control_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                control_.AddEntriesFrom(ref input, _repeated_control_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message InitialState
      ///@@
      ///@@     Settings used to initialize data for implicit state.
      ///@@
      /// </summary>
      public sealed partial class InitialState : pb::IMessage<InitialState>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<InitialState> _parser = new pb::MessageParser<InitialState>(() => new InitialState());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<InitialState> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelSequenceBatching.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitialState() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitialState(InitialState other) : this() {
          dataType_ = other.dataType_;
          dims_ = other.dims_.Clone();
          name_ = other.name_;
          switch (other.StateDataCase) {
            case StateDataOneofCase.ZeroData:
              ZeroData = other.ZeroData;
              break;
            case StateDataOneofCase.DataFile:
              DataFile = other.DataFile;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InitialState Clone() {
          return new InitialState(this);
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 1;
        private global::Inference.DataType dataType_ = global::Inference.DataType.TypeInvalid;
        /// <summary>
        ///@@      .. cpp:var:: DataType data_type
        ///@@
        ///@@         The data-type of the state.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Inference.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 2;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(18);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        /// <summary>
        ///@@      .. cpp:var:: int64 dims (repeated)
        ///@@
        ///@@         The shape of the state tensor, not including the batch dimension.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<long> Dims {
          get { return dims_; }
        }

        /// <summary>Field number for the "zero_data" field.</summary>
        public const int ZeroDataFieldNumber = 3;
        /// <summary>
        ///@@
        ///@@      .. cpp:var:: bool zero_data
        ///@@
        ///@@         The identifier for using zeros as initial state data.
        ///@@         Note that the value of 'zero_data' will not be checked,
        ///@@         instead, zero data will be used as long as the field is set.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ZeroData {
          get { return stateDataCase_ == StateDataOneofCase.ZeroData ? (bool) stateData_ : false; }
          set {
            stateData_ = value;
            stateDataCase_ = StateDataOneofCase.ZeroData;
          }
        }

        /// <summary>Field number for the "data_file" field.</summary>
        public const int DataFileFieldNumber = 4;
        /// <summary>
        ///@@      .. cpp:var:: string data_file
        ///@@
        ///@@         The file whose content will be used as the initial data for
        ///@@         the state in row-major order. The file must be provided in
        ///@@         sub-directory 'initial_state' under the model directory.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string DataFile {
          get { return stateDataCase_ == StateDataOneofCase.DataFile ? (string) stateData_ : ""; }
          set {
            stateData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            stateDataCase_ = StateDataOneofCase.DataFile;
          }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 5;
        private string name_ = "";
        /// <summary>
        ///@@  .. cpp:var:: string name
        ///@@
        ///@@     The name of the state initialization.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        private object stateData_;
        /// <summary>Enum of possible cases for the "state_data" oneof.</summary>
        public enum StateDataOneofCase {
          None = 0,
          ZeroData = 3,
          DataFile = 4,
        }
        private StateDataOneofCase stateDataCase_ = StateDataOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StateDataOneofCase StateDataCase {
          get { return stateDataCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearStateData() {
          stateDataCase_ = StateDataOneofCase.None;
          stateData_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as InitialState);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(InitialState other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DataType != other.DataType) return false;
          if(!dims_.Equals(other.dims_)) return false;
          if (ZeroData != other.ZeroData) return false;
          if (DataFile != other.DataFile) return false;
          if (Name != other.Name) return false;
          if (StateDataCase != other.StateDataCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (DataType != global::Inference.DataType.TypeInvalid) hash ^= DataType.GetHashCode();
          hash ^= dims_.GetHashCode();
          if (stateDataCase_ == StateDataOneofCase.ZeroData) hash ^= ZeroData.GetHashCode();
          if (stateDataCase_ == StateDataOneofCase.DataFile) hash ^= DataFile.GetHashCode();
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= (int) stateDataCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(8);
            output.WriteEnum((int) DataType);
          }
          dims_.WriteTo(output, _repeated_dims_codec);
          if (stateDataCase_ == StateDataOneofCase.ZeroData) {
            output.WriteRawTag(24);
            output.WriteBool(ZeroData);
          }
          if (stateDataCase_ == StateDataOneofCase.DataFile) {
            output.WriteRawTag(34);
            output.WriteString(DataFile);
          }
          if (Name.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(Name);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(8);
            output.WriteEnum((int) DataType);
          }
          dims_.WriteTo(ref output, _repeated_dims_codec);
          if (stateDataCase_ == StateDataOneofCase.ZeroData) {
            output.WriteRawTag(24);
            output.WriteBool(ZeroData);
          }
          if (stateDataCase_ == StateDataOneofCase.DataFile) {
            output.WriteRawTag(34);
            output.WriteString(DataFile);
          }
          if (Name.Length != 0) {
            output.WriteRawTag(42);
            output.WriteString(Name);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (DataType != global::Inference.DataType.TypeInvalid) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          size += dims_.CalculateSize(_repeated_dims_codec);
          if (stateDataCase_ == StateDataOneofCase.ZeroData) {
            size += 1 + 1;
          }
          if (stateDataCase_ == StateDataOneofCase.DataFile) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(DataFile);
          }
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(InitialState other) {
          if (other == null) {
            return;
          }
          if (other.DataType != global::Inference.DataType.TypeInvalid) {
            DataType = other.DataType;
          }
          dims_.Add(other.dims_);
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          switch (other.StateDataCase) {
            case StateDataOneofCase.ZeroData:
              ZeroData = other.ZeroData;
              break;
            case StateDataOneofCase.DataFile:
              DataFile = other.DataFile;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                dims_.AddEntriesFrom(input, _repeated_dims_codec);
                break;
              }
              case 24: {
                ZeroData = input.ReadBool();
                break;
              }
              case 34: {
                DataFile = input.ReadString();
                break;
              }
              case 42: {
                Name = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
                break;
              }
              case 24: {
                ZeroData = input.ReadBool();
                break;
              }
              case 34: {
                DataFile = input.ReadString();
                break;
              }
              case 42: {
                Name = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///@@  .. cpp:var:: message State
      ///@@
      ///@@     An input / output pair of tensors that carry state for the sequence.
      ///@@
      /// </summary>
      public sealed partial class State : pb::IMessage<State>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<State> _parser = new pb::MessageParser<State>(() => new State());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<State> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelSequenceBatching.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public State() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public State(State other) : this() {
          inputName_ = other.inputName_;
          outputName_ = other.outputName_;
          dataType_ = other.dataType_;
          dims_ = other.dims_.Clone();
          initialState_ = other.initialState_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public State Clone() {
          return new State(this);
        }

        /// <summary>Field number for the "input_name" field.</summary>
        public const int InputNameFieldNumber = 1;
        private string inputName_ = "";
        /// <summary>
        ///@@    .. cpp:var:: string input_name
        ///@@
        ///@@       The name of the model state input.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string InputName {
          get { return inputName_; }
          set {
            inputName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "output_name" field.</summary>
        public const int OutputNameFieldNumber = 2;
        private string outputName_ = "";
        /// <summary>
        ///@@    .. cpp:var:: string output_name
        ///@@
        ///@@       The name of the model state output.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string OutputName {
          get { return outputName_; }
          set {
            outputName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 3;
        private global::Inference.DataType dataType_ = global::Inference.DataType.TypeInvalid;
        /// <summary>
        ///@@    .. cpp:var:: DataType data_type
        ///@@
        ///@@       The data-type of the state.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Inference.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 4;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(34);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        /// <summary>
        ///@@    .. cpp:var:: int64 dim (repeated)
        ///@@
        ///@@       The dimension.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<long> Dims {
          get { return dims_; }
        }

        /// <summary>Field number for the "initial_state" field.</summary>
        public const int InitialStateFieldNumber = 5;
        private static readonly pb::FieldCodec<global::Inference.ModelSequenceBatching.Types.InitialState> _repeated_initialState_codec
            = pb::FieldCodec.ForMessage(42, global::Inference.ModelSequenceBatching.Types.InitialState.Parser);
        private readonly pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.InitialState> initialState_ = new pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.InitialState>();
        /// <summary>
        ///@@  .. cpp:var:: InitialState initial_state (repeated)
        ///@@
        ///@@     The optional field to specify the initial state for the model.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<global::Inference.ModelSequenceBatching.Types.InitialState> InitialState {
          get { return initialState_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as State);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(State other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (InputName != other.InputName) return false;
          if (OutputName != other.OutputName) return false;
          if (DataType != other.DataType) return false;
          if(!dims_.Equals(other.dims_)) return false;
          if(!initialState_.Equals(other.initialState_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (InputName.Length != 0) hash ^= InputName.GetHashCode();
          if (OutputName.Length != 0) hash ^= OutputName.GetHashCode();
          if (DataType != global::Inference.DataType.TypeInvalid) hash ^= DataType.GetHashCode();
          hash ^= dims_.GetHashCode();
          hash ^= initialState_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (InputName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(InputName);
          }
          if (OutputName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(OutputName);
          }
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(24);
            output.WriteEnum((int) DataType);
          }
          dims_.WriteTo(output, _repeated_dims_codec);
          initialState_.WriteTo(output, _repeated_initialState_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (InputName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(InputName);
          }
          if (OutputName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(OutputName);
          }
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(24);
            output.WriteEnum((int) DataType);
          }
          dims_.WriteTo(ref output, _repeated_dims_codec);
          initialState_.WriteTo(ref output, _repeated_initialState_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (InputName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(InputName);
          }
          if (OutputName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(OutputName);
          }
          if (DataType != global::Inference.DataType.TypeInvalid) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          size += dims_.CalculateSize(_repeated_dims_codec);
          size += initialState_.CalculateSize(_repeated_initialState_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(State other) {
          if (other == null) {
            return;
          }
          if (other.InputName.Length != 0) {
            InputName = other.InputName;
          }
          if (other.OutputName.Length != 0) {
            OutputName = other.OutputName;
          }
          if (other.DataType != global::Inference.DataType.TypeInvalid) {
            DataType = other.DataType;
          }
          dims_.Add(other.dims_);
          initialState_.Add(other.initialState_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                InputName = input.ReadString();
                break;
              }
              case 18: {
                OutputName = input.ReadString();
                break;
              }
              case 24: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 34:
              case 32: {
                dims_.AddEntriesFrom(input, _repeated_dims_codec);
                break;
              }
              case 42: {
                initialState_.AddEntriesFrom(input, _repeated_initialState_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                InputName = input.ReadString();
                break;
              }
              case 18: {
                OutputName = input.ReadString();
                break;
              }
              case 24: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 34:
              case 32: {
                dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
                break;
              }
              case 42: {
                initialState_.AddEntriesFrom(ref input, _repeated_initialState_codec);
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///@@  .. cpp:var:: message StrategyDirect
      ///@@
      ///@@     The sequence batcher uses a specific, unique batch
      ///@@     slot for each sequence. All inference requests in a
      ///@@     sequence are directed to the same batch slot in the same
      ///@@     model instance over the lifetime of the sequence. This
      ///@@     is the default strategy.
      ///@@
      /// </summary>
      public sealed partial class StrategyDirect : pb::IMessage<StrategyDirect>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<StrategyDirect> _parser = new pb::MessageParser<StrategyDirect>(() => new StrategyDirect());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<StrategyDirect> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelSequenceBatching.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StrategyDirect() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StrategyDirect(StrategyDirect other) : this() {
          maxQueueDelayMicroseconds_ = other.maxQueueDelayMicroseconds_;
          minimumSlotUtilization_ = other.minimumSlotUtilization_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StrategyDirect Clone() {
          return new StrategyDirect(this);
        }

        /// <summary>Field number for the "max_queue_delay_microseconds" field.</summary>
        public const int MaxQueueDelayMicrosecondsFieldNumber = 1;
        private ulong maxQueueDelayMicroseconds_;
        /// <summary>
        ///@@    .. cpp:var:: uint64 max_queue_delay_microseconds
        ///@@
        ///@@       The maximum time, in microseconds, a candidate request
        ///@@       will be delayed in the sequence batch scheduling queue to
        ///@@       wait for additional requests for batching. Default is 0.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong MaxQueueDelayMicroseconds {
          get { return maxQueueDelayMicroseconds_; }
          set {
            maxQueueDelayMicroseconds_ = value;
          }
        }

        /// <summary>Field number for the "minimum_slot_utilization" field.</summary>
        public const int MinimumSlotUtilizationFieldNumber = 2;
        private float minimumSlotUtilization_;
        /// <summary>
        ///@@    .. cpp:var:: float minimum_slot_utilization
        ///@@
        ///@@       The minimum slot utilization that must be satisfied to
        ///@@       execute the batch before 'max_queue_delay_microseconds' expires.
        ///@@       For example, a value of 0.5 indicates that the batch should be
        ///@@       executed as soon as 50% or more of the slots are ready even if
        ///@@       the 'max_queue_delay_microseconds' timeout has not expired.
        ///@@       The default is 0.0, indicating that a batch will be executed
        ///@@       before 'max_queue_delay_microseconds' timeout expires if at least
        ///@@       one batch slot is ready. 'max_queue_delay_microseconds' will be
        ///@@       ignored unless minimum_slot_utilization is set to a non-zero
        ///@@       value.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public float MinimumSlotUtilization {
          get { return minimumSlotUtilization_; }
          set {
            minimumSlotUtilization_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as StrategyDirect);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(StrategyDirect other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaxQueueDelayMicroseconds != other.MaxQueueDelayMicroseconds) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinimumSlotUtilization, other.MinimumSlotUtilization)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (MaxQueueDelayMicroseconds != 0UL) hash ^= MaxQueueDelayMicroseconds.GetHashCode();
          if (MinimumSlotUtilization != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinimumSlotUtilization);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (MaxQueueDelayMicroseconds != 0UL) {
            output.WriteRawTag(8);
            output.WriteUInt64(MaxQueueDelayMicroseconds);
          }
          if (MinimumSlotUtilization != 0F) {
            output.WriteRawTag(21);
            output.WriteFloat(MinimumSlotUtilization);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (MaxQueueDelayMicroseconds != 0UL) {
            output.WriteRawTag(8);
            output.WriteUInt64(MaxQueueDelayMicroseconds);
          }
          if (MinimumSlotUtilization != 0F) {
            output.WriteRawTag(21);
            output.WriteFloat(MinimumSlotUtilization);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (MaxQueueDelayMicroseconds != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxQueueDelayMicroseconds);
          }
          if (MinimumSlotUtilization != 0F) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(StrategyDirect other) {
          if (other == null) {
            return;
          }
          if (other.MaxQueueDelayMicroseconds != 0UL) {
            MaxQueueDelayMicroseconds = other.MaxQueueDelayMicroseconds;
          }
          if (other.MinimumSlotUtilization != 0F) {
            MinimumSlotUtilization = other.MinimumSlotUtilization;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaxQueueDelayMicroseconds = input.ReadUInt64();
                break;
              }
              case 21: {
                MinimumSlotUtilization = input.ReadFloat();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                MaxQueueDelayMicroseconds = input.ReadUInt64();
                break;
              }
              case 21: {
                MinimumSlotUtilization = input.ReadFloat();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      ///@@  .. cpp:var:: message StrategyOldest
      ///@@
      ///@@     The sequence batcher maintains up to 'max_candidate_sequences'
      ///@@     candidate sequences. 'max_candidate_sequences' can be greater
      ///@@     than the model's 'max_batch_size'. For inferencing the batcher
      ///@@     chooses from the candidate sequences up to 'max_batch_size'
      ///@@     inference requests. Requests are chosen in an oldest-first
      ///@@     manner across all candidate sequences. A given sequence is
      ///@@     not guaranteed to be assigned to the same batch slot for
      ///@@     all inference requests of that sequence.
      ///@@
      /// </summary>
      public sealed partial class StrategyOldest : pb::IMessage<StrategyOldest>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<StrategyOldest> _parser = new pb::MessageParser<StrategyOldest>(() => new StrategyOldest());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<StrategyOldest> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelSequenceBatching.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StrategyOldest() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StrategyOldest(StrategyOldest other) : this() {
          maxCandidateSequences_ = other.maxCandidateSequences_;
          preferredBatchSize_ = other.preferredBatchSize_.Clone();
          maxQueueDelayMicroseconds_ = other.maxQueueDelayMicroseconds_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public StrategyOldest Clone() {
          return new StrategyOldest(this);
        }

        /// <summary>Field number for the "max_candidate_sequences" field.</summary>
        public const int MaxCandidateSequencesFieldNumber = 1;
        private int maxCandidateSequences_;
        /// <summary>
        ///@@    .. cpp:var:: int32 max_candidate_sequences
        ///@@
        ///@@       Maximum number of candidate sequences that the batcher
        ///@@       maintains. Excess seqences are kept in an ordered backlog
        ///@@       and become candidates when existing candidate sequences
        ///@@       complete.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int MaxCandidateSequences {
          get { return maxCandidateSequences_; }
          set {
            maxCandidateSequences_ = value;
          }
        }

        /// <summary>Field number for the "preferred_batch_size" field.</summary>
        public const int PreferredBatchSizeFieldNumber = 2;
        private static readonly pb::FieldCodec<int> _repeated_preferredBatchSize_codec
            = pb::FieldCodec.ForInt32(18);
        private readonly pbc::RepeatedField<int> preferredBatchSize_ = new pbc::RepeatedField<int>();
        /// <summary>
        ///@@    .. cpp:var:: int32 preferred_batch_size (repeated)
        ///@@
        ///@@       Preferred batch sizes for dynamic batching of candidate
        ///@@       sequences. If a batch of one of these sizes can be formed
        ///@@       it will be executed immediately. If not specified a
        ///@@       preferred batch size will be chosen automatically
        ///@@       based on model and GPU characteristics.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<int> PreferredBatchSize {
          get { return preferredBatchSize_; }
        }

        /// <summary>Field number for the "max_queue_delay_microseconds" field.</summary>
        public const int MaxQueueDelayMicrosecondsFieldNumber = 3;
        private ulong maxQueueDelayMicroseconds_;
        /// <summary>
        ///@@    .. cpp:var:: uint64 max_queue_delay_microseconds
        ///@@
        ///@@       The maximum time, in microseconds, a candidate request
        ///@@       will be delayed in the dynamic batch scheduling queue to
        ///@@       wait for additional requests for batching. Default is 0.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ulong MaxQueueDelayMicroseconds {
          get { return maxQueueDelayMicroseconds_; }
          set {
            maxQueueDelayMicroseconds_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as StrategyOldest);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(StrategyOldest other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaxCandidateSequences != other.MaxCandidateSequences) return false;
          if(!preferredBatchSize_.Equals(other.preferredBatchSize_)) return false;
          if (MaxQueueDelayMicroseconds != other.MaxQueueDelayMicroseconds) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (MaxCandidateSequences != 0) hash ^= MaxCandidateSequences.GetHashCode();
          hash ^= preferredBatchSize_.GetHashCode();
          if (MaxQueueDelayMicroseconds != 0UL) hash ^= MaxQueueDelayMicroseconds.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (MaxCandidateSequences != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(MaxCandidateSequences);
          }
          preferredBatchSize_.WriteTo(output, _repeated_preferredBatchSize_codec);
          if (MaxQueueDelayMicroseconds != 0UL) {
            output.WriteRawTag(24);
            output.WriteUInt64(MaxQueueDelayMicroseconds);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (MaxCandidateSequences != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(MaxCandidateSequences);
          }
          preferredBatchSize_.WriteTo(ref output, _repeated_preferredBatchSize_codec);
          if (MaxQueueDelayMicroseconds != 0UL) {
            output.WriteRawTag(24);
            output.WriteUInt64(MaxQueueDelayMicroseconds);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (MaxCandidateSequences != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxCandidateSequences);
          }
          size += preferredBatchSize_.CalculateSize(_repeated_preferredBatchSize_codec);
          if (MaxQueueDelayMicroseconds != 0UL) {
            size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MaxQueueDelayMicroseconds);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(StrategyOldest other) {
          if (other == null) {
            return;
          }
          if (other.MaxCandidateSequences != 0) {
            MaxCandidateSequences = other.MaxCandidateSequences;
          }
          preferredBatchSize_.Add(other.preferredBatchSize_);
          if (other.MaxQueueDelayMicroseconds != 0UL) {
            MaxQueueDelayMicroseconds = other.MaxQueueDelayMicroseconds;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaxCandidateSequences = input.ReadInt32();
                break;
              }
              case 18:
              case 16: {
                preferredBatchSize_.AddEntriesFrom(input, _repeated_preferredBatchSize_codec);
                break;
              }
              case 24: {
                MaxQueueDelayMicroseconds = input.ReadUInt64();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                MaxCandidateSequences = input.ReadInt32();
                break;
              }
              case 18:
              case 16: {
                preferredBatchSize_.AddEntriesFrom(ref input, _repeated_preferredBatchSize_codec);
                break;
              }
              case 24: {
                MaxQueueDelayMicroseconds = input.ReadUInt64();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelEnsembling
  ///@@
  ///@@   Model ensembling configuration. These settings specify the models that
  ///@@   compose the ensemble and how data flows between the models.
  ///@@
  /// </summary>
  public sealed partial class ModelEnsembling : pb::IMessage<ModelEnsembling>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelEnsembling> _parser = new pb::MessageParser<ModelEnsembling>(() => new ModelEnsembling());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelEnsembling> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelEnsembling() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelEnsembling(ModelEnsembling other) : this() {
      step_ = other.step_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelEnsembling Clone() {
      return new ModelEnsembling(this);
    }

    /// <summary>Field number for the "step" field.</summary>
    public const int StepFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Inference.ModelEnsembling.Types.Step> _repeated_step_codec
        = pb::FieldCodec.ForMessage(10, global::Inference.ModelEnsembling.Types.Step.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelEnsembling.Types.Step> step_ = new pbc::RepeatedField<global::Inference.ModelEnsembling.Types.Step>();
    /// <summary>
    ///@@  .. cpp:var:: Step step (repeated)
    ///@@
    ///@@     The models and the input / output mappings used within the ensemble.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelEnsembling.Types.Step> Step {
      get { return step_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelEnsembling);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelEnsembling other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!step_.Equals(other.step_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= step_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      step_.WriteTo(output, _repeated_step_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      step_.WriteTo(ref output, _repeated_step_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += step_.CalculateSize(_repeated_step_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelEnsembling other) {
      if (other == null) {
        return;
      }
      step_.Add(other.step_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            step_.AddEntriesFrom(input, _repeated_step_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            step_.AddEntriesFrom(ref input, _repeated_step_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelEnsembling message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@  .. cpp:var:: message Step
      ///@@
      ///@@     Each step specifies a model included in the ensemble,
      ///@@     maps ensemble tensor names to the model input tensors,
      ///@@     and maps model output tensors to ensemble tensor names
      ///@@
      /// </summary>
      public sealed partial class Step : pb::IMessage<Step>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Step> _parser = new pb::MessageParser<Step>(() => new Step());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Step> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelEnsembling.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Step() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Step(Step other) : this() {
          modelName_ = other.modelName_;
          modelVersion_ = other.modelVersion_;
          inputMap_ = other.inputMap_.Clone();
          outputMap_ = other.outputMap_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Step Clone() {
          return new Step(this);
        }

        /// <summary>Field number for the "model_name" field.</summary>
        public const int ModelNameFieldNumber = 1;
        private string modelName_ = "";
        /// <summary>
        ///@@  .. cpp:var:: string model_name
        ///@@
        ///@@     The name of the model to execute for this step of the ensemble.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string ModelName {
          get { return modelName_; }
          set {
            modelName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "model_version" field.</summary>
        public const int ModelVersionFieldNumber = 2;
        private long modelVersion_;
        /// <summary>
        ///@@  .. cpp:var:: int64 model_version
        ///@@
        ///@@     The version of the model to use for inference. If -1
        ///@@     the latest/most-recent version of the model is used.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public long ModelVersion {
          get { return modelVersion_; }
          set {
            modelVersion_ = value;
          }
        }

        /// <summary>Field number for the "input_map" field.</summary>
        public const int InputMapFieldNumber = 3;
        private static readonly pbc::MapField<string, string>.Codec _map_inputMap_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 26);
        private readonly pbc::MapField<string, string> inputMap_ = new pbc::MapField<string, string>();
        /// <summary>
        ///@@  .. cpp:var:: map&lt;string,string> input_map
        ///@@
        ///@@     Map from name of an input tensor on this step's model to ensemble
        ///@@     tensor name. The ensemble tensor must have the same data type and
        ///@@     shape as the model input. Each model input must be assigned to
        ///@@     one ensemble tensor, but the same ensemble tensor can be assigned
        ///@@     to multiple model inputs.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, string> InputMap {
          get { return inputMap_; }
        }

        /// <summary>Field number for the "output_map" field.</summary>
        public const int OutputMapFieldNumber = 4;
        private static readonly pbc::MapField<string, string>.Codec _map_outputMap_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 34);
        private readonly pbc::MapField<string, string> outputMap_ = new pbc::MapField<string, string>();
        /// <summary>
        ///@@  .. cpp:var:: map&lt;string,string> output_map
        ///@@
        ///@@     Map from name of an output tensor on this step's model to ensemble
        ///@@     tensor name. The data type and shape of the ensemble tensor will
        ///@@     be inferred from the model output. It is optional to assign all
        ///@@     model outputs to ensemble tensors. One ensemble tensor name
        ///@@     can appear in an output map only once.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, string> OutputMap {
          get { return outputMap_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Step);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Step other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ModelName != other.ModelName) return false;
          if (ModelVersion != other.ModelVersion) return false;
          if (!InputMap.Equals(other.InputMap)) return false;
          if (!OutputMap.Equals(other.OutputMap)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (ModelName.Length != 0) hash ^= ModelName.GetHashCode();
          if (ModelVersion != 0L) hash ^= ModelVersion.GetHashCode();
          hash ^= InputMap.GetHashCode();
          hash ^= OutputMap.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (ModelName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(ModelName);
          }
          if (ModelVersion != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(ModelVersion);
          }
          inputMap_.WriteTo(output, _map_inputMap_codec);
          outputMap_.WriteTo(output, _map_outputMap_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (ModelName.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(ModelName);
          }
          if (ModelVersion != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(ModelVersion);
          }
          inputMap_.WriteTo(ref output, _map_inputMap_codec);
          outputMap_.WriteTo(ref output, _map_outputMap_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (ModelName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelName);
          }
          if (ModelVersion != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(ModelVersion);
          }
          size += inputMap_.CalculateSize(_map_inputMap_codec);
          size += outputMap_.CalculateSize(_map_outputMap_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Step other) {
          if (other == null) {
            return;
          }
          if (other.ModelName.Length != 0) {
            ModelName = other.ModelName;
          }
          if (other.ModelVersion != 0L) {
            ModelVersion = other.ModelVersion;
          }
          inputMap_.Add(other.inputMap_);
          outputMap_.Add(other.outputMap_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                ModelName = input.ReadString();
                break;
              }
              case 16: {
                ModelVersion = input.ReadInt64();
                break;
              }
              case 26: {
                inputMap_.AddEntriesFrom(input, _map_inputMap_codec);
                break;
              }
              case 34: {
                outputMap_.AddEntriesFrom(input, _map_outputMap_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                ModelName = input.ReadString();
                break;
              }
              case 16: {
                ModelVersion = input.ReadInt64();
                break;
              }
              case 26: {
                inputMap_.AddEntriesFrom(ref input, _map_inputMap_codec);
                break;
              }
              case 34: {
                outputMap_.AddEntriesFrom(ref input, _map_outputMap_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelParameter
  ///@@
  ///@@   A model parameter.
  ///@@
  /// </summary>
  public sealed partial class ModelParameter : pb::IMessage<ModelParameter>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelParameter> _parser = new pb::MessageParser<ModelParameter>(() => new ModelParameter());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelParameter> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelParameter() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelParameter(ModelParameter other) : this() {
      stringValue_ = other.stringValue_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelParameter Clone() {
      return new ModelParameter(this);
    }

    /// <summary>Field number for the "string_value" field.</summary>
    public const int StringValueFieldNumber = 1;
    private string stringValue_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string string_value
    ///@@
    ///@@     The string value of the parameter.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string StringValue {
      get { return stringValue_; }
      set {
        stringValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelParameter);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelParameter other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StringValue != other.StringValue) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (StringValue.Length != 0) hash ^= StringValue.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (StringValue.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StringValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (StringValue.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(StringValue);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (StringValue.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(StringValue);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelParameter other) {
      if (other == null) {
        return;
      }
      if (other.StringValue.Length != 0) {
        StringValue = other.StringValue;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            StringValue = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            StringValue = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelWarmup
  ///@@
  ///@@   Settings used to construct the request sample for model warmup.
  ///@@
  /// </summary>
  public sealed partial class ModelWarmup : pb::IMessage<ModelWarmup>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelWarmup> _parser = new pb::MessageParser<ModelWarmup>(() => new ModelWarmup());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelWarmup> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelWarmup() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelWarmup(ModelWarmup other) : this() {
      name_ = other.name_;
      batchSize_ = other.batchSize_;
      inputs_ = other.inputs_.Clone();
      count_ = other.count_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelWarmup Clone() {
      return new ModelWarmup(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the request sample.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "batch_size" field.</summary>
    public const int BatchSizeFieldNumber = 2;
    private uint batchSize_;
    /// <summary>
    ///@@  .. cpp:var:: uint32 batch_size
    ///@@
    ///@@     The batch size of the inference request. This must be >= 1. For
    ///@@     models that don't support batching, batch_size must be 1. If
    ///@@     batch_size > 1, the 'inputs' specified below will be duplicated to
    ///@@     match the batch size requested.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint BatchSize {
      get { return batchSize_; }
      set {
        batchSize_ = value;
      }
    }

    /// <summary>Field number for the "inputs" field.</summary>
    public const int InputsFieldNumber = 3;
    private static readonly pbc::MapField<string, global::Inference.ModelWarmup.Types.Input>.Codec _map_inputs_codec
        = new pbc::MapField<string, global::Inference.ModelWarmup.Types.Input>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Inference.ModelWarmup.Types.Input.Parser), 26);
    private readonly pbc::MapField<string, global::Inference.ModelWarmup.Types.Input> inputs_ = new pbc::MapField<string, global::Inference.ModelWarmup.Types.Input>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string, Input> inputs
    ///@@
    ///@@     The warmup meta data associated with every model input, including
    ///@@     control tensors.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Inference.ModelWarmup.Types.Input> Inputs {
      get { return inputs_; }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 4;
    private uint count_;
    /// <summary>
    ///@@  .. cpp:var:: uint32 count
    ///@@
    ///@@     The number of iterations that this warmup sample will be executed.
    ///@@     For example, if this field is set to 2, 2 model executions using this
    ///@@     sample will be scheduled for warmup. Default value is 0 which
    ///@@     indicates that this sample will be used only once.
    ///@@     Note that for sequence model, 'count' may not work well
    ///@@     because the model often expect a valid sequence of requests which
    ///@@     should be represented by a series of warmup samples. 'count > 1'
    ///@@     essentially "resends" one of the sample, which may invalidate the
    ///@@     sequence and result in unexpected warmup failure.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelWarmup);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelWarmup other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (BatchSize != other.BatchSize) return false;
      if (!Inputs.Equals(other.Inputs)) return false;
      if (Count != other.Count) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (BatchSize != 0) hash ^= BatchSize.GetHashCode();
      hash ^= Inputs.GetHashCode();
      if (Count != 0) hash ^= Count.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (BatchSize != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(BatchSize);
      }
      inputs_.WriteTo(output, _map_inputs_codec);
      if (Count != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Count);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (BatchSize != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(BatchSize);
      }
      inputs_.WriteTo(ref output, _map_inputs_codec);
      if (Count != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Count);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (BatchSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(BatchSize);
      }
      size += inputs_.CalculateSize(_map_inputs_codec);
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Count);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelWarmup other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.BatchSize != 0) {
        BatchSize = other.BatchSize;
      }
      inputs_.Add(other.inputs_);
      if (other.Count != 0) {
        Count = other.Count;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            BatchSize = input.ReadUInt32();
            break;
          }
          case 26: {
            inputs_.AddEntriesFrom(input, _map_inputs_codec);
            break;
          }
          case 32: {
            Count = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            BatchSize = input.ReadUInt32();
            break;
          }
          case 26: {
            inputs_.AddEntriesFrom(ref input, _map_inputs_codec);
            break;
          }
          case 32: {
            Count = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelWarmup message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message Input
      ///@@
      ///@@     Meta data associated with an input.
      ///@@
      /// </summary>
      public sealed partial class Input : pb::IMessage<Input>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Input> _parser = new pb::MessageParser<Input>(() => new Input());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Input> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelWarmup.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Input() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Input(Input other) : this() {
          dataType_ = other.dataType_;
          dims_ = other.dims_.Clone();
          switch (other.InputDataTypeCase) {
            case InputDataTypeOneofCase.ZeroData:
              ZeroData = other.ZeroData;
              break;
            case InputDataTypeOneofCase.RandomData:
              RandomData = other.RandomData;
              break;
            case InputDataTypeOneofCase.InputDataFile:
              InputDataFile = other.InputDataFile;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Input Clone() {
          return new Input(this);
        }

        /// <summary>Field number for the "data_type" field.</summary>
        public const int DataTypeFieldNumber = 1;
        private global::Inference.DataType dataType_ = global::Inference.DataType.TypeInvalid;
        /// <summary>
        ///@@    .. cpp:var:: DataType data_type
        ///@@
        ///@@       The data-type of the input.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public global::Inference.DataType DataType {
          get { return dataType_; }
          set {
            dataType_ = value;
          }
        }

        /// <summary>Field number for the "dims" field.</summary>
        public const int DimsFieldNumber = 2;
        private static readonly pb::FieldCodec<long> _repeated_dims_codec
            = pb::FieldCodec.ForInt64(18);
        private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
        /// <summary>
        ///@@    .. cpp:var:: int64 dims (repeated)
        ///@@
        ///@@       The shape of the input tensor, not including the batch dimension.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<long> Dims {
          get { return dims_; }
        }

        /// <summary>Field number for the "zero_data" field.</summary>
        public const int ZeroDataFieldNumber = 3;
        /// <summary>
        ///@@
        ///@@    .. cpp:var:: bool zero_data
        ///@@
        ///@@       The identifier for using zeros as input data. Note that the
        ///@@       value of 'zero_data' will not be checked, instead, zero data
        ///@@       will be used as long as the field is set.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool ZeroData {
          get { return inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData ? (bool) inputDataType_ : false; }
          set {
            inputDataType_ = value;
            inputDataTypeCase_ = InputDataTypeOneofCase.ZeroData;
          }
        }

        /// <summary>Field number for the "random_data" field.</summary>
        public const int RandomDataFieldNumber = 4;
        /// <summary>
        ///@@
        ///@@    .. cpp:var:: bool random_data
        ///@@
        ///@@       The identifier for using random data as input data. Note that
        ///@@       the value of 'random_data' will not be checked, instead,
        ///@@       random data will be used as long as the field is set.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool RandomData {
          get { return inputDataTypeCase_ == InputDataTypeOneofCase.RandomData ? (bool) inputDataType_ : false; }
          set {
            inputDataType_ = value;
            inputDataTypeCase_ = InputDataTypeOneofCase.RandomData;
          }
        }

        /// <summary>Field number for the "input_data_file" field.</summary>
        public const int InputDataFileFieldNumber = 5;
        /// <summary>
        ///@@    .. cpp:var:: string input_data_file
        ///@@
        ///@@       The file whose content will be used as raw input data in
        ///@@       row-major order. The file must be provided in a sub-directory
        ///@@       'warmup' under the model directory. The file contents should be
        ///@@       in binary format. For TYPE_STRING data-type, an element is
        ///@@       represented by a 4-byte unsigned integer giving the length
        ///@@       followed by the actual bytes.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string InputDataFile {
          get { return inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile ? (string) inputDataType_ : ""; }
          set {
            inputDataType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
            inputDataTypeCase_ = InputDataTypeOneofCase.InputDataFile;
          }
        }

        private object inputDataType_;
        /// <summary>Enum of possible cases for the "input_data_type" oneof.</summary>
        public enum InputDataTypeOneofCase {
          None = 0,
          ZeroData = 3,
          RandomData = 4,
          InputDataFile = 5,
        }
        private InputDataTypeOneofCase inputDataTypeCase_ = InputDataTypeOneofCase.None;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public InputDataTypeOneofCase InputDataTypeCase {
          get { return inputDataTypeCase_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void ClearInputDataType() {
          inputDataTypeCase_ = InputDataTypeOneofCase.None;
          inputDataType_ = null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Input);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Input other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (DataType != other.DataType) return false;
          if(!dims_.Equals(other.dims_)) return false;
          if (ZeroData != other.ZeroData) return false;
          if (RandomData != other.RandomData) return false;
          if (InputDataFile != other.InputDataFile) return false;
          if (InputDataTypeCase != other.InputDataTypeCase) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (DataType != global::Inference.DataType.TypeInvalid) hash ^= DataType.GetHashCode();
          hash ^= dims_.GetHashCode();
          if (inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData) hash ^= ZeroData.GetHashCode();
          if (inputDataTypeCase_ == InputDataTypeOneofCase.RandomData) hash ^= RandomData.GetHashCode();
          if (inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile) hash ^= InputDataFile.GetHashCode();
          hash ^= (int) inputDataTypeCase_;
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(8);
            output.WriteEnum((int) DataType);
          }
          dims_.WriteTo(output, _repeated_dims_codec);
          if (inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData) {
            output.WriteRawTag(24);
            output.WriteBool(ZeroData);
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.RandomData) {
            output.WriteRawTag(32);
            output.WriteBool(RandomData);
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile) {
            output.WriteRawTag(42);
            output.WriteString(InputDataFile);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (DataType != global::Inference.DataType.TypeInvalid) {
            output.WriteRawTag(8);
            output.WriteEnum((int) DataType);
          }
          dims_.WriteTo(ref output, _repeated_dims_codec);
          if (inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData) {
            output.WriteRawTag(24);
            output.WriteBool(ZeroData);
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.RandomData) {
            output.WriteRawTag(32);
            output.WriteBool(RandomData);
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile) {
            output.WriteRawTag(42);
            output.WriteString(InputDataFile);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (DataType != global::Inference.DataType.TypeInvalid) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
          }
          size += dims_.CalculateSize(_repeated_dims_codec);
          if (inputDataTypeCase_ == InputDataTypeOneofCase.ZeroData) {
            size += 1 + 1;
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.RandomData) {
            size += 1 + 1;
          }
          if (inputDataTypeCase_ == InputDataTypeOneofCase.InputDataFile) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(InputDataFile);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Input other) {
          if (other == null) {
            return;
          }
          if (other.DataType != global::Inference.DataType.TypeInvalid) {
            DataType = other.DataType;
          }
          dims_.Add(other.dims_);
          switch (other.InputDataTypeCase) {
            case InputDataTypeOneofCase.ZeroData:
              ZeroData = other.ZeroData;
              break;
            case InputDataTypeOneofCase.RandomData:
              RandomData = other.RandomData;
              break;
            case InputDataTypeOneofCase.InputDataFile:
              InputDataFile = other.InputDataFile;
              break;
          }

          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                dims_.AddEntriesFrom(input, _repeated_dims_codec);
                break;
              }
              case 24: {
                ZeroData = input.ReadBool();
                break;
              }
              case 32: {
                RandomData = input.ReadBool();
                break;
              }
              case 42: {
                InputDataFile = input.ReadString();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                DataType = (global::Inference.DataType) input.ReadEnum();
                break;
              }
              case 18:
              case 16: {
                dims_.AddEntriesFrom(ref input, _repeated_dims_codec);
                break;
              }
              case 24: {
                ZeroData = input.ReadBool();
                break;
              }
              case 32: {
                RandomData = input.ReadBool();
                break;
              }
              case 42: {
                InputDataFile = input.ReadString();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@ .. cpp:var:: message ModelOperations
  ///@@
  ///@@    The metadata of libraries providing custom operations for this model.
  ///@@
  /// </summary>
  public sealed partial class ModelOperations : pb::IMessage<ModelOperations>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelOperations> _parser = new pb::MessageParser<ModelOperations>(() => new ModelOperations());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelOperations> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOperations() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOperations(ModelOperations other) : this() {
      opLibraryFilename_ = other.opLibraryFilename_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelOperations Clone() {
      return new ModelOperations(this);
    }

    /// <summary>Field number for the "op_library_filename" field.</summary>
    public const int OpLibraryFilenameFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_opLibraryFilename_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> opLibraryFilename_ = new pbc::RepeatedField<string>();
    /// <summary>
    ///@@  .. cpp:var:: string op_library_filename (repeated)
    ///@@
    ///@@     Optional paths of the libraries providing custom operations for
    ///@@     this model. Valid only for ONNX models.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<string> OpLibraryFilename {
      get { return opLibraryFilename_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelOperations);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelOperations other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!opLibraryFilename_.Equals(other.opLibraryFilename_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= opLibraryFilename_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      opLibraryFilename_.WriteTo(output, _repeated_opLibraryFilename_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      opLibraryFilename_.WriteTo(ref output, _repeated_opLibraryFilename_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += opLibraryFilename_.CalculateSize(_repeated_opLibraryFilename_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelOperations other) {
      if (other == null) {
        return;
      }
      opLibraryFilename_.Add(other.opLibraryFilename_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            opLibraryFilename_.AddEntriesFrom(input, _repeated_opLibraryFilename_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            opLibraryFilename_.AddEntriesFrom(ref input, _repeated_opLibraryFilename_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///@@
  ///@@ .. cpp:var:: message ModelTransactionPolicy
  ///@@
  ///@@    The specification that describes the nature of transactions
  ///@@    to be expected from the model.
  ///@@
  /// </summary>
  public sealed partial class ModelTransactionPolicy : pb::IMessage<ModelTransactionPolicy>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelTransactionPolicy> _parser = new pb::MessageParser<ModelTransactionPolicy>(() => new ModelTransactionPolicy());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelTransactionPolicy> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelTransactionPolicy() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelTransactionPolicy(ModelTransactionPolicy other) : this() {
      decoupled_ = other.decoupled_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelTransactionPolicy Clone() {
      return new ModelTransactionPolicy(this);
    }

    /// <summary>Field number for the "decoupled" field.</summary>
    public const int DecoupledFieldNumber = 1;
    private bool decoupled_;
    /// <summary>
    ///@@  .. cpp:var:: bool decoupled
    ///@@
    ///@@     Indicates whether responses generated by the model are decoupled with
    ///@@     the requests issued to it, which means the number of responses
    ///@@     generated by model may differ from number of requests issued, and
    ///@@     that the responses may be out of order relative to the order of
    ///@@     requests. The default is false, which means the model will generate
    ///@@     exactly one response for each request.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Decoupled {
      get { return decoupled_; }
      set {
        decoupled_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelTransactionPolicy);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelTransactionPolicy other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Decoupled != other.Decoupled) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Decoupled != false) hash ^= Decoupled.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Decoupled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Decoupled);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Decoupled != false) {
        output.WriteRawTag(8);
        output.WriteBool(Decoupled);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Decoupled != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelTransactionPolicy other) {
      if (other == null) {
        return;
      }
      if (other.Decoupled != false) {
        Decoupled = other.Decoupled;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Decoupled = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Decoupled = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelRepositoryAgents
  ///@@
  ///@@   The repository agents for the model.
  ///@@
  /// </summary>
  public sealed partial class ModelRepositoryAgents : pb::IMessage<ModelRepositoryAgents>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelRepositoryAgents> _parser = new pb::MessageParser<ModelRepositoryAgents>(() => new ModelRepositoryAgents());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelRepositoryAgents> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelRepositoryAgents() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelRepositoryAgents(ModelRepositoryAgents other) : this() {
      agents_ = other.agents_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelRepositoryAgents Clone() {
      return new ModelRepositoryAgents(this);
    }

    /// <summary>Field number for the "agents" field.</summary>
    public const int AgentsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Inference.ModelRepositoryAgents.Types.Agent> _repeated_agents_codec
        = pb::FieldCodec.ForMessage(10, global::Inference.ModelRepositoryAgents.Types.Agent.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelRepositoryAgents.Types.Agent> agents_ = new pbc::RepeatedField<global::Inference.ModelRepositoryAgents.Types.Agent>();
    /// <summary>
    ///@@
    ///@@  .. cpp:var:: Agent agents (repeated)
    ///@@
    ///@@     The ordered list of agents for the model. These agents will be
    ///@@     invoked in order to respond to repository actions occuring for the
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelRepositoryAgents.Types.Agent> Agents {
      get { return agents_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelRepositoryAgents);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelRepositoryAgents other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!agents_.Equals(other.agents_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= agents_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      agents_.WriteTo(output, _repeated_agents_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      agents_.WriteTo(ref output, _repeated_agents_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += agents_.CalculateSize(_repeated_agents_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelRepositoryAgents other) {
      if (other == null) {
        return;
      }
      agents_.Add(other.agents_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            agents_.AddEntriesFrom(input, _repeated_agents_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            agents_.AddEntriesFrom(ref input, _repeated_agents_codec);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ModelRepositoryAgents message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      ///@@
      ///@@  .. cpp:var:: message Agent
      ///@@
      ///@@     A repository agent that should be invoked for the specified
      ///@@     repository actions for this model.
      ///@@
      /// </summary>
      public sealed partial class Agent : pb::IMessage<Agent>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Agent> _parser = new pb::MessageParser<Agent>(() => new Agent());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Agent> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Inference.ModelRepositoryAgents.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Agent() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Agent(Agent other) : this() {
          name_ = other.name_;
          parameters_ = other.parameters_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Agent Clone() {
          return new Agent(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        ///@@    .. cpp:var:: string name
        ///@@
        ///@@       The name of the agent.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "parameters" field.</summary>
        public const int ParametersFieldNumber = 2;
        private static readonly pbc::MapField<string, string>.Codec _map_parameters_codec
            = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 18);
        private readonly pbc::MapField<string, string> parameters_ = new pbc::MapField<string, string>();
        /// <summary>
        ///@@    .. cpp:var:: map&lt;string, string> parameters
        ///@@
        ///@@       The parameters for the agent.
        ///@@
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::MapField<string, string> Parameters {
          get { return parameters_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Agent);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Agent other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!Parameters.Equals(other.Parameters)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= Parameters.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          parameters_.WriteTo(output, _map_parameters_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          parameters_.WriteTo(ref output, _map_parameters_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += parameters_.CalculateSize(_map_parameters_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Agent other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          parameters_.Add(other.parameters_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                parameters_.AddEntriesFrom(input, _map_parameters_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                parameters_.AddEntriesFrom(ref input, _map_parameters_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelResponseCache
  ///@@
  ///@@   The response cache setting for the model.
  ///@@
  /// </summary>
  public sealed partial class ModelResponseCache : pb::IMessage<ModelResponseCache>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelResponseCache> _parser = new pb::MessageParser<ModelResponseCache>(() => new ModelResponseCache());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelResponseCache> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelResponseCache() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelResponseCache(ModelResponseCache other) : this() {
      enable_ = other.enable_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelResponseCache Clone() {
      return new ModelResponseCache(this);
    }

    /// <summary>Field number for the "enable" field.</summary>
    public const int EnableFieldNumber = 1;
    private bool enable_;
    /// <summary>
    ///@@
    ///@@  .. cpp::var:: bool enable
    ///@@
    ///@@     Whether or not to use response cache for the model. If True, the
    ///@@     responses from the model are cached and when identical request
    ///@@     is encountered, instead of going through the model execution,
    ///@@     the response from the cache is utilized. By default, response
    ///@@     cache is disabled for the models.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Enable {
      get { return enable_; }
      set {
        enable_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelResponseCache);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelResponseCache other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Enable != other.Enable) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Enable != false) hash ^= Enable.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Enable != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enable);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Enable != false) {
        output.WriteRawTag(8);
        output.WriteBool(Enable);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Enable != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelResponseCache other) {
      if (other == null) {
        return;
      }
      if (other.Enable != false) {
        Enable = other.Enable;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Enable = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            Enable = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  ///@@
  ///@@.. cpp:var:: message ModelConfig
  ///@@
  ///@@   A model configuration.
  ///@@
  /// </summary>
  public sealed partial class ModelConfig : pb::IMessage<ModelConfig>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ModelConfig> _parser = new pb::MessageParser<ModelConfig>(() => new ModelConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ModelConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Inference.ModelConfigReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelConfig(ModelConfig other) : this() {
      name_ = other.name_;
      platform_ = other.platform_;
      backend_ = other.backend_;
      versionPolicy_ = other.versionPolicy_ != null ? other.versionPolicy_.Clone() : null;
      maxBatchSize_ = other.maxBatchSize_;
      input_ = other.input_.Clone();
      output_ = other.output_.Clone();
      batchInput_ = other.batchInput_.Clone();
      batchOutput_ = other.batchOutput_.Clone();
      optimization_ = other.optimization_ != null ? other.optimization_.Clone() : null;
      instanceGroup_ = other.instanceGroup_.Clone();
      defaultModelFilename_ = other.defaultModelFilename_;
      ccModelFilenames_ = other.ccModelFilenames_.Clone();
      metricTags_ = other.metricTags_.Clone();
      parameters_ = other.parameters_.Clone();
      modelWarmup_ = other.modelWarmup_.Clone();
      modelOperations_ = other.modelOperations_ != null ? other.modelOperations_.Clone() : null;
      modelTransactionPolicy_ = other.modelTransactionPolicy_ != null ? other.modelTransactionPolicy_.Clone() : null;
      modelRepositoryAgents_ = other.modelRepositoryAgents_ != null ? other.modelRepositoryAgents_.Clone() : null;
      responseCache_ = other.responseCache_ != null ? other.responseCache_.Clone() : null;
      switch (other.SchedulingChoiceCase) {
        case SchedulingChoiceOneofCase.DynamicBatching:
          DynamicBatching = other.DynamicBatching.Clone();
          break;
        case SchedulingChoiceOneofCase.SequenceBatching:
          SequenceBatching = other.SequenceBatching.Clone();
          break;
        case SchedulingChoiceOneofCase.EnsembleScheduling:
          EnsembleScheduling = other.EnsembleScheduling.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ModelConfig Clone() {
      return new ModelConfig(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string name
    ///@@
    ///@@     The name of the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "platform" field.</summary>
    public const int PlatformFieldNumber = 2;
    private string platform_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string platform
    ///@@
    ///@@     The framework for the model. Possible values are
    ///@@     "tensorrt_plan", "tensorflow_graphdef",
    ///@@     "tensorflow_savedmodel", "onnxruntime_onnx",
    ///@@     "pytorch_libtorch".
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Platform {
      get { return platform_; }
      set {
        platform_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "backend" field.</summary>
    public const int BackendFieldNumber = 17;
    private string backend_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string backend
    ///@@
    ///@@     The backend used by the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Backend {
      get { return backend_; }
      set {
        backend_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "version_policy" field.</summary>
    public const int VersionPolicyFieldNumber = 3;
    private global::Inference.ModelVersionPolicy versionPolicy_;
    /// <summary>
    ///@@  .. cpp:var:: ModelVersionPolicy version_policy
    ///@@
    ///@@     Policy indicating which version(s) of the model will be served.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelVersionPolicy VersionPolicy {
      get { return versionPolicy_; }
      set {
        versionPolicy_ = value;
      }
    }

    /// <summary>Field number for the "max_batch_size" field.</summary>
    public const int MaxBatchSizeFieldNumber = 4;
    private int maxBatchSize_;
    /// <summary>
    ///@@  .. cpp:var:: int32 max_batch_size
    ///@@
    ///@@     Maximum batch size allowed for inference. This can only decrease
    ///@@     what is allowed by the model itself. A max_batch_size value of 0
    ///@@     indicates that batching is not allowed for the model and the
    ///@@     dimension/shape of the input and output tensors must exactly
    ///@@     match what is specified in the input and output configuration. A
    ///@@     max_batch_size value > 0 indicates that batching is allowed and
    ///@@     so the model expects the input tensors to have an additional
    ///@@     initial dimension for the batching that is not specified in the
    ///@@     input (for example, if the model supports batched inputs of
    ///@@     2-dimensional tensors then the model configuration will specify
    ///@@     the input shape as [ X, Y ] but the model will expect the actual
    ///@@     input tensors to have shape [ N, X, Y ]). For max_batch_size > 0
    ///@@     returned outputs will also have an additional initial dimension
    ///@@     for the batch.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int MaxBatchSize {
      get { return maxBatchSize_; }
      set {
        maxBatchSize_ = value;
      }
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Inference.ModelInput> _repeated_input_codec
        = pb::FieldCodec.ForMessage(42, global::Inference.ModelInput.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelInput> input_ = new pbc::RepeatedField<global::Inference.ModelInput>();
    /// <summary>
    ///@@  .. cpp:var:: ModelInput input (repeated)
    ///@@
    ///@@     The inputs request by the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelInput> Input {
      get { return input_; }
    }

    /// <summary>Field number for the "output" field.</summary>
    public const int OutputFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Inference.ModelOutput> _repeated_output_codec
        = pb::FieldCodec.ForMessage(50, global::Inference.ModelOutput.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelOutput> output_ = new pbc::RepeatedField<global::Inference.ModelOutput>();
    /// <summary>
    ///@@  .. cpp:var:: ModelOutput output (repeated)
    ///@@
    ///@@     The outputs produced by the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelOutput> Output {
      get { return output_; }
    }

    /// <summary>Field number for the "batch_input" field.</summary>
    public const int BatchInputFieldNumber = 20;
    private static readonly pb::FieldCodec<global::Inference.BatchInput> _repeated_batchInput_codec
        = pb::FieldCodec.ForMessage(162, global::Inference.BatchInput.Parser);
    private readonly pbc::RepeatedField<global::Inference.BatchInput> batchInput_ = new pbc::RepeatedField<global::Inference.BatchInput>();
    /// <summary>
    ///@@  .. cpp:var:: BatchInput batch_input (repeated)
    ///@@
    ///@@     The model input(s) that the server should use to communicate
    ///@@     batch related values to the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.BatchInput> BatchInput {
      get { return batchInput_; }
    }

    /// <summary>Field number for the "batch_output" field.</summary>
    public const int BatchOutputFieldNumber = 21;
    private static readonly pb::FieldCodec<global::Inference.BatchOutput> _repeated_batchOutput_codec
        = pb::FieldCodec.ForMessage(170, global::Inference.BatchOutput.Parser);
    private readonly pbc::RepeatedField<global::Inference.BatchOutput> batchOutput_ = new pbc::RepeatedField<global::Inference.BatchOutput>();
    /// <summary>
    ///@@  .. cpp:var:: BatchOutput batch_output (repeated)
    ///@@
    ///@@     The outputs produced by the model that requires special handling
    ///@@     by the model backend.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.BatchOutput> BatchOutput {
      get { return batchOutput_; }
    }

    /// <summary>Field number for the "optimization" field.</summary>
    public const int OptimizationFieldNumber = 12;
    private global::Inference.ModelOptimizationPolicy optimization_;
    /// <summary>
    ///@@  .. cpp:var:: ModelOptimizationPolicy optimization
    ///@@
    ///@@     Optimization configuration for the model. If not specified
    ///@@     then default optimization policy is used.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOptimizationPolicy Optimization {
      get { return optimization_; }
      set {
        optimization_ = value;
      }
    }

    /// <summary>Field number for the "dynamic_batching" field.</summary>
    public const int DynamicBatchingFieldNumber = 11;
    /// <summary>
    ///@@    .. cpp:var:: ModelDynamicBatching dynamic_batching
    ///@@
    ///@@       If specified, enables the dynamic-batching scheduling
    ///@@       policy. With dynamic-batching the scheduler may group
    ///@@       together independent requests into a single batch to
    ///@@       improve inference throughput.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelDynamicBatching DynamicBatching {
      get { return schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching ? (global::Inference.ModelDynamicBatching) schedulingChoice_ : null; }
      set {
        schedulingChoice_ = value;
        schedulingChoiceCase_ = value == null ? SchedulingChoiceOneofCase.None : SchedulingChoiceOneofCase.DynamicBatching;
      }
    }

    /// <summary>Field number for the "sequence_batching" field.</summary>
    public const int SequenceBatchingFieldNumber = 13;
    /// <summary>
    ///@@    .. cpp:var:: ModelSequenceBatching sequence_batching
    ///@@
    ///@@       If specified, enables the sequence-batching scheduling
    ///@@       policy. With sequence-batching, inference requests
    ///@@       with the same correlation ID are routed to the same
    ///@@       model instance. Multiple sequences of inference requests
    ///@@       may be batched together into a single batch to
    ///@@       improve inference throughput.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelSequenceBatching SequenceBatching {
      get { return schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching ? (global::Inference.ModelSequenceBatching) schedulingChoice_ : null; }
      set {
        schedulingChoice_ = value;
        schedulingChoiceCase_ = value == null ? SchedulingChoiceOneofCase.None : SchedulingChoiceOneofCase.SequenceBatching;
      }
    }

    /// <summary>Field number for the "ensemble_scheduling" field.</summary>
    public const int EnsembleSchedulingFieldNumber = 15;
    /// <summary>
    ///@@    .. cpp:var:: ModelEnsembling ensemble_scheduling
    ///@@
    ///@@       If specified, enables the model-ensembling scheduling
    ///@@       policy. With model-ensembling, inference requests
    ///@@       will be processed according to the specification, such as an
    ///@@       execution sequence of models. The input specified in this model
    ///@@       config will be the input for the ensemble, and the output
    ///@@       specified will be the output of the ensemble.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelEnsembling EnsembleScheduling {
      get { return schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling ? (global::Inference.ModelEnsembling) schedulingChoice_ : null; }
      set {
        schedulingChoice_ = value;
        schedulingChoiceCase_ = value == null ? SchedulingChoiceOneofCase.None : SchedulingChoiceOneofCase.EnsembleScheduling;
      }
    }

    /// <summary>Field number for the "instance_group" field.</summary>
    public const int InstanceGroupFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Inference.ModelInstanceGroup> _repeated_instanceGroup_codec
        = pb::FieldCodec.ForMessage(58, global::Inference.ModelInstanceGroup.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelInstanceGroup> instanceGroup_ = new pbc::RepeatedField<global::Inference.ModelInstanceGroup>();
    /// <summary>
    ///@@  .. cpp:var:: ModelInstanceGroup instance_group (repeated)
    ///@@
    ///@@     Instances of this model. If not specified, one instance
    ///@@     of the model will be instantiated on each available GPU.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelInstanceGroup> InstanceGroup {
      get { return instanceGroup_; }
    }

    /// <summary>Field number for the "default_model_filename" field.</summary>
    public const int DefaultModelFilenameFieldNumber = 8;
    private string defaultModelFilename_ = "";
    /// <summary>
    ///@@  .. cpp:var:: string default_model_filename
    ///@@
    ///@@     Optional filename of the model file to use if a
    ///@@     compute-capability specific model is not specified in
    ///@@     :cpp:var:`cc_model_filenames`. If not specified the default name
    ///@@     is 'model.graphdef', 'model.savedmodel', 'model.plan' or
    ///@@     'model.pt' depending on the model type.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string DefaultModelFilename {
      get { return defaultModelFilename_; }
      set {
        defaultModelFilename_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "cc_model_filenames" field.</summary>
    public const int CcModelFilenamesFieldNumber = 9;
    private static readonly pbc::MapField<string, string>.Codec _map_ccModelFilenames_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 74);
    private readonly pbc::MapField<string, string> ccModelFilenames_ = new pbc::MapField<string, string>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string,string> cc_model_filenames
    ///@@
    ///@@     Optional map from CUDA compute capability to the filename of
    ///@@     the model that supports that compute capability. The filename
    ///@@     refers to a file within the model version directory.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> CcModelFilenames {
      get { return ccModelFilenames_; }
    }

    /// <summary>Field number for the "metric_tags" field.</summary>
    public const int MetricTagsFieldNumber = 10;
    private static readonly pbc::MapField<string, string>.Codec _map_metricTags_codec
        = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForString(18, ""), 82);
    private readonly pbc::MapField<string, string> metricTags_ = new pbc::MapField<string, string>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string,string> metric_tags
    ///@@
    ///@@     Optional metric tags. User-specific key-value pairs for metrics
    ///@@     reported for this model. These tags are applied to the metrics
    ///@@     reported on the HTTP metrics port.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, string> MetricTags {
      get { return metricTags_; }
    }

    /// <summary>Field number for the "parameters" field.</summary>
    public const int ParametersFieldNumber = 14;
    private static readonly pbc::MapField<string, global::Inference.ModelParameter>.Codec _map_parameters_codec
        = new pbc::MapField<string, global::Inference.ModelParameter>.Codec(pb::FieldCodec.ForString(10, ""), pb::FieldCodec.ForMessage(18, global::Inference.ModelParameter.Parser), 114);
    private readonly pbc::MapField<string, global::Inference.ModelParameter> parameters_ = new pbc::MapField<string, global::Inference.ModelParameter>();
    /// <summary>
    ///@@  .. cpp:var:: map&lt;string,ModelParameter> parameters
    ///@@
    ///@@     Optional model parameters. User-specified parameter values.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::MapField<string, global::Inference.ModelParameter> Parameters {
      get { return parameters_; }
    }

    /// <summary>Field number for the "model_warmup" field.</summary>
    public const int ModelWarmupFieldNumber = 16;
    private static readonly pb::FieldCodec<global::Inference.ModelWarmup> _repeated_modelWarmup_codec
        = pb::FieldCodec.ForMessage(130, global::Inference.ModelWarmup.Parser);
    private readonly pbc::RepeatedField<global::Inference.ModelWarmup> modelWarmup_ = new pbc::RepeatedField<global::Inference.ModelWarmup>();
    /// <summary>
    ///@@  .. cpp:var:: ModelWarmup model_warmup (repeated)
    ///@@
    ///@@     Warmup setting of this model. If specified, all instances
    ///@@     will be run with the request samples in sequence before
    ///@@     serving the model.
    ///@@     This field can only be specified if the model is not an ensemble
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Inference.ModelWarmup> ModelWarmup {
      get { return modelWarmup_; }
    }

    /// <summary>Field number for the "model_operations" field.</summary>
    public const int ModelOperationsFieldNumber = 18;
    private global::Inference.ModelOperations modelOperations_;
    /// <summary>
    ///@@  .. cpp:var:: ModelOperations model_operations
    ///@@
    ///@@     Optional metadata of the libraries providing custom operations for
    ///@@     this model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelOperations ModelOperations {
      get { return modelOperations_; }
      set {
        modelOperations_ = value;
      }
    }

    /// <summary>Field number for the "model_transaction_policy" field.</summary>
    public const int ModelTransactionPolicyFieldNumber = 19;
    private global::Inference.ModelTransactionPolicy modelTransactionPolicy_;
    /// <summary>
    ///@@  .. cpp:var:: ModelTransactionPolicy model_transaction_policy
    ///@@
    ///@@     Optional specification that describes the nature of transactions
    ///@@     to be expected from the model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelTransactionPolicy ModelTransactionPolicy {
      get { return modelTransactionPolicy_; }
      set {
        modelTransactionPolicy_ = value;
      }
    }

    /// <summary>Field number for the "model_repository_agents" field.</summary>
    public const int ModelRepositoryAgentsFieldNumber = 23;
    private global::Inference.ModelRepositoryAgents modelRepositoryAgents_;
    /// <summary>
    ///@@  .. cpp:var:: ModelRepositoryAgents model_repository_agents
    ///@@
    ///@@     Optional specification of the agent(s) that should be invoked
    ///@@     with repository actions are performed for this model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelRepositoryAgents ModelRepositoryAgents {
      get { return modelRepositoryAgents_; }
      set {
        modelRepositoryAgents_ = value;
      }
    }

    /// <summary>Field number for the "response_cache" field.</summary>
    public const int ResponseCacheFieldNumber = 24;
    private global::Inference.ModelResponseCache responseCache_;
    /// <summary>
    ///@@  .. cpp:var:: ModelResponseCache response_cache
    ///@@
    ///@@     Optional setting for utilizing the response cache for this
    ///@@     model.
    ///@@
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Inference.ModelResponseCache ResponseCache {
      get { return responseCache_; }
      set {
        responseCache_ = value;
      }
    }

    private object schedulingChoice_;
    /// <summary>Enum of possible cases for the "scheduling_choice" oneof.</summary>
    public enum SchedulingChoiceOneofCase {
      None = 0,
      DynamicBatching = 11,
      SequenceBatching = 13,
      EnsembleScheduling = 15,
    }
    private SchedulingChoiceOneofCase schedulingChoiceCase_ = SchedulingChoiceOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SchedulingChoiceOneofCase SchedulingChoiceCase {
      get { return schedulingChoiceCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSchedulingChoice() {
      schedulingChoiceCase_ = SchedulingChoiceOneofCase.None;
      schedulingChoice_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ModelConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ModelConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Platform != other.Platform) return false;
      if (Backend != other.Backend) return false;
      if (!object.Equals(VersionPolicy, other.VersionPolicy)) return false;
      if (MaxBatchSize != other.MaxBatchSize) return false;
      if(!input_.Equals(other.input_)) return false;
      if(!output_.Equals(other.output_)) return false;
      if(!batchInput_.Equals(other.batchInput_)) return false;
      if(!batchOutput_.Equals(other.batchOutput_)) return false;
      if (!object.Equals(Optimization, other.Optimization)) return false;
      if (!object.Equals(DynamicBatching, other.DynamicBatching)) return false;
      if (!object.Equals(SequenceBatching, other.SequenceBatching)) return false;
      if (!object.Equals(EnsembleScheduling, other.EnsembleScheduling)) return false;
      if(!instanceGroup_.Equals(other.instanceGroup_)) return false;
      if (DefaultModelFilename != other.DefaultModelFilename) return false;
      if (!CcModelFilenames.Equals(other.CcModelFilenames)) return false;
      if (!MetricTags.Equals(other.MetricTags)) return false;
      if (!Parameters.Equals(other.Parameters)) return false;
      if(!modelWarmup_.Equals(other.modelWarmup_)) return false;
      if (!object.Equals(ModelOperations, other.ModelOperations)) return false;
      if (!object.Equals(ModelTransactionPolicy, other.ModelTransactionPolicy)) return false;
      if (!object.Equals(ModelRepositoryAgents, other.ModelRepositoryAgents)) return false;
      if (!object.Equals(ResponseCache, other.ResponseCache)) return false;
      if (SchedulingChoiceCase != other.SchedulingChoiceCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Platform.Length != 0) hash ^= Platform.GetHashCode();
      if (Backend.Length != 0) hash ^= Backend.GetHashCode();
      if (versionPolicy_ != null) hash ^= VersionPolicy.GetHashCode();
      if (MaxBatchSize != 0) hash ^= MaxBatchSize.GetHashCode();
      hash ^= input_.GetHashCode();
      hash ^= output_.GetHashCode();
      hash ^= batchInput_.GetHashCode();
      hash ^= batchOutput_.GetHashCode();
      if (optimization_ != null) hash ^= Optimization.GetHashCode();
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) hash ^= DynamicBatching.GetHashCode();
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) hash ^= SequenceBatching.GetHashCode();
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) hash ^= EnsembleScheduling.GetHashCode();
      hash ^= instanceGroup_.GetHashCode();
      if (DefaultModelFilename.Length != 0) hash ^= DefaultModelFilename.GetHashCode();
      hash ^= CcModelFilenames.GetHashCode();
      hash ^= MetricTags.GetHashCode();
      hash ^= Parameters.GetHashCode();
      hash ^= modelWarmup_.GetHashCode();
      if (modelOperations_ != null) hash ^= ModelOperations.GetHashCode();
      if (modelTransactionPolicy_ != null) hash ^= ModelTransactionPolicy.GetHashCode();
      if (modelRepositoryAgents_ != null) hash ^= ModelRepositoryAgents.GetHashCode();
      if (responseCache_ != null) hash ^= ResponseCache.GetHashCode();
      hash ^= (int) schedulingChoiceCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Platform.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Platform);
      }
      if (versionPolicy_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(VersionPolicy);
      }
      if (MaxBatchSize != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxBatchSize);
      }
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      instanceGroup_.WriteTo(output, _repeated_instanceGroup_codec);
      if (DefaultModelFilename.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(DefaultModelFilename);
      }
      ccModelFilenames_.WriteTo(output, _map_ccModelFilenames_codec);
      metricTags_.WriteTo(output, _map_metricTags_codec);
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
        output.WriteRawTag(90);
        output.WriteMessage(DynamicBatching);
      }
      if (optimization_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Optimization);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
        output.WriteRawTag(106);
        output.WriteMessage(SequenceBatching);
      }
      parameters_.WriteTo(output, _map_parameters_codec);
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
        output.WriteRawTag(122);
        output.WriteMessage(EnsembleScheduling);
      }
      modelWarmup_.WriteTo(output, _repeated_modelWarmup_codec);
      if (Backend.Length != 0) {
        output.WriteRawTag(138, 1);
        output.WriteString(Backend);
      }
      if (modelOperations_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(ModelOperations);
      }
      if (modelTransactionPolicy_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ModelTransactionPolicy);
      }
      batchInput_.WriteTo(output, _repeated_batchInput_codec);
      batchOutput_.WriteTo(output, _repeated_batchOutput_codec);
      if (modelRepositoryAgents_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(ModelRepositoryAgents);
      }
      if (responseCache_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(ResponseCache);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Platform.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Platform);
      }
      if (versionPolicy_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(VersionPolicy);
      }
      if (MaxBatchSize != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxBatchSize);
      }
      input_.WriteTo(ref output, _repeated_input_codec);
      output_.WriteTo(ref output, _repeated_output_codec);
      instanceGroup_.WriteTo(ref output, _repeated_instanceGroup_codec);
      if (DefaultModelFilename.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(DefaultModelFilename);
      }
      ccModelFilenames_.WriteTo(ref output, _map_ccModelFilenames_codec);
      metricTags_.WriteTo(ref output, _map_metricTags_codec);
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
        output.WriteRawTag(90);
        output.WriteMessage(DynamicBatching);
      }
      if (optimization_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(Optimization);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
        output.WriteRawTag(106);
        output.WriteMessage(SequenceBatching);
      }
      parameters_.WriteTo(ref output, _map_parameters_codec);
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
        output.WriteRawTag(122);
        output.WriteMessage(EnsembleScheduling);
      }
      modelWarmup_.WriteTo(ref output, _repeated_modelWarmup_codec);
      if (Backend.Length != 0) {
        output.WriteRawTag(138, 1);
        output.WriteString(Backend);
      }
      if (modelOperations_ != null) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(ModelOperations);
      }
      if (modelTransactionPolicy_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ModelTransactionPolicy);
      }
      batchInput_.WriteTo(ref output, _repeated_batchInput_codec);
      batchOutput_.WriteTo(ref output, _repeated_batchOutput_codec);
      if (modelRepositoryAgents_ != null) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(ModelRepositoryAgents);
      }
      if (responseCache_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(ResponseCache);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Platform.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Platform);
      }
      if (Backend.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Backend);
      }
      if (versionPolicy_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(VersionPolicy);
      }
      if (MaxBatchSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxBatchSize);
      }
      size += input_.CalculateSize(_repeated_input_codec);
      size += output_.CalculateSize(_repeated_output_codec);
      size += batchInput_.CalculateSize(_repeated_batchInput_codec);
      size += batchOutput_.CalculateSize(_repeated_batchOutput_codec);
      if (optimization_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Optimization);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DynamicBatching);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SequenceBatching);
      }
      if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EnsembleScheduling);
      }
      size += instanceGroup_.CalculateSize(_repeated_instanceGroup_codec);
      if (DefaultModelFilename.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DefaultModelFilename);
      }
      size += ccModelFilenames_.CalculateSize(_map_ccModelFilenames_codec);
      size += metricTags_.CalculateSize(_map_metricTags_codec);
      size += parameters_.CalculateSize(_map_parameters_codec);
      size += modelWarmup_.CalculateSize(_repeated_modelWarmup_codec);
      if (modelOperations_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ModelOperations);
      }
      if (modelTransactionPolicy_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ModelTransactionPolicy);
      }
      if (modelRepositoryAgents_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ModelRepositoryAgents);
      }
      if (responseCache_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ResponseCache);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ModelConfig other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Platform.Length != 0) {
        Platform = other.Platform;
      }
      if (other.Backend.Length != 0) {
        Backend = other.Backend;
      }
      if (other.versionPolicy_ != null) {
        if (versionPolicy_ == null) {
          VersionPolicy = new global::Inference.ModelVersionPolicy();
        }
        VersionPolicy.MergeFrom(other.VersionPolicy);
      }
      if (other.MaxBatchSize != 0) {
        MaxBatchSize = other.MaxBatchSize;
      }
      input_.Add(other.input_);
      output_.Add(other.output_);
      batchInput_.Add(other.batchInput_);
      batchOutput_.Add(other.batchOutput_);
      if (other.optimization_ != null) {
        if (optimization_ == null) {
          Optimization = new global::Inference.ModelOptimizationPolicy();
        }
        Optimization.MergeFrom(other.Optimization);
      }
      instanceGroup_.Add(other.instanceGroup_);
      if (other.DefaultModelFilename.Length != 0) {
        DefaultModelFilename = other.DefaultModelFilename;
      }
      ccModelFilenames_.Add(other.ccModelFilenames_);
      metricTags_.Add(other.metricTags_);
      parameters_.Add(other.parameters_);
      modelWarmup_.Add(other.modelWarmup_);
      if (other.modelOperations_ != null) {
        if (modelOperations_ == null) {
          ModelOperations = new global::Inference.ModelOperations();
        }
        ModelOperations.MergeFrom(other.ModelOperations);
      }
      if (other.modelTransactionPolicy_ != null) {
        if (modelTransactionPolicy_ == null) {
          ModelTransactionPolicy = new global::Inference.ModelTransactionPolicy();
        }
        ModelTransactionPolicy.MergeFrom(other.ModelTransactionPolicy);
      }
      if (other.modelRepositoryAgents_ != null) {
        if (modelRepositoryAgents_ == null) {
          ModelRepositoryAgents = new global::Inference.ModelRepositoryAgents();
        }
        ModelRepositoryAgents.MergeFrom(other.ModelRepositoryAgents);
      }
      if (other.responseCache_ != null) {
        if (responseCache_ == null) {
          ResponseCache = new global::Inference.ModelResponseCache();
        }
        ResponseCache.MergeFrom(other.ResponseCache);
      }
      switch (other.SchedulingChoiceCase) {
        case SchedulingChoiceOneofCase.DynamicBatching:
          if (DynamicBatching == null) {
            DynamicBatching = new global::Inference.ModelDynamicBatching();
          }
          DynamicBatching.MergeFrom(other.DynamicBatching);
          break;
        case SchedulingChoiceOneofCase.SequenceBatching:
          if (SequenceBatching == null) {
            SequenceBatching = new global::Inference.ModelSequenceBatching();
          }
          SequenceBatching.MergeFrom(other.SequenceBatching);
          break;
        case SchedulingChoiceOneofCase.EnsembleScheduling:
          if (EnsembleScheduling == null) {
            EnsembleScheduling = new global::Inference.ModelEnsembling();
          }
          EnsembleScheduling.MergeFrom(other.EnsembleScheduling);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Platform = input.ReadString();
            break;
          }
          case 26: {
            if (versionPolicy_ == null) {
              VersionPolicy = new global::Inference.ModelVersionPolicy();
            }
            input.ReadMessage(VersionPolicy);
            break;
          }
          case 32: {
            MaxBatchSize = input.ReadInt32();
            break;
          }
          case 42: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 50: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 58: {
            instanceGroup_.AddEntriesFrom(input, _repeated_instanceGroup_codec);
            break;
          }
          case 66: {
            DefaultModelFilename = input.ReadString();
            break;
          }
          case 74: {
            ccModelFilenames_.AddEntriesFrom(input, _map_ccModelFilenames_codec);
            break;
          }
          case 82: {
            metricTags_.AddEntriesFrom(input, _map_metricTags_codec);
            break;
          }
          case 90: {
            global::Inference.ModelDynamicBatching subBuilder = new global::Inference.ModelDynamicBatching();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
              subBuilder.MergeFrom(DynamicBatching);
            }
            input.ReadMessage(subBuilder);
            DynamicBatching = subBuilder;
            break;
          }
          case 98: {
            if (optimization_ == null) {
              Optimization = new global::Inference.ModelOptimizationPolicy();
            }
            input.ReadMessage(Optimization);
            break;
          }
          case 106: {
            global::Inference.ModelSequenceBatching subBuilder = new global::Inference.ModelSequenceBatching();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
              subBuilder.MergeFrom(SequenceBatching);
            }
            input.ReadMessage(subBuilder);
            SequenceBatching = subBuilder;
            break;
          }
          case 114: {
            parameters_.AddEntriesFrom(input, _map_parameters_codec);
            break;
          }
          case 122: {
            global::Inference.ModelEnsembling subBuilder = new global::Inference.ModelEnsembling();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
              subBuilder.MergeFrom(EnsembleScheduling);
            }
            input.ReadMessage(subBuilder);
            EnsembleScheduling = subBuilder;
            break;
          }
          case 130: {
            modelWarmup_.AddEntriesFrom(input, _repeated_modelWarmup_codec);
            break;
          }
          case 138: {
            Backend = input.ReadString();
            break;
          }
          case 146: {
            if (modelOperations_ == null) {
              ModelOperations = new global::Inference.ModelOperations();
            }
            input.ReadMessage(ModelOperations);
            break;
          }
          case 154: {
            if (modelTransactionPolicy_ == null) {
              ModelTransactionPolicy = new global::Inference.ModelTransactionPolicy();
            }
            input.ReadMessage(ModelTransactionPolicy);
            break;
          }
          case 162: {
            batchInput_.AddEntriesFrom(input, _repeated_batchInput_codec);
            break;
          }
          case 170: {
            batchOutput_.AddEntriesFrom(input, _repeated_batchOutput_codec);
            break;
          }
          case 186: {
            if (modelRepositoryAgents_ == null) {
              ModelRepositoryAgents = new global::Inference.ModelRepositoryAgents();
            }
            input.ReadMessage(ModelRepositoryAgents);
            break;
          }
          case 194: {
            if (responseCache_ == null) {
              ResponseCache = new global::Inference.ModelResponseCache();
            }
            input.ReadMessage(ResponseCache);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Platform = input.ReadString();
            break;
          }
          case 26: {
            if (versionPolicy_ == null) {
              VersionPolicy = new global::Inference.ModelVersionPolicy();
            }
            input.ReadMessage(VersionPolicy);
            break;
          }
          case 32: {
            MaxBatchSize = input.ReadInt32();
            break;
          }
          case 42: {
            input_.AddEntriesFrom(ref input, _repeated_input_codec);
            break;
          }
          case 50: {
            output_.AddEntriesFrom(ref input, _repeated_output_codec);
            break;
          }
          case 58: {
            instanceGroup_.AddEntriesFrom(ref input, _repeated_instanceGroup_codec);
            break;
          }
          case 66: {
            DefaultModelFilename = input.ReadString();
            break;
          }
          case 74: {
            ccModelFilenames_.AddEntriesFrom(ref input, _map_ccModelFilenames_codec);
            break;
          }
          case 82: {
            metricTags_.AddEntriesFrom(ref input, _map_metricTags_codec);
            break;
          }
          case 90: {
            global::Inference.ModelDynamicBatching subBuilder = new global::Inference.ModelDynamicBatching();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.DynamicBatching) {
              subBuilder.MergeFrom(DynamicBatching);
            }
            input.ReadMessage(subBuilder);
            DynamicBatching = subBuilder;
            break;
          }
          case 98: {
            if (optimization_ == null) {
              Optimization = new global::Inference.ModelOptimizationPolicy();
            }
            input.ReadMessage(Optimization);
            break;
          }
          case 106: {
            global::Inference.ModelSequenceBatching subBuilder = new global::Inference.ModelSequenceBatching();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.SequenceBatching) {
              subBuilder.MergeFrom(SequenceBatching);
            }
            input.ReadMessage(subBuilder);
            SequenceBatching = subBuilder;
            break;
          }
          case 114: {
            parameters_.AddEntriesFrom(ref input, _map_parameters_codec);
            break;
          }
          case 122: {
            global::Inference.ModelEnsembling subBuilder = new global::Inference.ModelEnsembling();
            if (schedulingChoiceCase_ == SchedulingChoiceOneofCase.EnsembleScheduling) {
              subBuilder.MergeFrom(EnsembleScheduling);
            }
            input.ReadMessage(subBuilder);
            EnsembleScheduling = subBuilder;
            break;
          }
          case 130: {
            modelWarmup_.AddEntriesFrom(ref input, _repeated_modelWarmup_codec);
            break;
          }
          case 138: {
            Backend = input.ReadString();
            break;
          }
          case 146: {
            if (modelOperations_ == null) {
              ModelOperations = new global::Inference.ModelOperations();
            }
            input.ReadMessage(ModelOperations);
            break;
          }
          case 154: {
            if (modelTransactionPolicy_ == null) {
              ModelTransactionPolicy = new global::Inference.ModelTransactionPolicy();
            }
            input.ReadMessage(ModelTransactionPolicy);
            break;
          }
          case 162: {
            batchInput_.AddEntriesFrom(ref input, _repeated_batchInput_codec);
            break;
          }
          case 170: {
            batchOutput_.AddEntriesFrom(ref input, _repeated_batchOutput_codec);
            break;
          }
          case 186: {
            if (modelRepositoryAgents_ == null) {
              ModelRepositoryAgents = new global::Inference.ModelRepositoryAgents();
            }
            input.ReadMessage(ModelRepositoryAgents);
            break;
          }
          case 194: {
            if (responseCache_ == null) {
              ResponseCache = new global::Inference.ModelResponseCache();
            }
            input.ReadMessage(ResponseCache);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
