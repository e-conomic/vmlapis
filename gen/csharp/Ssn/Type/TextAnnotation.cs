// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: ssn/type/text_annotation.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Ssn.Type {

  /// <summary>Holder for reflection information generated from ssn/type/text_annotation.proto</summary>
  public static partial class TextAnnotationReflection {

    #region Descriptor
    /// <summary>File descriptor for ssn/type/text_annotation.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TextAnnotationReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ch5zc24vdHlwZS90ZXh0X2Fubm90YXRpb24ucHJvdG8SCHNzbi50eXBlGhdz",
            "c24vdHlwZS9nZW9tZXRyeS5wcm90byLeAwoOVGV4dEFubm90YXRpb24SHQoF",
            "cGFnZXMYASADKAsyDi5zc24udHlwZS5QYWdlEgwKBHRleHQYAiABKAkaPQoQ",
            "RGV0ZWN0ZWRMYW5ndWFnZRIVCg1sYW5ndWFnZV9jb2RlGAEgASgJEhIKCmNv",
            "bmZpZGVuY2UYAiABKAIaxwEKDURldGVjdGVkQnJlYWsSPgoEdHlwZRgBIAEo",
            "DjIwLnNzbi50eXBlLlRleHRBbm5vdGF0aW9uLkRldGVjdGVkQnJlYWsuQnJl",
            "YWtUeXBlEhEKCWlzX3ByZWZpeBgCIAEoCCJjCglCcmVha1R5cGUSCwoHVU5L",
            "Tk9XThAAEgkKBVNQQUNFEAESDgoKU1VSRV9TUEFDRRACEhIKDkVPTF9TVVJF",
            "X1NQQUNFEAMSCgoGSFlQSEVOEAQSDgoKTElORV9CUkVBSxAFGpUBCgxUZXh0",
            "UHJvcGVydHkSRQoSZGV0ZWN0ZWRfbGFuZ3VhZ2VzGAEgAygLMikuc3NuLnR5",
            "cGUuVGV4dEFubm90YXRpb24uRGV0ZWN0ZWRMYW5ndWFnZRI+Cg5kZXRlY3Rl",
            "ZF9icmVhaxgCIAEoCzImLnNzbi50eXBlLlRleHRBbm5vdGF0aW9uLkRldGVj",
            "dGVkQnJlYWsikwEKBFBhZ2USNwoIcHJvcGVydHkYASABKAsyJS5zc24udHlw",
            "ZS5UZXh0QW5ub3RhdGlvbi5UZXh0UHJvcGVydHkSDQoFd2lkdGgYAiABKAUS",
            "DgoGaGVpZ2h0GAMgASgFEh8KBmJsb2NrcxgEIAMoCzIPLnNzbi50eXBlLkJs",
            "b2NrEhIKCmNvbmZpZGVuY2UYBSABKAIirgIKBUJsb2NrEjcKCHByb3BlcnR5",
            "GAEgASgLMiUuc3NuLnR5cGUuVGV4dEFubm90YXRpb24uVGV4dFByb3BlcnR5",
            "EiwKDGJvdW5kaW5nX2JveBgCIAEoCzIWLnNzbi50eXBlLkJvdW5kaW5nUG9s",
            "eRInCgpwYXJhZ3JhcGhzGAMgAygLMhMuc3NuLnR5cGUuUGFyYWdyYXBoEi0K",
            "CmJsb2NrX3R5cGUYBCABKA4yGS5zc24udHlwZS5CbG9jay5CbG9ja1R5cGUS",
            "EgoKY29uZmlkZW5jZRgFIAEoAiJSCglCbG9ja1R5cGUSCwoHVU5LTk9XThAA",
            "EggKBFRFWFQQARIJCgVUQUJMRRACEgsKB1BJQ1RVUkUQAxIJCgVSVUxFUhAE",
            "EgsKB0JBUkNPREUQBSKlAQoJUGFyYWdyYXBoEjcKCHByb3BlcnR5GAEgASgL",
            "MiUuc3NuLnR5cGUuVGV4dEFubm90YXRpb24uVGV4dFByb3BlcnR5EiwKDGJv",
            "dW5kaW5nX2JveBgCIAEoCzIWLnNzbi50eXBlLkJvdW5kaW5nUG9seRIdCgV3",
            "b3JkcxgDIAMoCzIOLnNzbi50eXBlLldvcmQSEgoKY29uZmlkZW5jZRgEIAEo",
            "AiKkAQoEV29yZBI3Cghwcm9wZXJ0eRgBIAEoCzIlLnNzbi50eXBlLlRleHRB",
            "bm5vdGF0aW9uLlRleHRQcm9wZXJ0eRIsCgxib3VuZGluZ19ib3gYAiABKAsy",
            "Fi5zc24udHlwZS5Cb3VuZGluZ1BvbHkSIQoHc3ltYm9scxgDIAMoCzIQLnNz",
            "bi50eXBlLlN5bWJvbBISCgpjb25maWRlbmNlGAQgASgCIpEBCgZTeW1ib2wS",
            "NwoIcHJvcGVydHkYASABKAsyJS5zc24udHlwZS5UZXh0QW5ub3RhdGlvbi5U",
            "ZXh0UHJvcGVydHkSLAoMYm91bmRpbmdfYm94GAIgASgLMhYuc3NuLnR5cGUu",
            "Qm91bmRpbmdQb2x5EgwKBHRleHQYAyABKAkSEgoKY29uZmlkZW5jZRgEIAEo",
            "AkI2WjRnaXRodWIuY29tL2UtY29ub21pYy92bWxhcGlzL2dlbi9nby9zc24v",
            "dHlwZTtzc250eXBlYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Ssn.Type.GeometryReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.TextAnnotation), global::Ssn.Type.TextAnnotation.Parser, new[]{ "Pages", "Text" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.TextAnnotation.Types.DetectedLanguage), global::Ssn.Type.TextAnnotation.Types.DetectedLanguage.Parser, new[]{ "LanguageCode", "Confidence" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.TextAnnotation.Types.DetectedBreak), global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Parser, new[]{ "Type", "IsPrefix" }, null, new[]{ typeof(global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.TextAnnotation.Types.TextProperty), global::Ssn.Type.TextAnnotation.Types.TextProperty.Parser, new[]{ "DetectedLanguages", "DetectedBreak" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.Page), global::Ssn.Type.Page.Parser, new[]{ "Property", "Width", "Height", "Blocks", "Confidence" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.Block), global::Ssn.Type.Block.Parser, new[]{ "Property", "BoundingBox", "Paragraphs", "BlockType", "Confidence" }, null, new[]{ typeof(global::Ssn.Type.Block.Types.BlockType) }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.Paragraph), global::Ssn.Type.Paragraph.Parser, new[]{ "Property", "BoundingBox", "Words", "Confidence" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.Word), global::Ssn.Type.Word.Parser, new[]{ "Property", "BoundingBox", "Symbols", "Confidence" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Ssn.Type.Symbol), global::Ssn.Type.Symbol.Parser, new[]{ "Property", "BoundingBox", "Text", "Confidence" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// TextAnnotation contains a structured representation of OCR extracted text.
  /// The hierarchy of an OCR extracted text structure is like this:
  ///     TextAnnotation -> Page -> Block -> Paragraph -> Word -> Symbol
  /// Each structural component, starting from Page, may further have their own
  /// properties. Properties describe detected languages, breaks etc.. Please refer
  /// to the
  /// [TextAnnotation.TextProperty][google.cloud.vision.v1.TextAnnotation.TextProperty]
  /// message definition below for more detail.
  /// </summary>
  public sealed partial class TextAnnotation : pb::IMessage<TextAnnotation> {
    private static readonly pb::MessageParser<TextAnnotation> _parser = new pb::MessageParser<TextAnnotation>(() => new TextAnnotation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TextAnnotation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ssn.Type.TextAnnotationReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TextAnnotation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TextAnnotation(TextAnnotation other) : this() {
      pages_ = other.pages_.Clone();
      text_ = other.text_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TextAnnotation Clone() {
      return new TextAnnotation(this);
    }

    /// <summary>Field number for the "pages" field.</summary>
    public const int PagesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Ssn.Type.Page> _repeated_pages_codec
        = pb::FieldCodec.ForMessage(10, global::Ssn.Type.Page.Parser);
    private readonly pbc::RepeatedField<global::Ssn.Type.Page> pages_ = new pbc::RepeatedField<global::Ssn.Type.Page>();
    /// <summary>
    /// List of pages detected by OCR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Ssn.Type.Page> Pages {
      get { return pages_; }
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 2;
    private string text_ = "";
    /// <summary>
    /// UTF-8 text detected on the pages.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Text {
      get { return text_; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TextAnnotation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TextAnnotation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!pages_.Equals(other.pages_)) return false;
      if (Text != other.Text) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= pages_.GetHashCode();
      if (Text.Length != 0) hash ^= Text.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      pages_.WriteTo(output, _repeated_pages_codec);
      if (Text.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Text);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += pages_.CalculateSize(_repeated_pages_codec);
      if (Text.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TextAnnotation other) {
      if (other == null) {
        return;
      }
      pages_.Add(other.pages_);
      if (other.Text.Length != 0) {
        Text = other.Text;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            pages_.AddEntriesFrom(input, _repeated_pages_codec);
            break;
          }
          case 18: {
            Text = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TextAnnotation message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Detected language for a structural component.
      /// </summary>
      public sealed partial class DetectedLanguage : pb::IMessage<DetectedLanguage> {
        private static readonly pb::MessageParser<DetectedLanguage> _parser = new pb::MessageParser<DetectedLanguage>(() => new DetectedLanguage());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DetectedLanguage> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Ssn.Type.TextAnnotation.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DetectedLanguage() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DetectedLanguage(DetectedLanguage other) : this() {
          languageCode_ = other.languageCode_;
          confidence_ = other.confidence_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DetectedLanguage Clone() {
          return new DetectedLanguage(this);
        }

        /// <summary>Field number for the "language_code" field.</summary>
        public const int LanguageCodeFieldNumber = 1;
        private string languageCode_ = "";
        /// <summary>
        /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
        /// information, see
        /// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string LanguageCode {
          get { return languageCode_; }
          set {
            languageCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "confidence" field.</summary>
        public const int ConfidenceFieldNumber = 2;
        private float confidence_;
        /// <summary>
        /// Confidence of detected language. Range [0, 1].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Confidence {
          get { return confidence_; }
          set {
            confidence_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DetectedLanguage);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DetectedLanguage other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (LanguageCode != other.LanguageCode) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Confidence, other.Confidence)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (LanguageCode.Length != 0) hash ^= LanguageCode.GetHashCode();
          if (Confidence != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Confidence);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (LanguageCode.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(LanguageCode);
          }
          if (Confidence != 0F) {
            output.WriteRawTag(21);
            output.WriteFloat(Confidence);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (LanguageCode.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(LanguageCode);
          }
          if (Confidence != 0F) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DetectedLanguage other) {
          if (other == null) {
            return;
          }
          if (other.LanguageCode.Length != 0) {
            LanguageCode = other.LanguageCode;
          }
          if (other.Confidence != 0F) {
            Confidence = other.Confidence;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                LanguageCode = input.ReadString();
                break;
              }
              case 21: {
                Confidence = input.ReadFloat();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Detected start or end of a structural component.
      /// </summary>
      public sealed partial class DetectedBreak : pb::IMessage<DetectedBreak> {
        private static readonly pb::MessageParser<DetectedBreak> _parser = new pb::MessageParser<DetectedBreak>(() => new DetectedBreak());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DetectedBreak> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Ssn.Type.TextAnnotation.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DetectedBreak() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DetectedBreak(DetectedBreak other) : this() {
          type_ = other.type_;
          isPrefix_ = other.isPrefix_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DetectedBreak Clone() {
          return new DetectedBreak(this);
        }

        /// <summary>Field number for the "type" field.</summary>
        public const int TypeFieldNumber = 1;
        private global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType type_ = global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType.Unknown;
        /// <summary>
        /// Detected break type.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType Type {
          get { return type_; }
          set {
            type_ = value;
          }
        }

        /// <summary>Field number for the "is_prefix" field.</summary>
        public const int IsPrefixFieldNumber = 2;
        private bool isPrefix_;
        /// <summary>
        /// True if break prepends the element.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool IsPrefix {
          get { return isPrefix_; }
          set {
            isPrefix_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DetectedBreak);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DetectedBreak other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Type != other.Type) return false;
          if (IsPrefix != other.IsPrefix) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Type != global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType.Unknown) hash ^= Type.GetHashCode();
          if (IsPrefix != false) hash ^= IsPrefix.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Type != global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType.Unknown) {
            output.WriteRawTag(8);
            output.WriteEnum((int) Type);
          }
          if (IsPrefix != false) {
            output.WriteRawTag(16);
            output.WriteBool(IsPrefix);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Type != global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType.Unknown) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
          }
          if (IsPrefix != false) {
            size += 1 + 1;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DetectedBreak other) {
          if (other == null) {
            return;
          }
          if (other.Type != global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType.Unknown) {
            Type = other.Type;
          }
          if (other.IsPrefix != false) {
            IsPrefix = other.IsPrefix;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Type = (global::Ssn.Type.TextAnnotation.Types.DetectedBreak.Types.BreakType) input.ReadEnum();
                break;
              }
              case 16: {
                IsPrefix = input.ReadBool();
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the DetectedBreak message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// Enum to denote the type of break found. New line, space etc.
          /// </summary>
          public enum BreakType {
            /// <summary>
            /// Unknown break label type.
            /// </summary>
            [pbr::OriginalName("UNKNOWN")] Unknown = 0,
            /// <summary>
            /// Regular space.
            /// </summary>
            [pbr::OriginalName("SPACE")] Space = 1,
            /// <summary>
            /// Sure space (very wide).
            /// </summary>
            [pbr::OriginalName("SURE_SPACE")] SureSpace = 2,
            /// <summary>
            /// Line-wrapping break.
            /// </summary>
            [pbr::OriginalName("EOL_SURE_SPACE")] EolSureSpace = 3,
            /// <summary>
            /// End-line hyphen that is not present in text; does not co-occur with
            /// `SPACE`, `LEADER_SPACE`, or `LINE_BREAK`.
            /// </summary>
            [pbr::OriginalName("HYPHEN")] Hyphen = 4,
            /// <summary>
            /// Line break that ends a paragraph.
            /// </summary>
            [pbr::OriginalName("LINE_BREAK")] LineBreak = 5,
          }

        }
        #endregion

      }

      /// <summary>
      /// Additional information detected on the structural component.
      /// </summary>
      public sealed partial class TextProperty : pb::IMessage<TextProperty> {
        private static readonly pb::MessageParser<TextProperty> _parser = new pb::MessageParser<TextProperty>(() => new TextProperty());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TextProperty> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Ssn.Type.TextAnnotation.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TextProperty() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TextProperty(TextProperty other) : this() {
          detectedLanguages_ = other.detectedLanguages_.Clone();
          detectedBreak_ = other.detectedBreak_ != null ? other.detectedBreak_.Clone() : null;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TextProperty Clone() {
          return new TextProperty(this);
        }

        /// <summary>Field number for the "detected_languages" field.</summary>
        public const int DetectedLanguagesFieldNumber = 1;
        private static readonly pb::FieldCodec<global::Ssn.Type.TextAnnotation.Types.DetectedLanguage> _repeated_detectedLanguages_codec
            = pb::FieldCodec.ForMessage(10, global::Ssn.Type.TextAnnotation.Types.DetectedLanguage.Parser);
        private readonly pbc::RepeatedField<global::Ssn.Type.TextAnnotation.Types.DetectedLanguage> detectedLanguages_ = new pbc::RepeatedField<global::Ssn.Type.TextAnnotation.Types.DetectedLanguage>();
        /// <summary>
        /// A list of detected languages together with confidence.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Ssn.Type.TextAnnotation.Types.DetectedLanguage> DetectedLanguages {
          get { return detectedLanguages_; }
        }

        /// <summary>Field number for the "detected_break" field.</summary>
        public const int DetectedBreakFieldNumber = 2;
        private global::Ssn.Type.TextAnnotation.Types.DetectedBreak detectedBreak_;
        /// <summary>
        /// Detected start or end of a text segment.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Ssn.Type.TextAnnotation.Types.DetectedBreak DetectedBreak {
          get { return detectedBreak_; }
          set {
            detectedBreak_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TextProperty);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TextProperty other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!detectedLanguages_.Equals(other.detectedLanguages_)) return false;
          if (!object.Equals(DetectedBreak, other.DetectedBreak)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= detectedLanguages_.GetHashCode();
          if (detectedBreak_ != null) hash ^= DetectedBreak.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          detectedLanguages_.WriteTo(output, _repeated_detectedLanguages_codec);
          if (detectedBreak_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DetectedBreak);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += detectedLanguages_.CalculateSize(_repeated_detectedLanguages_codec);
          if (detectedBreak_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DetectedBreak);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TextProperty other) {
          if (other == null) {
            return;
          }
          detectedLanguages_.Add(other.detectedLanguages_);
          if (other.detectedBreak_ != null) {
            if (detectedBreak_ == null) {
              DetectedBreak = new global::Ssn.Type.TextAnnotation.Types.DetectedBreak();
            }
            DetectedBreak.MergeFrom(other.DetectedBreak);
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                detectedLanguages_.AddEntriesFrom(input, _repeated_detectedLanguages_codec);
                break;
              }
              case 18: {
                if (detectedBreak_ == null) {
                  DetectedBreak = new global::Ssn.Type.TextAnnotation.Types.DetectedBreak();
                }
                input.ReadMessage(DetectedBreak);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Detected page from OCR.
  /// </summary>
  public sealed partial class Page : pb::IMessage<Page> {
    private static readonly pb::MessageParser<Page> _parser = new pb::MessageParser<Page>(() => new Page());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Page> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ssn.Type.TextAnnotationReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Page() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Page(Page other) : this() {
      property_ = other.property_ != null ? other.property_.Clone() : null;
      width_ = other.width_;
      height_ = other.height_;
      blocks_ = other.blocks_.Clone();
      confidence_ = other.confidence_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Page Clone() {
      return new Page(this);
    }

    /// <summary>Field number for the "property" field.</summary>
    public const int PropertyFieldNumber = 1;
    private global::Ssn.Type.TextAnnotation.Types.TextProperty property_;
    /// <summary>
    /// Additional information detected on the page.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.TextAnnotation.Types.TextProperty Property {
      get { return property_; }
      set {
        property_ = value;
      }
    }

    /// <summary>Field number for the "width" field.</summary>
    public const int WidthFieldNumber = 2;
    private int width_;
    /// <summary>
    /// Page width. For PDFs the unit is points. For images (including
    /// TIFFs) the unit is pixels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Width {
      get { return width_; }
      set {
        width_ = value;
      }
    }

    /// <summary>Field number for the "height" field.</summary>
    public const int HeightFieldNumber = 3;
    private int height_;
    /// <summary>
    /// Page height. For PDFs the unit is points. For images (including
    /// TIFFs) the unit is pixels.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Height {
      get { return height_; }
      set {
        height_ = value;
      }
    }

    /// <summary>Field number for the "blocks" field.</summary>
    public const int BlocksFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Ssn.Type.Block> _repeated_blocks_codec
        = pb::FieldCodec.ForMessage(34, global::Ssn.Type.Block.Parser);
    private readonly pbc::RepeatedField<global::Ssn.Type.Block> blocks_ = new pbc::RepeatedField<global::Ssn.Type.Block>();
    /// <summary>
    /// List of blocks of text, images etc on this page.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Ssn.Type.Block> Blocks {
      get { return blocks_; }
    }

    /// <summary>Field number for the "confidence" field.</summary>
    public const int ConfidenceFieldNumber = 5;
    private float confidence_;
    /// <summary>
    /// Confidence of the OCR results on the page. Range [0, 1].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Confidence {
      get { return confidence_; }
      set {
        confidence_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Page);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Page other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Property, other.Property)) return false;
      if (Width != other.Width) return false;
      if (Height != other.Height) return false;
      if(!blocks_.Equals(other.blocks_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Confidence, other.Confidence)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (property_ != null) hash ^= Property.GetHashCode();
      if (Width != 0) hash ^= Width.GetHashCode();
      if (Height != 0) hash ^= Height.GetHashCode();
      hash ^= blocks_.GetHashCode();
      if (Confidence != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Confidence);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (property_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Property);
      }
      if (Width != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Width);
      }
      if (Height != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(Height);
      }
      blocks_.WriteTo(output, _repeated_blocks_codec);
      if (Confidence != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(Confidence);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (property_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Property);
      }
      if (Width != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Width);
      }
      if (Height != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Height);
      }
      size += blocks_.CalculateSize(_repeated_blocks_codec);
      if (Confidence != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Page other) {
      if (other == null) {
        return;
      }
      if (other.property_ != null) {
        if (property_ == null) {
          Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
        }
        Property.MergeFrom(other.Property);
      }
      if (other.Width != 0) {
        Width = other.Width;
      }
      if (other.Height != 0) {
        Height = other.Height;
      }
      blocks_.Add(other.blocks_);
      if (other.Confidence != 0F) {
        Confidence = other.Confidence;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (property_ == null) {
              Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
            }
            input.ReadMessage(Property);
            break;
          }
          case 16: {
            Width = input.ReadInt32();
            break;
          }
          case 24: {
            Height = input.ReadInt32();
            break;
          }
          case 34: {
            blocks_.AddEntriesFrom(input, _repeated_blocks_codec);
            break;
          }
          case 45: {
            Confidence = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Logical element on the page.
  /// </summary>
  public sealed partial class Block : pb::IMessage<Block> {
    private static readonly pb::MessageParser<Block> _parser = new pb::MessageParser<Block>(() => new Block());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Block> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ssn.Type.TextAnnotationReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Block() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Block(Block other) : this() {
      property_ = other.property_ != null ? other.property_.Clone() : null;
      boundingBox_ = other.boundingBox_ != null ? other.boundingBox_.Clone() : null;
      paragraphs_ = other.paragraphs_.Clone();
      blockType_ = other.blockType_;
      confidence_ = other.confidence_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Block Clone() {
      return new Block(this);
    }

    /// <summary>Field number for the "property" field.</summary>
    public const int PropertyFieldNumber = 1;
    private global::Ssn.Type.TextAnnotation.Types.TextProperty property_;
    /// <summary>
    /// Additional information detected for the block.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.TextAnnotation.Types.TextProperty Property {
      get { return property_; }
      set {
        property_ = value;
      }
    }

    /// <summary>Field number for the "bounding_box" field.</summary>
    public const int BoundingBoxFieldNumber = 2;
    private global::Ssn.Type.BoundingPoly boundingBox_;
    /// <summary>
    /// The bounding box for the block.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///
    ///         0----1
    ///         |    |
    ///         3----2
    ///
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///
    ///         2----3
    ///         |    |
    ///         1----0
    ///
    ///   and the vertex order will still be (0, 1, 2, 3).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.BoundingPoly BoundingBox {
      get { return boundingBox_; }
      set {
        boundingBox_ = value;
      }
    }

    /// <summary>Field number for the "paragraphs" field.</summary>
    public const int ParagraphsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Ssn.Type.Paragraph> _repeated_paragraphs_codec
        = pb::FieldCodec.ForMessage(26, global::Ssn.Type.Paragraph.Parser);
    private readonly pbc::RepeatedField<global::Ssn.Type.Paragraph> paragraphs_ = new pbc::RepeatedField<global::Ssn.Type.Paragraph>();
    /// <summary>
    /// List of paragraphs in this block (if this blocks is of type text).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Ssn.Type.Paragraph> Paragraphs {
      get { return paragraphs_; }
    }

    /// <summary>Field number for the "block_type" field.</summary>
    public const int BlockTypeFieldNumber = 4;
    private global::Ssn.Type.Block.Types.BlockType blockType_ = global::Ssn.Type.Block.Types.BlockType.Unknown;
    /// <summary>
    /// Detected block type (text, image etc) for this block.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.Block.Types.BlockType BlockType {
      get { return blockType_; }
      set {
        blockType_ = value;
      }
    }

    /// <summary>Field number for the "confidence" field.</summary>
    public const int ConfidenceFieldNumber = 5;
    private float confidence_;
    /// <summary>
    /// Confidence of the OCR results on the block. Range [0, 1].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Confidence {
      get { return confidence_; }
      set {
        confidence_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Block);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Block other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Property, other.Property)) return false;
      if (!object.Equals(BoundingBox, other.BoundingBox)) return false;
      if(!paragraphs_.Equals(other.paragraphs_)) return false;
      if (BlockType != other.BlockType) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Confidence, other.Confidence)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (property_ != null) hash ^= Property.GetHashCode();
      if (boundingBox_ != null) hash ^= BoundingBox.GetHashCode();
      hash ^= paragraphs_.GetHashCode();
      if (BlockType != global::Ssn.Type.Block.Types.BlockType.Unknown) hash ^= BlockType.GetHashCode();
      if (Confidence != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Confidence);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (property_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Property);
      }
      if (boundingBox_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BoundingBox);
      }
      paragraphs_.WriteTo(output, _repeated_paragraphs_codec);
      if (BlockType != global::Ssn.Type.Block.Types.BlockType.Unknown) {
        output.WriteRawTag(32);
        output.WriteEnum((int) BlockType);
      }
      if (Confidence != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(Confidence);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (property_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Property);
      }
      if (boundingBox_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoundingBox);
      }
      size += paragraphs_.CalculateSize(_repeated_paragraphs_codec);
      if (BlockType != global::Ssn.Type.Block.Types.BlockType.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BlockType);
      }
      if (Confidence != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Block other) {
      if (other == null) {
        return;
      }
      if (other.property_ != null) {
        if (property_ == null) {
          Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
        }
        Property.MergeFrom(other.Property);
      }
      if (other.boundingBox_ != null) {
        if (boundingBox_ == null) {
          BoundingBox = new global::Ssn.Type.BoundingPoly();
        }
        BoundingBox.MergeFrom(other.BoundingBox);
      }
      paragraphs_.Add(other.paragraphs_);
      if (other.BlockType != global::Ssn.Type.Block.Types.BlockType.Unknown) {
        BlockType = other.BlockType;
      }
      if (other.Confidence != 0F) {
        Confidence = other.Confidence;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (property_ == null) {
              Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
            }
            input.ReadMessage(Property);
            break;
          }
          case 18: {
            if (boundingBox_ == null) {
              BoundingBox = new global::Ssn.Type.BoundingPoly();
            }
            input.ReadMessage(BoundingBox);
            break;
          }
          case 26: {
            paragraphs_.AddEntriesFrom(input, _repeated_paragraphs_codec);
            break;
          }
          case 32: {
            BlockType = (global::Ssn.Type.Block.Types.BlockType) input.ReadEnum();
            break;
          }
          case 45: {
            Confidence = input.ReadFloat();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Block message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Type of a block (text, image etc) as identified by OCR.
      /// </summary>
      public enum BlockType {
        /// <summary>
        /// Unknown block type.
        /// </summary>
        [pbr::OriginalName("UNKNOWN")] Unknown = 0,
        /// <summary>
        /// Regular text block.
        /// </summary>
        [pbr::OriginalName("TEXT")] Text = 1,
        /// <summary>
        /// Table block.
        /// </summary>
        [pbr::OriginalName("TABLE")] Table = 2,
        /// <summary>
        /// Image block.
        /// </summary>
        [pbr::OriginalName("PICTURE")] Picture = 3,
        /// <summary>
        /// Horizontal/vertical line box.
        /// </summary>
        [pbr::OriginalName("RULER")] Ruler = 4,
        /// <summary>
        /// Barcode block.
        /// </summary>
        [pbr::OriginalName("BARCODE")] Barcode = 5,
      }

    }
    #endregion

  }

  /// <summary>
  /// Structural unit of text representing a number of words in certain order.
  /// </summary>
  public sealed partial class Paragraph : pb::IMessage<Paragraph> {
    private static readonly pb::MessageParser<Paragraph> _parser = new pb::MessageParser<Paragraph>(() => new Paragraph());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Paragraph> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ssn.Type.TextAnnotationReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Paragraph() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Paragraph(Paragraph other) : this() {
      property_ = other.property_ != null ? other.property_.Clone() : null;
      boundingBox_ = other.boundingBox_ != null ? other.boundingBox_.Clone() : null;
      words_ = other.words_.Clone();
      confidence_ = other.confidence_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Paragraph Clone() {
      return new Paragraph(this);
    }

    /// <summary>Field number for the "property" field.</summary>
    public const int PropertyFieldNumber = 1;
    private global::Ssn.Type.TextAnnotation.Types.TextProperty property_;
    /// <summary>
    /// Additional information detected for the paragraph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.TextAnnotation.Types.TextProperty Property {
      get { return property_; }
      set {
        property_ = value;
      }
    }

    /// <summary>Field number for the "bounding_box" field.</summary>
    public const int BoundingBoxFieldNumber = 2;
    private global::Ssn.Type.BoundingPoly boundingBox_;
    /// <summary>
    /// The bounding box for the paragraph.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///   * when the text is horizontal it might look like:
    ///      0----1
    ///      |    |
    ///      3----2
    ///   * when it's rotated 180 degrees around the top-left corner it becomes:
    ///      2----3
    ///      |    |
    ///      1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.BoundingPoly BoundingBox {
      get { return boundingBox_; }
      set {
        boundingBox_ = value;
      }
    }

    /// <summary>Field number for the "words" field.</summary>
    public const int WordsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Ssn.Type.Word> _repeated_words_codec
        = pb::FieldCodec.ForMessage(26, global::Ssn.Type.Word.Parser);
    private readonly pbc::RepeatedField<global::Ssn.Type.Word> words_ = new pbc::RepeatedField<global::Ssn.Type.Word>();
    /// <summary>
    /// List of words in this paragraph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Ssn.Type.Word> Words {
      get { return words_; }
    }

    /// <summary>Field number for the "confidence" field.</summary>
    public const int ConfidenceFieldNumber = 4;
    private float confidence_;
    /// <summary>
    /// Confidence of the OCR results for the paragraph. Range [0, 1].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Confidence {
      get { return confidence_; }
      set {
        confidence_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Paragraph);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Paragraph other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Property, other.Property)) return false;
      if (!object.Equals(BoundingBox, other.BoundingBox)) return false;
      if(!words_.Equals(other.words_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Confidence, other.Confidence)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (property_ != null) hash ^= Property.GetHashCode();
      if (boundingBox_ != null) hash ^= BoundingBox.GetHashCode();
      hash ^= words_.GetHashCode();
      if (Confidence != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Confidence);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (property_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Property);
      }
      if (boundingBox_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BoundingBox);
      }
      words_.WriteTo(output, _repeated_words_codec);
      if (Confidence != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Confidence);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (property_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Property);
      }
      if (boundingBox_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoundingBox);
      }
      size += words_.CalculateSize(_repeated_words_codec);
      if (Confidence != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Paragraph other) {
      if (other == null) {
        return;
      }
      if (other.property_ != null) {
        if (property_ == null) {
          Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
        }
        Property.MergeFrom(other.Property);
      }
      if (other.boundingBox_ != null) {
        if (boundingBox_ == null) {
          BoundingBox = new global::Ssn.Type.BoundingPoly();
        }
        BoundingBox.MergeFrom(other.BoundingBox);
      }
      words_.Add(other.words_);
      if (other.Confidence != 0F) {
        Confidence = other.Confidence;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (property_ == null) {
              Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
            }
            input.ReadMessage(Property);
            break;
          }
          case 18: {
            if (boundingBox_ == null) {
              BoundingBox = new global::Ssn.Type.BoundingPoly();
            }
            input.ReadMessage(BoundingBox);
            break;
          }
          case 26: {
            words_.AddEntriesFrom(input, _repeated_words_codec);
            break;
          }
          case 37: {
            Confidence = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A word representation.
  /// </summary>
  public sealed partial class Word : pb::IMessage<Word> {
    private static readonly pb::MessageParser<Word> _parser = new pb::MessageParser<Word>(() => new Word());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Word> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ssn.Type.TextAnnotationReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Word() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Word(Word other) : this() {
      property_ = other.property_ != null ? other.property_.Clone() : null;
      boundingBox_ = other.boundingBox_ != null ? other.boundingBox_.Clone() : null;
      symbols_ = other.symbols_.Clone();
      confidence_ = other.confidence_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Word Clone() {
      return new Word(this);
    }

    /// <summary>Field number for the "property" field.</summary>
    public const int PropertyFieldNumber = 1;
    private global::Ssn.Type.TextAnnotation.Types.TextProperty property_;
    /// <summary>
    /// Additional information detected for the word.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.TextAnnotation.Types.TextProperty Property {
      get { return property_; }
      set {
        property_ = value;
      }
    }

    /// <summary>Field number for the "bounding_box" field.</summary>
    public const int BoundingBoxFieldNumber = 2;
    private global::Ssn.Type.BoundingPoly boundingBox_;
    /// <summary>
    /// The bounding box for the word.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///   * when the text is horizontal it might look like:
    ///      0----1
    ///      |    |
    ///      3----2
    ///   * when it's rotated 180 degrees around the top-left corner it becomes:
    ///      2----3
    ///      |    |
    ///      1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.BoundingPoly BoundingBox {
      get { return boundingBox_; }
      set {
        boundingBox_ = value;
      }
    }

    /// <summary>Field number for the "symbols" field.</summary>
    public const int SymbolsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Ssn.Type.Symbol> _repeated_symbols_codec
        = pb::FieldCodec.ForMessage(26, global::Ssn.Type.Symbol.Parser);
    private readonly pbc::RepeatedField<global::Ssn.Type.Symbol> symbols_ = new pbc::RepeatedField<global::Ssn.Type.Symbol>();
    /// <summary>
    /// List of symbols in the word.
    /// The order of the symbols follows the natural reading order.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Ssn.Type.Symbol> Symbols {
      get { return symbols_; }
    }

    /// <summary>Field number for the "confidence" field.</summary>
    public const int ConfidenceFieldNumber = 4;
    private float confidence_;
    /// <summary>
    /// Confidence of the OCR results for the word. Range [0, 1].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Confidence {
      get { return confidence_; }
      set {
        confidence_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Word);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Word other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Property, other.Property)) return false;
      if (!object.Equals(BoundingBox, other.BoundingBox)) return false;
      if(!symbols_.Equals(other.symbols_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Confidence, other.Confidence)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (property_ != null) hash ^= Property.GetHashCode();
      if (boundingBox_ != null) hash ^= BoundingBox.GetHashCode();
      hash ^= symbols_.GetHashCode();
      if (Confidence != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Confidence);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (property_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Property);
      }
      if (boundingBox_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BoundingBox);
      }
      symbols_.WriteTo(output, _repeated_symbols_codec);
      if (Confidence != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Confidence);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (property_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Property);
      }
      if (boundingBox_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoundingBox);
      }
      size += symbols_.CalculateSize(_repeated_symbols_codec);
      if (Confidence != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Word other) {
      if (other == null) {
        return;
      }
      if (other.property_ != null) {
        if (property_ == null) {
          Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
        }
        Property.MergeFrom(other.Property);
      }
      if (other.boundingBox_ != null) {
        if (boundingBox_ == null) {
          BoundingBox = new global::Ssn.Type.BoundingPoly();
        }
        BoundingBox.MergeFrom(other.BoundingBox);
      }
      symbols_.Add(other.symbols_);
      if (other.Confidence != 0F) {
        Confidence = other.Confidence;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (property_ == null) {
              Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
            }
            input.ReadMessage(Property);
            break;
          }
          case 18: {
            if (boundingBox_ == null) {
              BoundingBox = new global::Ssn.Type.BoundingPoly();
            }
            input.ReadMessage(BoundingBox);
            break;
          }
          case 26: {
            symbols_.AddEntriesFrom(input, _repeated_symbols_codec);
            break;
          }
          case 37: {
            Confidence = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A single symbol representation.
  /// </summary>
  public sealed partial class Symbol : pb::IMessage<Symbol> {
    private static readonly pb::MessageParser<Symbol> _parser = new pb::MessageParser<Symbol>(() => new Symbol());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Symbol> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Ssn.Type.TextAnnotationReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Symbol() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Symbol(Symbol other) : this() {
      property_ = other.property_ != null ? other.property_.Clone() : null;
      boundingBox_ = other.boundingBox_ != null ? other.boundingBox_.Clone() : null;
      text_ = other.text_;
      confidence_ = other.confidence_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Symbol Clone() {
      return new Symbol(this);
    }

    /// <summary>Field number for the "property" field.</summary>
    public const int PropertyFieldNumber = 1;
    private global::Ssn.Type.TextAnnotation.Types.TextProperty property_;
    /// <summary>
    /// Additional information detected for the symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.TextAnnotation.Types.TextProperty Property {
      get { return property_; }
      set {
        property_ = value;
      }
    }

    /// <summary>Field number for the "bounding_box" field.</summary>
    public const int BoundingBoxFieldNumber = 2;
    private global::Ssn.Type.BoundingPoly boundingBox_;
    /// <summary>
    /// The bounding box for the symbol.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///   * when the text is horizontal it might look like:
    ///      0----1
    ///      |    |
    ///      3----2
    ///   * when it's rotated 180 degrees around the top-left corner it becomes:
    ///      2----3
    ///      |    |
    ///      1----0
    ///   and the vertice order will still be (0, 1, 2, 3).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Ssn.Type.BoundingPoly BoundingBox {
      get { return boundingBox_; }
      set {
        boundingBox_ = value;
      }
    }

    /// <summary>Field number for the "text" field.</summary>
    public const int TextFieldNumber = 3;
    private string text_ = "";
    /// <summary>
    /// The actual UTF-8 representation of the symbol.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Text {
      get { return text_; }
      set {
        text_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "confidence" field.</summary>
    public const int ConfidenceFieldNumber = 4;
    private float confidence_;
    /// <summary>
    /// Confidence of the OCR results for the symbol. Range [0, 1].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Confidence {
      get { return confidence_; }
      set {
        confidence_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Symbol);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Symbol other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Property, other.Property)) return false;
      if (!object.Equals(BoundingBox, other.BoundingBox)) return false;
      if (Text != other.Text) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Confidence, other.Confidence)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (property_ != null) hash ^= Property.GetHashCode();
      if (boundingBox_ != null) hash ^= BoundingBox.GetHashCode();
      if (Text.Length != 0) hash ^= Text.GetHashCode();
      if (Confidence != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Confidence);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (property_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Property);
      }
      if (boundingBox_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BoundingBox);
      }
      if (Text.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Text);
      }
      if (Confidence != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(Confidence);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (property_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Property);
      }
      if (boundingBox_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoundingBox);
      }
      if (Text.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Text);
      }
      if (Confidence != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Symbol other) {
      if (other == null) {
        return;
      }
      if (other.property_ != null) {
        if (property_ == null) {
          Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
        }
        Property.MergeFrom(other.Property);
      }
      if (other.boundingBox_ != null) {
        if (boundingBox_ == null) {
          BoundingBox = new global::Ssn.Type.BoundingPoly();
        }
        BoundingBox.MergeFrom(other.BoundingBox);
      }
      if (other.Text.Length != 0) {
        Text = other.Text;
      }
      if (other.Confidence != 0F) {
        Confidence = other.Confidence;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (property_ == null) {
              Property = new global::Ssn.Type.TextAnnotation.Types.TextProperty();
            }
            input.ReadMessage(Property);
            break;
          }
          case 18: {
            if (boundingBox_ == null) {
              BoundingBox = new global::Ssn.Type.BoundingPoly();
            }
            input.ReadMessage(BoundingBox);
            break;
          }
          case 26: {
            Text = input.ReadString();
            break;
          }
          case 37: {
            Confidence = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
